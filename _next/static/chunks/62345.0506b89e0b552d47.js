(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[62345],{75410:function(){},48628:function(){},31601:function(){},67792:function(){},34977:function(){},75042:function(){},26378:function(e,t,i){"use strict";i.r(t),i.d(t,{AppUpscaler:function(){return ej},Solution:function(){return eD}});let r=e=>Array.isArray(e),o=e=>r(e)?e[0]:e,n=(({scale:e,name:t,version:i,meta:{architecture:r,...n},path:s})=>{let a=s||`models/x${e}/model.json`;return"rdn"===r?{scale:e,modelType:"layers",_internals:{path:a,name:t,version:i},meta:{architecture:r,...n},inputRange:[0,255],outputRange:[0,255]}:{setup:t=>{let i=t.layers.Layer;class r extends i{beta;constructor(){super({}),this.beta=.2}call(e){return t.mul(o(e),this.beta)}static className="MultiplyBeta"}[r,(r=>{class n extends i{scale=r;constructor(){super({})}computeOutputShape(e){return[e[0],e[1],e[2],3]}call(e){return t.depthToSpace(o(e),this.scale,"NHWC")}static className=`PixelShuffle${e}x`}return n})(e)].forEach(e=>{t.serialization.registerClass(e)})},scale:e,modelType:"layers",_internals:{path:a,name:t,version:i},meta:{architecture:r,...n},inputRange:[0,1],outputRange:[0,1]}})({scale:2,name:"@upscalerjs/default-model",version:"1.0.0-beta.17",path:"models/model.json",meta:{C:1,D:2,G:4,G0:64,T:10,architecture:"rdn",patchSize:128,size:"slim",artifactReducing:!1,sharpening:!1,dataset:"div2k",modelFileName:"rdn-C1-D2-G4-G064-T10-x2-patchsize128-compress100-sharpen0-datadiv2k-vary_cFalse_best-val_loss_epoch494"}});var s,a,l=i(94976);(a=s||(s={})).UNDEFINED="undefined",a.INVALID_MODEL_TYPE="invalidModelType",a.MISSING_PATH="missingPath";let d=e=>!!(e&&Array.isArray(e))&&4===e.length&&e.every(e=>null===e||"number"==typeof e),u=e=>d(e)&&null!==e[1]&&null!==e[2]&&e[1]>0&&e[2]>0;function p(e){return function(t){try{return t.shape.length===e}catch(e){}return!1}}let c=p(4),h=p(3),m=e=>e instanceof l.Tensor,f=e=>"string"==typeof e,g=e=>"string"==typeof e&&["layers","graph"].includes(e);class y extends Error{type;constructor(e){super(e),this.type=e}}let w=e=>{if(void 0===e)throw new y(s.UNDEFINED);if(!g(e.modelType??"layers"))throw new y(s.INVALID_MODEL_TYPE);if(!e.path&&!e._internals?.path)throw new y(s.MISSING_PATH);return!0},v=e=>"number"==typeof e,b=e=>Array.isArray(e)&&2===e.length&&e.every(v),E=e=>{console.warn(Array.isArray(e)?e.join("\n"):e)};function z(e){return void 0!==e&&"function"==typeof e}let x=(e,t,i)=>!!z(e)&&!(e.length<=1)&&(void 0===i&&"tensor"===t||"tensor"===i),S=e=>!!e&&e.aborted;async function I(e,t){let i;for(i=await e.next();!i.done;i=await e.next())t&&await t(i.value);return i.value}function _(e){return null!=e}function T(e,t,...i){let r=i.filter(_);if(r.length){let i=e.tidy(()=>r.reduce((e,t)=>t(e),t));return t.isDisposed||t===i||t.dispose(),i}return t}let C=e=>e instanceof y,A=e=>`The tensor returned by the model was not a valid rank-4 tensor. It's shape is ${JSON.stringify(e)}.} UpscalerJS only supports models returning valid image-like data in four dimensional form. For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-predicted-tensor.`,N=Error("No defined tensors were passed to concatTensors");class j extends Error{message="The upscale request received an abort signal"}let D=e=>`You've provided an invalid model type: ${JSON.stringify(e)}. Accepted types are "layers" and "graph". For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-model-type.`,$="There is a bug with the upscaler code. Please report this.",k=e=>`Expected model to have a rank-4 compatible input shape. Instead got: ${JSON.stringify(e)}. For more information, see https://upscalerjs.com/documentation/troubleshooting#error-with-model-input-shape.`,M=e=>Error(`Invalid patch size: ${e}. Patch size must be greater than 0.`),F=(e,t)=>Error(`Invalid patch size and padding: ${e} and ${t}. Patch size must be greater than padding * 2.`),O=(e,t,i)=>`Invalid patch size: ${e}. The model has a defined divibility factor of ${t} and patch size must be a multiple of this number. Patch size has been scaled up to ${i}. 
For more information, see https://upscalerjs.com/documentation/troubleshooting#patch-size-indivisible-by-divisibility-factor.`,P=Error("Model input sizes must be square. If you are using a model with a non-square input size and would like to request support, please file a feature request at https://github.com/thekevinscott/upscalerjs"),L=e=>`Provided model configuration is missing both a "path" and "_internals". A valid path to a model JSON file must be provided. For more information, see https://upscalerjs.com/documentation/troubleshooting#missing-path-and-internals. The model configuration provided was: ${JSON.stringify(e)}`,H=(e,t,i)=>async r=>{if(i&&await e.nextFrame(),S(t))throw Array.isArray(r)?r.forEach(e=>e?.dispose()):m(r)&&r.dispose(),new j},R=e=>!!e&&"object"==typeof e&&"patchSize"in e&&"number"==typeof e.patchSize,U=e=>!!e&&"number"==typeof e&&e>0,J=e=>["Invalid value passed to warmup in warmupSizes:",JSON.stringify(e),"For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-warmup-value."].join("\n"),G=e=>Error(J(e)),q=e=>{if(R(e)){let{patchSize:t}=e;return t}return e};async function*B(e,t,i){let{model:r,modelDefinition:o}=await t;for(let t of i){if(!R(t)&&!U(t))throw G(t);let i=q(t),n=e.zeros([1,i,i,3]);for(let t of(yield[n],[o.preprocess,e=>r.predict(e),o.postprocess].filter(Boolean)))n=T(e,n,t),yield[n];n.dispose(),yield}}let V=e=>{if(Array.isArray(e)){for(let t of e)if(!R(t)&&!U(t))throw G(e);return e}if(R(e)||U(e))return[e];throw G(e)},Y=async(e,t,i,{signal:r,awaitNextFrame:o=!1}={},n)=>{let s=H(e,r||n.signal,o);await s(),await I(B(e,t,V(i)),s)},W=(e,t)=>t instanceof e.LayersModel,K=e=>({...e});async function Q(e,t){let i="function"==typeof t?(E("Passing a model definition as a function is deprecated and will be removed in a future version. To leverage model lifecycle methods, use the setup and teardown methods. For more information, see https://upscalerjs.com/documentation/troubleshooting#deprecated-model-definition-function."),t(e)):t;return i.setup&&await i.setup(e),i}function X(e,t,i){return"graph"===i?e.loadGraphModel(t):e.loadLayersModel(t)}let Z=(e,t)=>W(e,t)?t.layers[0].batchInputShape:t.inputs[0].shape,ee=(e,{model:t})=>{let i=Z(e,t);if(!d(i))throw Error(k(i));return i},et=(e,t)=>Math.ceil(t/e)*e,ei=(e,t,{patchSize:i,padding:r},o)=>{let n=ee(e,t);if(void 0!==i){if(i<=0)throw M(i);if(void 0!==r&&2*r>=i)throw F(i,r)}if(u(n)){if(void 0!==i&&E("You have provided a patchSize, but the model definition already includes an input size. Your patchSize will be ignored. For more information, see https://upscalerjs.com/documentation/troubleshooting#input-size-and-patch-size."),n[1]!==n[2])throw P;return{patchSize:n[1],padding:r,modelInputShape:n}}void 0!==i&&void 0===r&&E('"padding" is undefined, but "patchSize" is explicitly defined. Without padding, patches of images often have visible artifacting at the seams. Defining an explicit padding will resolve the artifacting. For more information, see https://upscalerjs.com/documentation/troubleshooting#padding-is-undefined. To hide this warning, pass an explicit padding of "0".');let{divisibilityFactor:s}=t.modelDefinition;if(void 0!==s){if(void 0!==i){let e=et(s,i);return e!==i&&E(O(i,s,e)),{patchSize:e,padding:r,modelInputShape:[null,e,e,3]}}return{patchSize:void 0,padding:void 0,modelInputShape:[null,et(s,o[1]),et(s,o[2]),3]}}return{patchSize:i,padding:r,modelInputShape:void 0}},er=(e,t)=>i=>{let r=i.shape[1],o=i.shape[2];return u(t)&&(t[1]>r||t[2]>o)?e.tidy(()=>{let n=Math.max(r,t[1]),s=Math.max(o,t[2]),a=e.zeros([1,r,s-o,3]),l=e.zeros([1,n-r,s,3]),d=e.concat([i,a],2);return e.concat([d,l],1)}):i},eo=(e,t,i)=>r=>{let o=t[1]*i,n=t[2]*i;return o<r.shape[1]||n<r.shape[2]?e.tidy(()=>e.slice(r,[0,0,0],[1,o,n,3])):r},en=e=>t=>{let i=b(e)?e[1]:255;return t.clipByValue(0,i).mul(1===i?255:1)},es=(e,t)=>i=>b(t)&&1===t[1]?e.mul(i,1/255):i,ea=(e,t)=>e.tidy(()=>{let[i,r]=t.shape,o=e.fill([i,r],255).expandDims(2);return t.clipByValue(0,255).concat([o],2).dataSync()});function el(e,t,i=0){let r=t.filter(_);if(0===r.length)throw N;let o=e.concat(r,i);return t.forEach(e=>e?.dispose()),o}let ed=(e,t,i,r)=>{let o=t,n=0===t?0:i===e?0:r,s=o+i>e,a=s?i-(e-o):0,l=s?0:i===e?0:r,d=s?0:n,u=i-(s?a:0);return s&&(o=e-i),{pre:{origin:o-=d,size:i},post:{origin:a+=d,size:u-=d+l},increment:i>e?e:i-n-l}},eu=([e,t],i,r)=>{let o=[],n=0,s=0;for(;s<t;){let{pre:{origin:a,size:l},post:{origin:d,size:u},increment:p}=ed(t,s,Math.min(i,t),r),c=[];for(;n<e;){let{pre:{origin:t,size:o},post:{origin:s,size:p},increment:h}=ed(e,n,Math.min(i,e),r);c.push({pre:{origin:[a,t],size:[l,o]},post:{origin:[d,s],size:[u,p]}}),n+=h}o.push(c),n=0,s+=p}return o},ep=(e,t,i,r)=>(e*i+t+1)/r,ec=(e,t)=>{let i=e.predict(t);if(!m(i))throw Error("The model output was not a valid tensor. UpscalerJS only supports models returning valid tensors. This is likely an error with the model itself, not UpscalerJS. For more information, see https://upscalerjs.com/documentation/troubleshooting#invalid-model-prediction.");if(c(i))return i;throw Error(A(i.shape))};async function*eh(e,t,{output:i,progress:r,progressOutput:o},n,{originalImageSize:s,patchSize:a,padding:l=0},{tensorAsBase64:d}){let{model:u,modelDefinition:p}=n,c=p.scale??1;if(a){let n;let[h,m]=t.shape.slice(1),f=eu([m,h],a,l);yield;let g=f.length*f[0].length;for(let s=0;s<f.length;s++){let a;let l=f[s],h=l.length;yield[a,n];for(let m=0;m<h;m++){let{pre:f,post:y}=l[m];yield[n,a];let w=t.slice([0,...f.origin],[-1,...f.size]);yield[n,a,w];let v=ec(u,w);w.dispose(),yield[n,a,v];let b=[0,y.origin[0]*c,y.origin[1]*c],E=[-1,y.size[0]*c,y.size[1]*c],S=v.slice(b,E);v.dispose(),yield[n,a,S];let I=T(e,S,p.postprocess,en(p.outputRange));if(yield[n,a,I],void 0!==r&&z(r)){let t=ep(s,m,h,g);if(z(r)&&r.length<=1)r(t);else{let n=I.squeeze(),a={row:s,col:m,patchCoordinates:{pre:f,post:y}};if(x(r,i,o))r(t,n,a);else{let i=d(e,n);n.dispose(),r(t,i,a)}}}yield[n,a,I],a=el(e,[a,I],2),I.dispose(),yield[n,a]}n=el(e,[n,a],1),a.dispose(),yield[n]}let y=T(e,n.clone(),eo(e,s,c));n?.dispose(),yield[y];let w=y.squeeze();return y.dispose(),w}r&&E('The "progress" callback was provided but "patchSize" was not defined. Without a "patchSize", the "progress" callback will never be called. For more information, see https://upscalerjs.com/documentation/troubleshooting#progress-specified-without-patch-size.');let h=ec(u,t);yield[h];let m=T(e,h.clone(),p.postprocess,en(p.outputRange),eo(e,s,c));h.dispose(),yield[m];let f=m.squeeze();return m.dispose(),f}async function*em(e,t,i,r,{getImageAsTensor:o,tensorAsBase64:n}){let s=m(t)?t.clone():t,a=await o(e,s);yield a;let l=a.shape,{patchSize:d,padding:u,modelInputShape:p}=ei(e,r,i,l),c=T(e,a,r.modelDefinition.preprocess,es(e,r.modelDefinition.inputRange),p?er(e,p):void 0);yield c;let h=eh(e,c,{output:i.output,progressOutput:i.progressOutput,progress:i.progress},r,{originalImageSize:l,patchSize:d,padding:u},{tensorAsBase64:n}),f=await h.next();for(yield f.value;!f.done;)Array.isArray((f=await h.next()).value)?yield[...f.value,c]:m(f.value)?yield[f.value,c]:yield c;c.dispose();let g=f.value;if("tensor"===i.output)return g;let y=n(e,g);return g.dispose(),y}async function ef(e,t,{signal:i,awaitNextFrame:r,...o},n,{checkValidEnvironment:s,...a}){s(t,{output:o.output,progressOutput:o.progressOutput});let l=H(e,i||n.signal,r);await l();let d=await I(em(e,t,o,n,a),l);return await l(),d}var eg=i(88405);let ey=e=>"tensor"===e?"tensor":"base64",ew={jsdelivr:(e,t,i)=>`https://cdn.jsdelivr.net/npm/${e}@${t}/${i}`,unpkg:(e,t,i)=>`https://unpkg.com/${e}@${t}/${i}`},ev=["jsdelivr","unpkg"],eb=(e,t,i)=>Error([`Could not resolve URL ${t} for package ${i?.name}@${i?.version}`,"Errors include:",...e.map(([e,t])=>`- ${e}: ${t.message}`)].join("\n"));async function eE(e,t){let{modelType:i,_internals:r,path:o}=t;if(o)return await X(e,o,i);if(!r)throw Error($);let n=[];for(let t of ev){let o=ew[t];try{let t=o(r.name,r.version,r.path);return await X(e,t,i)}catch(e){n.push([t,e instanceof Error?e:Error(`There was an unknown error: ${JSON.stringify(e)}`)])}}throw eb(n,o||r.path,r)}let ez=()=>Error(`Environment does not support a string URL as an input format.
For more information, see https://upscalerjs.com/documentation/troubleshooting#environment-disallows-string-input.`),ex=()=>Error(`Environment does not support base64 as an output format.
For more information, see https://upscalerjs.com/documentation/troubleshooting#environment-disallows-base64.`),eS=e=>Error(`Unsupported dimensions for incoming pixels: ${e.shape.length}.
Only 3 or 4 rank tensors are supported.`),eI=()=>Error("Failed to load image"),e_=e=>new Promise((t,i)=>{let r=new Image;r.src=e,r.crossOrigin="anonymous",r.onload=()=>t(r),r.onerror=()=>i(eI())}),eT=e=>eg.browser.fromPixelsAsync(e),eC=async(e,t)=>m(e)?e:f(e)?eT(await e_(e)):eT(e),eA=e=>{try{if(new Image,"createElement"in document!=!0)throw e()}catch(t){throw e()}};var eN=function({tf:e,getUpscaleOptions:t,checkValidEnvironment:i,getImageAsTensor:r,tensorAsBase64:o,loadModel:s}){class a{_opts;_model;ready;_abortController=new AbortController;constructor(t={}){this._opts={...t},this._model=s(e,Q(e,this._opts.model||n)),this.ready=new Promise((t,i)=>{this._model.then(()=>Y(e,this._model,this._opts.warmupSizes||[],void 0,{signal:this._abortController.signal})).then(t).catch(i)})}async execute(n,s){await this.ready;let a=await this._model;return ef(e,n,t(s),{...a,signal:this._abortController.signal},{checkValidEnvironment:i,getImageAsTensor:r,tensorAsBase64:o})}upscale=this.execute.bind(this);warmup=async(t=[],i)=>(await this.ready,Y(e,this._model,t,i,{signal:this._abortController.signal}));abort=()=>{this._abortController.abort(),this._abortController=new AbortController};dispose=async()=>{await this.ready;let{model:t,modelDefinition:i}=await this._model;i.teardown&&await i.teardown(e),t.dispose()};getModel=()=>this._model}return a}({tf:eg,getUpscaleOptions:({output:e,progressOutput:t,...i}={})=>({...i,output:ey(e),progressOutput:ey(t||e)}),loadModel:async(e,t)=>{let i=await t;try{w(i)}catch(e){if(C(e))throw function(e,t){switch(e){case s.INVALID_MODEL_TYPE:return Error(D(t?.modelType));case s.MISSING_PATH:return Error(L(t));default:return Error($)}}(e.type,i);throw Error($)}let r=K(i);return{model:await eE(e,r),modelDefinition:r}},getImageAsTensor:async(e,t)=>{let i=await eC(t,e);if(h(i)){let e=i.expandDims(0);return i.dispose(),e}if(c(i))return i;throw eS(i)},tensorAsBase64:(e,t)=>{let i=ea(e,t),[r,o]=t.shape,n=new ImageData(o,r);n.data.set(i);let s=document.createElement("canvas");s.width=o,s.height=r;let a=s.getContext("2d");if(!a)throw Error("No context found");return a.putImageData(n,0,0),s.toDataURL()},checkValidEnvironment:(e,{output:t="base64",progressOutput:i})=>{"string"==typeof e&&eA(ez),("base64"===i||"base64"===t)&&eA(ex)}});class ej{static Init(e){new ej(e)}InitHTML(){let e=document.createElement("button");e.style.width="100px",e.style.height="20px",e.style.marginLeft="20px",e.style.zIndex="5",e.name="Clear",e.innerText="Clear",e.value="Clear",e.onclick=()=>{console.log(this),this.canvasSD.Clear()},this.host.appendChild(e),this.divText=document.createElement("div"),this.divText.id="classText",this.divText.style.zIndex="5",this.divText.innerText="class: ",this.divText.style.marginLeft="20px",this.host.appendChild(this.divText)}Init(e){}Clear(){this.canvasSD.Clear()}constructor(e="main"){let t="https://raw.githubusercontent.com/NamjuLee/data/master/img/map/worldMapGlobeA_small.png",i=new Image;i.src=t;let r=document.getElementById(e);r&&r.appendChild(i),new eN({}).upscale(t).then(e=>{let t=document.createElement("img");t.src=e,r&&r.appendChild(t)})}}class eD{destroy(){if(this.divHost)try{for(;this.divHost.firstChild;)this.divHost.removeChild(this.divHost.firstChild)}catch(e){console.error("Error in destroy method:",e)}else console.warn("divHost is undefined in destroy method")}constructor(e){this.divHost=document.getElementById(e),ej.Init(e)}}}}]);