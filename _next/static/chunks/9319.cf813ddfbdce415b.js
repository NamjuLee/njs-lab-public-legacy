"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9319,59027],{9319:function(t,e,r){r.r(e),r.d(e,{NLine:function(){return o}});var s=r(59027);class o extends s.GeometryBase{static GetLineFromVecs(t){let e=[];for(let r=0;r<t.length;++r)r===t.length-1?e.push(new o(t[r],t[0])):e.push(new o(t[r],t[r+1]));return e}static GetUnOverlapWithLines(t,e){let r=[],s=[];for(let s=0;s<t.length;++s){r.push(!1);for(let h=0;h<e.length;++h)o.IsOverlap(t[s],e[h])&&(r[s]=!0)}for(let e=0;e<r.length;++e)r[e]||s.push(t[e]);return s}static IsOverlap(t,e){return!!(t.p0.IsOverlap(e.p0)&&t.p1.IsOverlap(e.p1))||!!(t.p0.IsOverlap(e.p1)&&t.p1.IsOverlap(e.p0))}static RemoveOverlapWithLines(t){let e=[],r=[];for(let r=0;r<t.length;++r){e.push(0);for(let s=r+1;s<t.length;++s)o.IsOverlap(t[r],t[s])&&e[r]++}for(let s=0;s<e.length;++s)0===e[s]&&r.push(t[s]);return r}Render(t){t.lineWidth=.5,t.strokeStyle="red",t.beginPath(),t.moveTo(this.p0.x,this.p0.y),t.lineTo(this.p1.x,this.p1.y),t.closePath(),t.stroke()}DistanceToPoint(t){let e=(this.p1.y-this.p0.y)/(this.p1.x-this.p0.x),r=this.p0.y-e*this.p0.x,s=[];return s.push(Math.abs(t.y-e*t.x-r)/Math.sqrt(Math.pow(e,2)+1)),s.push(Math.sqrt(Math.pow(t.x-this.p0.x,2)+Math.pow(t.y-this.p0.y,2))),s.push(Math.sqrt(Math.pow(t.x-this.p1.x,2)+Math.pow(t.y-this.p1.y,2))),s.sort((t,e)=>t-e)[0]}GetLog(){throw Error("Method not implemented.")}RenderPost(t){throw Error("Method not implemented.")}IsMouseInside(t,e){throw Error("Method not implemented.")}Translate(t,e){throw Error("Method not implemented.")}Move(t,e){throw Error("Method not implemented.")}Remove(){throw Error("Method not implemented.")}Hide(){throw Error("Method not implemented.")}constructor(t,e){super(),this.p0=t,this.p1=e}}},59027:function(t,e,r){r.r(e),r.d(e,{GeometryBase:function(){return o}});var s=r(98594);class o{constructor(){this.vec=new s.NVector3(0,0,0)}}}}]);