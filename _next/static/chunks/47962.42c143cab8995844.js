(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[47962],{15510:function(t){function e(t){return Promise.resolve().then(function(){var e=Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e})}e.keys=function(){return[]},e.resolve=e,e.id=15510,t.exports=e},11768:function(t,e,i){"use strict";i.r(e),i.d(e,{Solution:function(){return C}});var s=i(81519),r=i(49644),a=i(50023);class o{zoom(t){}update(){s.zB(this.viewMatrix,this.eye,this.center,this.up),s.Jp(this.viewProjectionMatrix,this.projectionMatrix,this.viewMatrix)}constructor(t=100,e=100,i=[2,2,4],a=[0,0,0],o=[0,1,0],n=5){this.viewMatrix=s.Ue(),this.projectionMatrix=s.Ue(),this.viewProjectionMatrix=s.Ue(),this.zoomMax=100,this.zoomSpeed=2,this.near=.01,this.far=1e4,this.mvpMatrix=s.Ue(),this.eye=r.al(0,0,0),this.center=r.al(0,0,0),this.up=r.al(0,1,0),this.type="camera",this.angleXY=Math.PI,this.angleZ=.25*Math.PI,this.distance=1,this.distance=n,this.width=t,this.height=e,this.respectRatio=t/e,this.eye=i,this.center=a,this.up=o}}class n extends o{init(){s.G3(this.projectionMatrix,2*Math.PI/5,this.respectRatio,this.near,this.far),this.update()}zoom(t){this.distance+=.01*t}constructor(t=100,e=100,i=[2,2,4],s=[0,0,0],r=[0,1,0],a=3){super(t,e,i,s,r,a),this.type="CameraPerspective",this.init()}}class h extends o{init(){c(this.projectionMatrix,this.width,this.height,this.near,this.far,this.distance),this.angleXY=0,this.angleZ=0,this.update()}zoom(t){this.width+=.001*this.width*t,this.height+=.001*this.height*t,this.distance<1e-6&&(this.distance=1e-6),this.distance>1e5&&(this.distance=1e5),c(this.projectionMatrix,this.width,this.height,this.near,this.far,this.distance)}constructor(t=100,e=100,i=[0,0,1],s=[0,0,0],r=[0,1,0],a=300.1){super(t,e,i,s,r,a),this.type="CameraOrth",this.init()}}let c=(t,e,i,s,r,a)=>(t[0]=2/e*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2/i*a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=-2/(r-s),t[11]=0,t[12]=0,t[13]=0,t[14]=.1,t[15]=1,t);class l{update(){this.camera.update(),d(this.modelMatrix,this.translation,this.rotation),s.Jp(this.mvpMatrix,this.camera.viewProjectionMatrix,this.modelMatrix)}rotateZ(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:.1;this.rotation[2]+=t,this.update()}translateX(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:.1;this.translation[0]+=t,this.update()}get getMatrix(){return this.mvpMatrix}shiftCamera(){this.camera===this.cameraPerspective?this.camera=this.cameraOrth:this.camera=this.cameraPerspective,this.update()}moveCamera(t,e){this.camera===this.cameraPerspective?this.arcRotation(t,e):this.pan(t,e)}arcRotation(t,e){t*=-.01,e*=-.01,this.isShift?this.panPerspective(t,e):(this.camera.angleXY+=t,this.camera.angleZ+=e,this.camera.eye[0]=this.camera.center[0]+Math.sin(this.camera.angleXY)*Math.cos(this.camera.angleZ)*this.camera.distance,this.camera.eye[1]=this.camera.center[1]+Math.cos(this.camera.angleXY)*Math.cos(this.camera.angleZ)*this.camera.distance,this.camera.eye[2]=this.camera.center[2]+Math.sin(this.camera.angleZ)*this.camera.distance),this.update()}zoomWheel(t){this.camera===this.cameraPerspective?(this.camera.zoom(t),this.arcRotation(0,0)):this.camera.zoom(t),this.update()}panPerspective(t,e){this.camera.center[0]+=t/this.camera.distance,this.camera.center[2]+=e/this.camera.distance,this.camera.eye[0]+=t/this.camera.distance,this.camera.eye[2]+=e/this.camera.distance,this.update()}pan(t,e){this.camera.center[0]+=t/this.camera.distance,this.camera.center[1]-=e/this.camera.distance,this.camera.eye[0]+=t/this.camera.distance,this.camera.eye[1]-=e/this.camera.distance,this.update()}appendEvent(t){t.addEventListener("drag",t=>{},!1),t.addEventListener("click",t=>{},!1),t.addEventListener("dblclick",t=>{},!1),t.addEventListener("drag",t=>{},!0),t.addEventListener("mouseup",t=>{},!1),t.addEventListener("mousedown",t=>{this.isDown=!0,this.pos[0]=t.offsetX,this.pos[1]=t.offsetY},!1),t.addEventListener("mouseup",t=>{this.isDown=!1},!1),t.addEventListener("mousemove",e=>{if(this.isDown){let t=this.pos[0]-e.offsetX,i=this.pos[1]-e.offsetY;this.moveCamera(t,i),this.pos[0]=e.offsetX,this.pos[1]=e.offsetY}else t.getBoundingClientRect();this.pos[0]=e.offsetX,this.pos[1]=e.offsetY},!1),t.addEventListener("wheel",t=>{this.zoomWheel(t.deltaY)},!1),window.addEventListener("keydown",t=>{"p"===t.key&&this.shiftCamera(),t.shiftKey&&(this.isShift=!0)},!1),window.addEventListener("keyup",t=>{this.isShift=!1},!1)}constructor(t){this.modelMatrix=s.Ue(),this.mvpMatrix=s.Ue(),this.rotation=r.al(0,0,0),this.translation=r.al(0,0,0),this.screen2=a.al(0,0),this.pos=[0,0],this.isDown=!1,this.isShift=!1,this.renderer=t,this.canvas=t.canvas;let e=r.al(2.6451475620269775,3.130298137664795,2.864337205886841),i=r.al(0,0,0),o=r.al(0,0,1);this.cameraPerspective=new n(this.canvas.width,this.canvas.height,e,i,o),this.camera=this.cameraPerspective,this.arcRotation(0,0),this.cameraOrth=new h(this.canvas.width,this.canvas.height),this.camera=this.cameraOrth,this.appendEvent(this.canvas),this.update()}}let d=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0,0,0],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=s.Ue(),o=s.Ue(),n=s.Ue(),h=s.Ue(),c=s.Ue();s.vc(h,e),s.aC(a,i[0]),s.gT(o,i[1]),s.QO(n,i[2]),s.xJ(c,r),s.Jp(t,a,c),s.Jp(t,o,t),s.Jp(t,n,t),s.Jp(t,h,t)};class m{init(){this.gl=this.canvas.getContext("webgl2"),this.cameraController=new l(this)}draw(){this.isActive&&(requestAnimationFrame(()=>this.draw()),this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height),this.gl.enable(this.gl.CULL_FACE),this.gl.enable(this.gl.DEPTH_TEST),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.cameraController.update(),this.core.scene.render())}destroy(){this.isActive=!1,this.divHost.removeChild(this.canvas)}constructor(t){this.isActive=!0,this.core=t,this.divHost=document.getElementById(this.core.id),this.canvas=document.createElement("canvas"),this.divHost.appendChild(this.canvas),this.canvas.width=this.divHost.clientWidth,this.canvas.height=this.divHost.clientHeight,this.init()}}let g=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0,0,0],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=s.Ue(),o=s.Ue(),n=s.Ue(),h=s.Ue(),c=s.Ue();s.vc(h,e),s.aC(a,i[0]),s.gT(o,i[1]),s.QO(n,i[2]),s.xJ(c,r),s.Jp(t,a,c),s.Jp(t,o,t),s.Jp(t,n,t),s.Jp(t,h,t)};var f=i(45169);class v{async init(){await (0,f.getJSONFromURL)("https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson").then(t=>{for(let e=0;e<t.features.length;++e)this.streetOSM.push(t.features[e].geometry.coordinates);this.renderLines(this.streetOSM,[0,0,0])})}constructor(){this.streetOSM=[],this.renderLines=(t,e)=>{let i=[],s=[],r=[];for(let a=0;a<t.length;++a){let o=t[a];for(let t=0;t<o.length;++t)for(let a=0;a<o[t].length-1;++a){let[n,h]=(0,f.MercatorProjection)(o[t][a][0],o[t][a][1]),[c,l]=(0,f.MercatorProjection)(o[t][a+1][0],o[t][a+1][1]),d=(n-15478749.591872748)*.001,m=(h-4766690.415614613)*.001,g=(c-15478749.591872748)*.001,v=(l-4766690.415614613)*.001;i.push(d,m,0),s.push(e[0],e[1],e[2]),i.push(g,v,0),s.push(e[0],e[1],e[2]),a<o[t].length-1&&r.push(Math.floor(i.length/3)-1,Math.floor(i.length/3))}}this.pos=new Float32Array(i.flat()),this.colors=new Float32Array(s.flat())}}}class u{async init(){}render(){}constructor(t){this.modelMatrix=s.Ue(),this.translation=r.al(2,0,0),this.rotation=r.al(0,0,0),this.scale=r.al(1,1,1),this.isRenderable=!1,this.scene=t,this.gl=t.core.renderer.gl,this.scene.add(this)}}class p extends u{async init(){this.geometry=new v,await this.geometry.init(),console.log(this.geometry);let t=this.gl;this.vertexBuffer=t.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.geometry.pos,t.STATIC_DRAW),this.colorBuffer=t.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.colorBuffer),t.bufferData(t.ARRAY_BUFFER,this.geometry.colors,t.STATIC_DRAW),this.program=t.createProgram();let e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,'export default "#version 300 es\\n#define GLSLIFY 1\\n#pragma vscode_glsllint_stage: vert\\n\\nuniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nuniform mat4 cameraProjection;\\n\\nuniform float uFrame;\\nuniform vec2 uMouse;\\n\\nlayout(location=0) in vec4 aPosition;\\nlayout(location=1) in vec4 aColor;\\n\\nout vec4 vColor;\\n\\nfloat euclideanDistance(vec2 p1, vec2 p2) {\\n\\tfloat d1 = (p1.x - p2.x);\\n\\tfloat d2 = (p1.y - p2.y);\\n\\treturn sqrt(pow(d1, 2.0) + pow(d2, 2.0));\\n}\\n\\nvoid main(){\\n    highp vec4 pos = vec4(aPosition);\\n\\n    vec2 v0 = vec2(uMouse.x, -uMouse.y);\\n    vec2 v1 = vec2(pos.xy);\\n\\n    float dis = euclideanDistance(v0,v1);\\n\\n    vColor = vec4(0, dis, 0.0 , sin(uFrame * 0.3) + 1.25);\\n    // vColor = vec4(aPosition.xyz, 0.);\\n    gl_PointSize = 10.;\\n    gl_Position = cameraProjection * uModel * pos;\\n}\\n\\n";'),t.compileShader(e),t.attachShader(this.program,e);let i=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(i,'export default "#version 300 es\\n#pragma vscode_glsllint_stage: frag\\n\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nin vec4 vColor;\\n\\nout vec4 fragColor;\\n\\nvoid main()\\n{\\n    fragColor = vec4(vColor.xyzw);\\n\\n    // float r = 0.0, delta = 0.0, alpha = 1.0;\\n    // vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\n    // r = dot(cxy, cxy);\\n    // if (r > 1.0) {\\n    //     discard;\\n    // }\\n    // gl_FragColor = color * (alpha);\\n}\\n\\n";'),t.compileShader(i),t.attachShader(this.program,i),t.linkProgram(this.program),this.modelLoc=t.getUniformLocation(this.program,"uModel"),this.cameraLoc=t.getUniformLocation(this.program,"cameraProjection"),this.frameLoc=t.getUniformLocation(this.program,"uFrame"),this.mouseLoc=t.getUniformLocation(this.program,"uMouse"),this.isRenderable=!0}render(){this.isRenderable&&(g(this.modelMatrix,this.translation,this.rotation,this.scale),this.gl.useProgram(this.program),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.enableVertexAttribArray(0),this.gl.vertexAttribPointer(0,3,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.colorBuffer),this.gl.enableVertexAttribArray(1),this.gl.vertexAttribPointer(1,3,this.gl.FLOAT,!1,0,0),this.gl.uniformMatrix4fv(this.modelLoc,!1,this.modelMatrix),this.gl.uniformMatrix4fv(this.cameraLoc,!1,this.scene.core.renderer.cameraController.getMatrix),this.gl.uniform1f(this.frameLoc,this.t),this.gl.uniform2f(this.mouseLoc,.01*this.scene.core.renderer.cameraController.pos[0],.01*this.scene.core.renderer.cameraController.pos[1]),this.gl.drawArrays(this.gl.LINES,0,this.geometry.pos.length/3),this.t+=.1)}constructor(t){super(t),this.numberOfVertices=0,this.isAnimation=!1,this.t=0,this.init()}}class x{async init(){await (0,f.getJSONFromURL)("https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson").then(t=>{for(let e=0;e<t.features.length;++e)this.streetOSM.push(t.features[e].geometry.coordinates);this.renderLines(this.streetOSM,[0,0,0])})}constructor(){this.streetOSM=[],this.renderLines=(t,e)=>{let i=[],s=[];for(let r=0;r<t.length;++r){let a=t[r];for(let t=0;t<a.length;++t)for(let r=0;r<a[t].length-1;++r){let[o,n]=(0,f.MercatorProjection)(a[t][r][0],a[t][r][1]),h=(o-15478749.591872748)*.001,c=(n-4766690.415614613)*.001;i.push(h,c,0),s.push(e[0],e[1],e[2])}}this.pos=new Float32Array(i.flat()),this.colors=new Float32Array(s.flat())}}}class y extends u{async init(){this.geometry=new x,await this.geometry.init(),console.log(this.geometry);let t=this.gl;this.vertexBuffer=t.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),t.bufferData(t.ARRAY_BUFFER,this.geometry.pos,t.STATIC_DRAW),this.colorBuffer=t.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.colorBuffer),t.bufferData(t.ARRAY_BUFFER,this.geometry.colors,t.STATIC_DRAW),this.program=t.createProgram();let e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,'export default "#version 300 es\\n#define GLSLIFY 1\\n#pragma vscode_glsllint_stage: vert\\n\\nuniform mat4 uModel;\\nuniform mat4 uView;\\nuniform mat4 uProjection;\\nuniform mat4 cameraProjection;\\n\\nuniform float uFrame;\\nuniform vec2 uMouse;\\n\\nlayout(location=0) in vec4 aPosition;\\nlayout(location=1) in vec4 aColor;\\n\\nout vec4 vColor;\\nout vec4 vPos;\\n\\nvoid main(){\\n    highp vec4 pos = vec4(aPosition);\\n    pos[2]+=0.1;\\n\\n    vPos = vec4(pos.xyz, 1.);\\n    // vColor = vec4(0, dis, 0.0 , sin(uFrame * 0.3) + 1.25);\\n    // vColor = vec4(gl_PointCoord.x, gl_PointCoord.y, 0.0,  0.);\\n    // vColor = vec4(gl_FragCoord.x, gl_FragCoord.y, 0.0,  1.);\\n    vColor = vec4(1.0, .0, .0, 1.0);\\n    \\n    gl_PointSize = 5.;\\n\\n    gl_Position = cameraProjection * uModel * pos;\\n\\n}\\n\\n";'),t.compileShader(e),t.attachShader(this.program,e);let i=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(i,'export default "#version 300 es\\n#pragma vscode_glsllint_stage: frag\\n\\n#ifdef GL_OES_standard_derivatives\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nin vec4 vColor;\\nin vec4 vPos;\\n\\nout vec4 fragColor;\\n\\nfloat circle(in vec2 st, in float radius) {\\n    vec2 dist = st - vec2(0.5);\\n    return 1.0 - smoothstep(\\n       radius - (radius * 0.01),\\n       radius +(radius * 0.01),\\n       dot(dist, dist) * 4.0);\\n}\\n\\nfloat aastep(float threshold, float value) {\\n\\tfloat afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\\n\\treturn smoothstep(threshold-afwidth, threshold+afwidth, value);\\n}\\n\\nvoid main()\\n{\\n    // vec4 col;\\n    // vec2 p =  vec2(gl_PointCoord.xy);\\n\\n    // if ( length(p -vec2(0.5,0.5)) < 1.){\\n    //     col = vec4(p.x, p.y ,0. ,1.) ;\\n    // }else{\\n    //     // discard;\\n    //     // col = vec4(0.,0.,0., 0.) ;\\n    // }\\n\\n    // if ( length(vPos.xy-vec2(0.5,0.5)) < 0.2){\\n    //     fragColor = vec4(1,0.,0.,1.) ;\\n    // }else{\\n    //     fragColor = vec4(0.,0.,0.,1.) ;\\n    // }\\n    // return ;\\n\\n    // float r = 0.0, delta = 0.0, alpha = 1.0;\\n    // vec2 cxy = 2.0 * vPos - 1.0;\\n    // r = dot(cxy, cxy);\\n\\n    // if (r > 1.0) {\\n    //     discard;\\n    // }\\n    // gl_FragColor = vColor * (alpha);\\n    // fragColor = gl_FragColor;\\n\\n    // fragColor = vec4(vPos.xyz, 1);\\n    // fragColor = vec4(1., 0., 0., 1.);\\n\\n    // float r = 0.0, delta = 0.0, alpha = 1.0;\\n    // vec2 cxy = 2.0 * p - 1.0;\\n    // r = dot(cxy, cxy);\\n\\n    // if (r > 1.0) {\\n    //     discard;\\n    // }\\n\\n    // // // #ifdef GL_OES_standard_derivatives\\n    // delta = fwidth(r);\\n    // alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\n\\n    // fragColor = col * alpha;\\n\\n    // https://stackoverflow.com/questions/70537724/drawing-a-circle-using-smoothstep-with-dot-or-length-produces-different-re\\n    // https://codepen.io/mikrosystheme/pen/VwdJamY?editors=0010\\n    vec4 v_fill_color =   vec4(1. , 1. , 1. , 1.);\\n    vec4 v_stroke_color = vec4(1., 0.,0. , 1.);\\n    float v_stroke_width = 0.2;\\n\\n\\t//vec2 uv = gl_FragCoord.xy; // 0..pointsize\\n\\tvec2 uv = gl_PointCoord.xy; // 0..1;\\n\\tuv = uv * 2.0 - 1.0; // -1.0 .. +1.0\\n\\tfloat d = length(uv);\\n\\tfloat aa = aastep( 1.0, d );\\n\\tfloat aa2 = aastep( 1.0 - v_stroke_width, d );\\n\\tfragColor = vec4(uv, 0.0, aa) + v_fill_color; //vec4(1.0, 0.0, 0.0, 1.0);\\n\\n    vec4 theColor = mix(v_stroke_color, vec4(0.0), aa);\\n\\n    if (theColor.w < 0.2) {\\n        discard;\\n    }\\n\\n\\tfragColor = theColor; //vec4(vec3(aa),1.0);\\n\\tfragColor = mix(v_fill_color, fragColor, aa2);\\n\\t// Meh... c\'\xe8 da lavorarci, soprattutto per via di mix che stiamo facendo \\n\\t// tra screenspace e clipspace.\\n\\n    \\n\\n}\\n\\n";'),t.compileShader(i),t.attachShader(this.program,i),t.linkProgram(this.program),this.modelLoc=t.getUniformLocation(this.program,"uModel"),this.cameraLoc=t.getUniformLocation(this.program,"cameraProjection"),this.frameLoc=t.getUniformLocation(this.program,"uFrame"),this.mouseLoc=t.getUniformLocation(this.program,"uMouse"),this.isRenderable=!0}render(){this.isRenderable&&(g(this.modelMatrix,this.translation,this.rotation,this.scale),this.gl.useProgram(this.program),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.enableVertexAttribArray(0),this.gl.vertexAttribPointer(0,3,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.colorBuffer),this.gl.enableVertexAttribArray(1),this.gl.vertexAttribPointer(1,3,this.gl.FLOAT,!1,0,0),this.gl.uniformMatrix4fv(this.modelLoc,!1,this.modelMatrix),this.gl.uniformMatrix4fv(this.cameraLoc,!1,this.scene.core.renderer.cameraController.getMatrix),this.gl.uniform1f(this.frameLoc,this.t),this.gl.uniform2f(this.mouseLoc,.01*this.scene.core.renderer.cameraController.pos[0],.01*this.scene.core.renderer.cameraController.pos[1]),this.gl.drawArrays(this.gl.POINTS,0,this.geometry.pos.length/3),this.t+=.1)}constructor(t){super(t),this.numberOfVertices=0,this.isAnimation=!1,this.t=0,this.init()}}class _{async init(){new p(this),new y(this)}render(){for(let t=0;t<this.objectList.length;++t)this.objectList[t].render()}add(t){this.objectList.push(t)}constructor(t){this.objectList=[],this.core=t}}class w{async init(){this.renderer=new m(this),this.scene=new _(this),this.scene.init(),this.renderer.draw()}destroy(){this.renderer.destroy()}constructor(t){this.id=t,this.init()}}class C{destroy(){this.core.destroy()}constructor(t){this.core=new w(t)}}}}]);