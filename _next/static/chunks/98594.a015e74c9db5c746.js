"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[98594],{98594:function(t,e,n){n.r(e),n.d(e,{NVector3:function(){return r}});class r{static GetVecforGraphicApp(t,e,n,s,i,h){let l=new r(0,0,0);return l.long=t,l.lat=e,l.ele=n,l.proX=s,l.proY=i,l.proZ=h,l}static DeepCopy(t){let e=new r(t.x,t.y,t.z);return e.long=t.long,e.lat=t.lat,e.proX=t.proX,e.proY=t.proY,e.proZ=t.proZ,e}static Dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static GetAreayConvexGPS(t){let e,n,r,s=[],i=[];for(let e=0;e<t.length;++e)s.push(t[e].lat),i.push(t[e].long);s.push(t[0].lat),i.push(t[0].long);let h=0,l=0;for(let t=s.length;t--;)h+=s[t],l+=i[t];let a=h/s.length,o=l/i.length,y=Array(s.length);for(let t=s.length;t--;)s[t]-=a,i[t]-=o,i[t]>=0&&s[t]>=0?y[t]=Math.abs(180*Math.atan(s[t]/i[t])/Math.PI):i[t]<0&&s[t]>=0?y[t]=90+Math.abs(180*Math.atan(s[t]/i[t])/Math.PI):i[t]<0&&s[t]<0?y[t]=180+Math.abs(180*Math.atan(s[t]/i[t])/Math.PI):i[t]>=0&&s[t]<0&&(y[t]=270+Math.abs(180*Math.atan(s[t]/i[t])/Math.PI));for(let t=0;t<y.length;t++)for(let t=0;t<y.length-1;t++)e=y[t],n=s[t],r=i[t],e<y[t+1]&&(y[t]=y[t+1],s[t]=s[t+1],i[t]=i[t+1],y[t+1]=e,s[t+1]=n,i[t+1]=r);let x=0,u=0;for(let t=0;t<s.length;t++)t!==s.length-1?(x+=s[t]*i[t+1],u+=i[t]*s[t+1]):(x+=s[t]*i[0],u+=i[t]*s[0]);return(x-u)/2*20}static ScalarRev_V_S_OUT(t,e,n){return n.x=e*t.x,n.y=e*t.y,n.z=e*t.z,n}static Add(t,e){return new r(t.x+e.x,t.y+e.y,t.z+e.z)}static Sub(t,e){return new r(t.x-e.x,t.y-e.y,t.z-e.z)}static Clone(t){return r.DeepCopy(t)}static ZAxis(){return new r(0,0,1)}static YAxis(){return new r(0,1,0)}static Zero(){return new r(0,0,0)}static Origin(){return new r(0,0,0)}static Plus(t,e){return new r(t.x+e.x,t.y+e.y,t.z+e.z)}static Scale(t,e){return new r(t.x*e,t.y*e,t.z*e)}static MidVec(t,e){return new r((t.x+e.x)*.5,(t.y+e.y)*.5,(t.z+e.z)*.5)}static CompareTwoVectors(t,e){return t.x===e.x&&t.y===e.y&&t.z===e.z}static Length(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z)}static Normalize(t){let e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);return new r(t.x/e,t.y/e,t.z/e)}static GetArea(t){let e=0;for(let n=0,r=t.length;n<r;n++){let r=t[n].x,s=t[n===t.length-1?0:n+1].y,i=t[n===t.length-1?0:n+1].x,h=t[n].y;e+=r*s*.5,e-=i*h*.5}return Math.abs(e)}static GetAreaByLongLat(t){let e=0;for(let n=0;n<t.length-1;n++)e+=(t[n].long-t[n+1].long)*(t[n].lat+t[n+1].lat);return .5*e}static GetGeoArea(t){let e=0;for(let n=0;n<t.length-1;n++)e+=(t[n].x-t[n+1].x)*(t[n].y+t[n+1].y);return Math.abs(e*=.5)}static GetGeoAreaBbyLongLat(t){let e=0;for(let n=0;n<t.length-1;n++)e+=(t[n].long-t[n+1].long)*(t[n].lat+t[n+1].lat);return Math.abs(e*=.5)}static Distance(t,e){return Math.sqrt((t.x-e.x)*(t.x-e.x)+(t.y-e.y)*(t.y-e.y)+(t.z-e.z)*(t.z-e.z))}static Distance2(t,e){return(t.x-e.x)*(t.x-e.x)+(t.y-e.y)*(t.y-e.y)+(t.z-e.z)*(t.z-e.z)}static DotProduct(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static CrossProduct(t,e){return new r(t.y*e.z-t.z*e.y,t.z*e.x-t.x*e.z,t.x*e.y-t.y*e.x)}static DivideByNum(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5,s=[],i=(e.x-t.x)/n,h=(e.y-t.y)/n,l=(e.z-t.z)/n;for(let e=0;e<n;++e){let n=t.x+i*e,a=t.y+h*e,o=t.z+l*e;s.push(new r(n,a,o))}return s}static KMeterFromGeoGPSPos(t,e){let n=e.lat*Math.PI/180-t.lat*Math.PI/180,r=e.long*Math.PI/180-t.long*Math.PI/180,s=Math.sin(n/2)*Math.sin(n/2)+Math.cos(t.lat*Math.PI/180)*Math.cos(e.lat*Math.PI/180)*Math.sin(r/2)*Math.sin(r/2);return 2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s))*6378.137}static KMeterByTwoGeoPos(t,e,n,s){let i=new r(0,0);i.long=t,i.lat=e;let h=new r(0,0);return h.long=n,h.lat=s,r.KMeterFromGeoGPSPos(i,h)}static KMeterFromGPSPos(t,e){let n=e.y*Math.PI/180-t.y*Math.PI/180,r=e.x*Math.PI/180-t.x*Math.PI/180,s=Math.sin(n/2)*Math.sin(n/2)+Math.cos(t.y*Math.PI/180)*Math.cos(e.y*Math.PI/180)*Math.sin(r/2)*Math.sin(r/2);return 2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s))*6378.137}static Get1KM_Long_ByGeoUnit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=new r(t,e,0),s=0;for(let t=0;t<1e4;++t){let t=r.KMeterFromGPSPos(n,new r(n.x+s,n.y,n.z));if(1<t&&t<1.001)return n.x+s;s+=1e-5}return -1}static Get1KM_lat_ByGeoUnit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=new r(t,e,0),s=0;for(let t=0;t<1e4;++t){let t=r.KMeterFromGPSPos(n,new r(n.x,n.y+s,n.z));if(1<t&&t<1.001)return n.y+s;s+=1e-5}return -1}static Get1KM_Lat_Long_GeoUnit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=r.Get1KM_Long_ByGeoUnit(t,e),s=r.Get1KM_lat_ByGeoUnit(t,e);return new r(n,s,0)}static CalculateFalloff(t,e,n,r){let s=e.Sub(t).Length();return n*Math.exp(-r*s*s)*s}static Attractor(t,e,n,r){let s=e.Sub(t);s.Unitize();let i=s.Length();return s.Mult(n*Math.exp(-r*i*i))}static Explosion(t,e,n,r){let s=e.Sub(t);s.Unitize();let i=s.Length();return s.Mult(-(n*Math.exp(-r*i*i)))}static Rotor(t,e,n,s){return e.Sub(t).Unitize(),r.Origin()}static GetAngleBetween(t,e){return Math.atan2(e.x-t.x,e.y-t.y)}static GetCosAngleByTwoVectors(t,e){return r.DotProduct(r.Normalize(t),r.Normalize(e))}static GetAngleByTwoVectorsRadian(t,e){return Math.acos(r.GetCosAngleByTwoVectors(t,e))}static GetAngleByTwoVectors(t,e){return 180*r.GetAngleByTwoVectorsRadian(t,e)/Math.PI}static GetRotationByWorldCoodinate(t){let e=new r(1,0,0);return r.GetAngleByTwoVectors(e,t)}static GetRotationByWorldCoodinateByTwo(t,e){let n=e.Sub(t),s=new r(1,0,0);return n.y>0?-1*r.GetAngleByTwoVectors(s,n):r.GetAngleByTwoVectors(s,n)}static ComputeDotProducts(t){let e=[];for(let n=0;n<t.length;++n)if(n<t.length-1){let s=new r(t[n].x,t[n].y,t[n].z),i=new r(t[n+1].x,t[n+1].y,t[n+1].z);i.x-=s.x,i.y-=s.y,i.z-=s.z;let h=r.DotProduct(new r(1,0,0),r.Normalize(i));Number.isNaN(h)?e.push(e[e.length-1]):e.push(h)}else{let s=new r(t[n].x,t[n].y,t[n].z),i=new r(t[0].x,t[0].y,t[0].z);i.x-=s.x,i.y-=s.y,i.z-=s.z;let h=r.DotProduct(new r(1,0,0),r.Normalize(i));Number.isNaN(h)?e.push(e[e.length-1]):e.push(h)}return e}static ComputeDotProductsWithCenter(t){let e=r.GetCenterVecFromVecs(t),n=[];for(let s=0;s<t.length;++s){let i,h;s<t.length-1?(i=new r(t[s].x-e.x,t[s].y-e.y,t[s].z-e.z),h=new r(t[s+1].x-e.x,t[s+1].y-e.y,t[s+1].z-e.z)):(i=new r(t[s].x-e.x,t[s].y-e.y,t[s].z-e.z),h=new r(t[0].x-e.x,t[0].y-e.y,t[0].z-e.z));let l=r.DotProduct(r.Normalize(i),r.Normalize(h));n.push(l)}return n}static GetXYDimForCircle(t){let e=r.GetCenterVecFromVecs(t),n=0,s=0,i=t.length;for(let r=0;r<i;++r)n+=Math.abs(t[r].x-e.x),s+=Math.abs(t[r].y-e.y);return[n/(i+=2),s/i]}static DistanceMouseWithTwoVecs(t,e,n){e.x+=1e-5,e.y+=1e-5;let s=r.GetBoundingVecs(e,n),i=r.GetCloseVec(e,n,t.x,t.y,s,!0);return r.Distance(t,i)}static GetCloseVec(t,e,n,s,i){let h=!(arguments.length>5)||void 0===arguments[5]||arguments[5],l=new r(t.x,t.y,t.z),a=new r(e.x,e.y,e.z).Sub(l),o=new r(n,s,0).Sub(l);a.Unitize();let y=l.Add(a.Mult(o.DotProduct(a)));return h?r.IsInsideOfVecs(y,i)?y:t.Distance(y)<e.Distance(y)?new r(t.x,t.y,t.z):new r(e.x,e.y,e.z):y}static GetBoundingVecs(t,e){let n=[],s=0,i=0,h=new r(s=t.x<e.x?t.x:e.x,t.y<e.y?t.y:e.y,t.z<e.z?t.z:e.z),l=new r(s=t.x>e.x?t.x:e.x,t.y>e.y?t.y:e.y,t.z>e.z?t.z:e.z);return n.push(new r(h.x,h.y,h.z)),n.push(new r(l.x,h.y,h.z)),n.push(new r(l.x,l.y,h.z)),n.push(new r(h.x,l.y,h.z)),n}static GetBoundaryByVecWidthHeight(t,e,n){let s=[];return s.push(new r(t.x,t.y,t.z)),s.push(new r(t.x+e,t.y,t.z)),s.push(new r(t.x+e,t.y+n,t.z)),s.push(new r(t.x,t.y+n,t.z)),s}static GetMinMaxVecFromVecs(t){let e=Number.MAX_VALUE,n=Number.MAX_VALUE,s=Number.MAX_VALUE,i=Number.MIN_VALUE,h=Number.MIN_VALUE,l=Number.MIN_VALUE;for(let r of t)e>r.x&&(e=r.x),n>r.y&&(n=r.y),s>r.z&&(s=r.z),i<r.x&&(i=r.x),h<r.y&&(h=r.y),l<r.z&&(l=r.z);return[new r(e,n,s),new r(i,h,l)]}static RemoveVecsWithinDis(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,n=[];for(let n=0;n<t.length-1;++n){let s=t[n];if(!1!==s.d)for(let i=n+1;i<t.length;++i)r.Distance(s,t[i])<e&&(t[i].d=!1)}for(let e=0;e<t.length;++e)!0===t[e].d&&n.push(t[e]);return n}static IsInsideOfVecsWtihVecs(t,e){for(let n=0;n<t.length;n++)if(!r.IsInsideOfVecs(t[n],e))return!1;return!0}static IsInsideOfVecs(t,e){let n=t.x,r=t.y,s=!1;for(let t=0,i=e.length-1;t<e.length;i=t++){let h=e[t].x,l=e[t].y,a=e[i].x,o=e[i].y;l>r!=o>r&&n<(a-h)*(r-l)/(o-l)+h&&(s=!s)}return s}static IsInsideOfVecsByCrossing(t,e,n,s){return!!(this.IsInsideOfVecs(new r(t.x-.5*e,t.y-.5*n),s)||this.IsInsideOfVecs(new r(t.x+.5*e,t.y-.5*n),s)||this.IsInsideOfVecs(new r(t.x+.5*e,t.y+.5*n),s)||this.IsInsideOfVecs(new r(t.x-.5*e,t.y+.5*n),s))}static IsInsideOfVecsByConcaveHull(t,e){}static IsInsideOfVecsByConvexHull(t,e){return e=r.ConvexHull(e),!!r.IsInsideOfVecs(t,e)}static ConvexHull(t){t.sort(function(t,e){return t.x===e.x?t.y-e.y:t.x-e.x});let e=[];for(let n=0;n<t.length;n++){for(;e.length>=2&&0>=r.Cross(e[e.length-2],e[e.length-1],t[n]);)e.pop();e.push(t[n])}let n=[];for(let e=t.length-1;e>=0;e--){for(;n.length>=2&&0>=r.Cross(n[n.length-2],n[n.length-1],t[e]);)n.pop();n.push(t[e])}n.pop(),e.pop();for(let t=0;t<n.length;++t)e.push(n[t]);return e}static Cross(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static Cross_A_B_OUT(t,e,n){let r=t.x,s=t.y,i=t.z,h=e.x,l=e.y,a=e.z;return n.x=s*a-i*l,n.y=i*h-r*a,n.z=r*l-s*h,n}static CheckLineIntersection(t,e,n,s){let i=0,h=0,l=0,a=0,o=0,y=!1,x=!1;i=(s.y-n.y)*(e.x-t.x)-(s.x-n.x)*(e.y-t.y);let u=new r(0,0,0);return 0===i?void 0:(h=t.y-n.y,l=t.x-n.x,a=(s.x-n.x)*h-(s.y-n.y)*l,o=(e.x-t.x)*h-(e.y-t.y)*l,h=a/i,l=o/i,u.x=t.x+h*(e.x-t.x),u.y=t.y+h*(e.y-t.y),h>0&&h<1&&(y=!0),l>0&&l<1&&(x=!0),y&&x)?u:void 0}static CheckConvexity(t){let e,n,s;if(t.length<3)return!1;let i=0;for(let h=0;h<t.length;h++){e=t[h];let l=t[(h+1)%t.length];if(n=new r(l.x-e.x,l.y-e.y,0),s=t[(h+2)%t.length],0===h)i=s.x*n.y-s.y*n.x+n.x*e.y-n.y*e.x;else{let t=s.x*n.y-s.y*n.x+n.x*e.y-n.y*e.x;if(t>0&&i<0||t<0&&i>0)return!1}}return!0}static MoveVecs(t,e){let n=[];for(let s=0;s<t.length;++s)n.push(r.MoveVec(t[s],e));return n}static MoveVec(t,e){return new r(t.x+e.x,t.y+e.y,t.z+e.z)}static RotateVecsLoal(t,e){let n=r.GetCenterVecFromVecs(t),s=new r(-n.x,-n.y,-n.z),i=r.MoveVecs(t,s);return i=r.RotateVecs(i,e),i=r.MoveVecs(i,n)}static RotateVecs(t,e){let n=[];for(let s=0;s<t.length;++s)n.push(r.RotateVec(t[s],e));return n}static RotateVec(t,e){let n=Math.cos(.017453292519943278*e),s=Math.sin(.017453292519943278*e);return new r(t.x*n-t.y*s,t.x*s+t.y*n,t.z)}static GetCenterVecFromVecs(t){let e=new r(0,0,0);for(let n=0,r=t.length;n<r;++n)e.Add(t[n]);return e.Mult(1/t.length),e}static MidVecGeo(t,e){return new r(t.x+.5*e.x,t.y+.5*e.y,0)}static GetVecFromIntersection(t){let e=[];for(let n=0;n<t.length-1;++n)for(let s=n+1;s<t.length-1;++s){let i=r.CheckLineIntersection(t[n],t[n+1],t[s],t[s+1]);i&&e.push(i)}if(0!==e.length)return e}static between(t,e,n){return t-r.eps<=e&&e<=n+r.eps}static segment_intersection(t,e,n,s){var i=((t.x*e.y-t.y*e.x)*(n.x-s.x)-(t.x-e.x)*(n.x*s.y-n.y*s.x))/((t.x-e.x)*(n.y-s.y)-(t.y-e.y)*(n.x-s.x)),h=((t.x*e.y-t.y*e.x)*(n.y-s.y)-(t.y-e.y)*(n.x*s.y-n.y*s.x))/((t.x-e.x)*(n.y-s.y)-(t.y-e.y)*(n.x-s.x));if(isNaN(i)||isNaN(h))return!1;if(t.x>=e.x){if(!r.between(e.x,i,t.x))return!1}else if(!r.between(t.x,i,e.x))return!1;if(t.y>=e.y){if(!r.between(e.y,h,t.y))return!1}else if(!r.between(t.y,h,e.y))return!1;if(n.x>=s.x){if(!r.between(s.x,i,n.x))return!1}else if(!r.between(n.x,i,s.x))return!1;if(n.y>=s.y){if(!r.between(s.y,h,n.y))return!1}else if(!r.between(n.y,h,s.y))return!1;return new r(i,h)}Set(t,e,n){return this.x=t,this.y=e,this.z=n,new r(this.x,this.y,this.z)}Scale(t){return this.x*=t,this.y*=t,this.z*=t,new r(this.x,this.y,this.z)}Mult(t){return this.x*=t,this.y*=t,this.z*=t,new r(this.x,this.y,this.z)}DivByVal(t){return this.x/=t,this.y/=t,this.z/=t,new r(this.x,this.y,this.z)}DivByVec(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,new r(this.x,this.y,this.z)}Add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,new r(this.x,this.y,this.z)}Sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,new r(this.x,this.y,this.z)}Negate(){return this.x*=-1,this.y*=-1,this.z*=-1,new r(this.x,this.y,this.z)}Equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}Clone(){return new r(this.x,this.y,this.z)}Length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}Unitize(){return this.Normalize()}IsOverlap(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;return this.Distance(t)<e}Normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,new r(this.x,this.y,this.z)}Distance(t){return r.Distance(new r(this.x,this.y,this.z),t)}Distance2(t){return r.Distance2(new r(this.x,this.y,this.z),t)}DotProduct(t){return r.DotProduct(new r(this.x,this.y,this.z),t)}CrossProduct(t){return r.CrossProduct(new r(this.x,this.y,this.z),t)}SquareLength(){let t=r.Length(new r(this.x,this.y,this.z));return t*t}FadeExp(t,e){let n=new r(this.x,this.y,this.z);return n.Sub(t),Math.exp(-e*n.SquareLength())}GetAngle(){return Math.atan2(this.y,this.x)}GetAngleDegree(){return 180*this.GetAngle()/Math.PI}ToJSON(){}ToString(){return"x: "+this.x.toFixed(3).toString()+" , y: "+this.y.toFixed(3).toString()+", z: "+this.z.toFixed(3).toString()}ToFloat32Array(){return new Float32Array([this.x,this.y,this.z])}constructor(t,e,n=0){this.x=0,this.y=0,this.z=0,this.w=0,this.long=0,this.lat=0,this.ele=0,this.proX=0,this.proY=0,this.proZ=0,this.alt=0,this.d=!0,this.isModified=!1,this.x=t,this.y=e,this.z=n}}r.eps=1e-7,r.origin=new r(0,0,0)}}]);