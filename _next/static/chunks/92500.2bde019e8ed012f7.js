"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[92500],{92500:function(e,t,n){n.r(t),n.d(t,{CreateGPUBuffer:function(){return s},Solution:function(){return a},vertex:function(){return r},vertexCount:function(){return o}});let i=()=>({vertex:"  \n    struct Output {\n        @builtin(position) Position : vec4<f32>,\n        @location(0) vColor : vec4<f32>,\n    };\n\n    @vertex\n    fn main(@builtin(vertex_index) VertexIndex: u32) -> Output {\n        var pos : array<vec2<f32>, 9> = array<vec2<f32>, 9>(             \n            vec2<f32>(-0.63,  0.80),\n            vec2<f32>(-0.65,  0.20),\n            vec2<f32>(-0.20,  0.60),\n            vec2<f32>(-0.37, -0.07),\n            vec2<f32>( 0.05,  0.18),\n            vec2<f32>(-0.13, -0.40),\n            vec2<f32>( 0.30, -0.13),\n            vec2<f32>( 0.13, -0.64),\n            vec2<f32>( 0.70, -0.30)     \n        );\n    \n        var color : array<vec3<f32>, 9> = array<vec3<f32>, 9>(             \n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),  \n        );\n\n        var output: Output;\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n        return output;\n    }",fragment:"\n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }\n    "}),r=new Float32Array([0,.5,0,-.5,-.5,0,.5,-.5,0]),o=3;class a{async initWebGPU(){if(!navigator.gpu)throw Error("Not Support WebGPU");let e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!e)throw Error("No Adapter Found");let t=await e.requestDevice();this.ctx=this.canvas.getContext("webgpu");let n=navigator.gpu.getPreferredCanvasFormat?navigator.gpu.getPreferredCanvasFormat():this.ctx.getPreferredFormat(e);window.devicePixelRatio,this.canvas.width=this.divHost.clientWidth,this.canvas.height=this.divHost.clientHeight,this.ctx.configure({device:t,format:n,alphaMode:"opaque"}),this.size={width:this.canvas.width,height:this.canvas.height},this.device=t,this.format=n,this.initPipeline(this.device,this.format)}async initPipeline(e,t){let n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"triangle-list";"line-strip"===r&&(n="uint32");let o=i(),a=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:o.vertex}),entryPoint:"main"},fragment:{module:e.createShaderModule({code:o.fragment}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:r,stripIndexFormat:n}}),s=e.createCommandEncoder(),c=this.ctx.getCurrentTexture().createView(),u=s.beginRenderPass({colorAttachments:[{view:c,clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]});u.setPipeline(a),u.draw(9,1,0,0),u.end(),e.queue.submit([s.finish()])}destroy(){for(this.device.destroy();this.divHost.lastElementChild;)this.divHost.removeChild(this.divHost.lastElementChild)}constructor(e){this.mouse=new Float32Array([0,0]),this.divHost=document.getElementById(e),this.canvas=document.createElement("canvas"),this.divHost.appendChild(this.canvas),this.canvas.addEventListener("mousemove",e=>{this.mouse[0],e.offsetX,this.mouse[1],e.offsetY,this.mouse[0]=e.offsetX,this.mouse[1]=e.offsetY,console.log("mousemove",e)},!1),this.initWebGPU()}}let s=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,i=e.createBuffer({size:t.byteLength,usage:n,mappedAtCreation:!0});return new Float32Array(i.getMappedRange()).set(t),i.unmap(),i}}}]);