{"version":3,"file":"static/js/12702.2fbe9b06.chunk.js","mappings":"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","sources":["njslab/Workshop/workshop-three/Slowzone_Point/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, } from '../../../../lib';\r\nimport { getJSONFromURL, distanceTo, MercatorProjection } from 'njscore';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    positions;\r\n    geometry;\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n\r\n    mesh: THREE.Points;\r\n\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Points.threshold = 0.8;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            this.renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n            this.start();\r\n        });\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        this.pointer.x = (e.offsetX / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (e.offsetY / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersections = this.raycaster.intersectObjects([this.mesh], false);\r\n        const intersection = (intersections.length) > 0 ? intersections[0] : null;\r\n\r\n        if (intersection !== null) {\r\n            this.sphere.position.set(intersection.point.x, intersection.point.y, intersection.point.z);\r\n        }\r\n\r\n        let numVertices = this.mesh.geometry.attributes.position.count;\r\n        for (let i = 0; i < numVertices; i++) {\r\n            let o = this.mesh.geometry.attributes.position;\r\n\r\n            let x = o.getX(i);\r\n            let y = o.getY(i);\r\n            let z = o.getZ(i)\r\n\r\n            y = Math.sin(9 * x * z + this.t * 5)\r\n\r\n            y = y < 0 ? 0 : y;\r\n\r\n            let p = new THREE.Vector3(x, y, z);\r\n\r\n            this.mesh.geometry.attributes.position.setXYZ(i, p.x, p.y, p.z);\r\n\r\n            if (intersection !== null) {\r\n                y = distanceTo(x, y, z, intersection.point.x, intersection.point.y, intersection.point.z) / 30\r\n            }\r\n            this.mesh.geometry.attributes.color.setXYZ(i, y, 1 - y, 0);\r\n        }\r\n        this.mesh.geometry.attributes.position.needsUpdate = true;\r\n        this.mesh.geometry.attributes.color.needsUpdate = true;\r\n        this.mesh.geometry.computeVertexNormals();\r\n    }\r\n    public renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.75 });\r\n\r\n        const positions = [];\r\n        const colors = [];\r\n\r\n        const xOFf = -15478803.88731685;\r\n        const yOFf = -4766681.448690384;\r\n        const scale = 0.01;\r\n\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const route = paths[i]\r\n\r\n            for (let j = 0; j < route.length; ++j) {\r\n                for (let k = 0; k < route[j].length; ++k) {\r\n                    const [xPro, yPro] = MercatorProjection(+route[j][k][0], +route[j][k][1]);\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n\r\n                    positions.push(x, 0, y)\r\n                    colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        geometry.computeBoundingSphere();\r\n        this.positions = positions;\r\n        this.geometry = geometry;\r\n        this.mesh = new THREE.Points(geometry, material);\r\n        scene.add(this.mesh);\r\n\r\n    }\r\n};"],"names":["Solution","RendererThree","constructor","super","streetOSM","routesTreated","routesControl","zones30","positions","geometry","raycaster","THREE","pointer","mesh","sphere","renderPoints","scene","paths","color","material","vertexColors","size","colors","i","length","route","j","k","xPro","yPro","MercatorProjection","x","y","push","setAttribute","computeBoundingSphere","this","add","light","camera","params","Points","threshold","far","sphereGeometry","sphereMaterial","position","set","getJSONFromURL","then","data","start","mouseMove","e","offsetX","hostDiv","clientWidth","offsetY","clientHeight","update","setFromCamera","intersections","intersectObjects","intersection","point","z","numVertices","attributes","count","o","getX","getY","getZ","Math","sin","t","p","setXYZ","distanceTo","needsUpdate","computeVertexNormals"],"sourceRoot":""}