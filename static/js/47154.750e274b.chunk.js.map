{"version":3,"file":"static/js/47154.750e274b.chunk.js","mappings":"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","sources":["njslab/Tools/GameOfLife/index.ts"],"sourcesContent":["import { PARAM } from 'App';\r\nimport { RendererCanvas } from '../../../lib'\r\n\r\n\r\nconst getSlider = (title: string, min: number, max: number) => {\r\n    // <input type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\">\r\n    const div = document.createElement('div');\r\n    div.style.display = 'flex';\r\n\r\n    const slider = document.createElement('input');\r\n    slider.type = 'range';\r\n    slider.min = `${min}`;\r\n    slider.max = `${max}`;\r\n\r\n    const text = document.createElement('div');\r\n    text.textContent = title;\r\n    text.style.color = '#aaa';\r\n    div.appendChild(slider);\r\n    div.appendChild(text);\r\n\r\n    return {\r\n        div, slider\r\n    }\r\n};\r\nconst getCheckBox = (title: string) => {\r\n    const div = document.createElement('div');\r\n    div.style.display = 'flex';\r\n\r\n    const checkBox = document.createElement('input');\r\n    checkBox.type = 'checkbox';\r\n    checkBox.defaultChecked = false;\r\n    const text = document.createElement('div');\r\n    text.textContent = title;\r\n    text.style.color = '#aaa';\r\n    div.appendChild(checkBox);\r\n    div.appendChild(text);\r\n\r\n    return {\r\n        div, checkBox\r\n    }\r\n};\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n        this.divHost.appendChild(div);\r\n\r\n        // if (PARAM.demo) {\r\n            this.renderer = new Renderer(div);\r\n\r\n            let btn = document.createElement('div');\r\n            div.appendChild(btn);\r\n            btn.textContent = 'Reset';\r\n            btn.onclick = () => {\r\n                this.renderer.Build();\r\n            };\r\n       \r\n\r\n            btn = document.createElement('div');\r\n            div.appendChild(btn);\r\n            btn.textContent = 'Play and Stop toggle';\r\n            btn.onclick = () => {\r\n                this.renderer.playToggle = !this.renderer.playToggle;\r\n            };\r\n\r\n        // }\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nconst renderCell = (ctx: CanvasRenderingContext2D, node: Node, col: string, cellSize: number) => {\r\n    ctx.fillStyle = col;\r\n    ctx.beginPath();\r\n    ctx.rect(node.x * cellSize, node.y * cellSize, cellSize - 1, cellSize - 1);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n};\r\n\r\nexport class Renderer extends RendererCanvas {\r\n    w: number = 0;\r\n    h: number = 0;\r\n    cols: number = 0;\r\n    rows: number = 0;\r\n    cellSize: number = 20;\r\n    gridWidth: number = 0;\r\n    gridHeight: number = 0;\r\n    chanceOfWalls: number = 0.15;\r\n    connectionDiagonal = true\r\n\r\n    graph: PixelMap;\r\n\r\n    playToggle = true;\r\n\r\n    frame = 0;\r\n    public divTextIteration: HTMLDivElement;\r\n\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        this.divTextIteration = document.createElement('div');\r\n        div.appendChild(this.divTextIteration);\r\n\r\n        this.Build();\r\n        this.start();\r\n    }\r\n    public update() {\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                node.count = 0\r\n                for (let k = 0; k < node.neighbors.length; k++) {\r\n                    if (node.neighbors[k].alive) {\r\n                        node.count++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                if (!node.alive){\r\n                    if(node.count === 3) {\r\n                        node.alive = true; \r\n                    } \r\n                } else {\r\n                    if (node.count < 2) {\r\n                        node.alive = false\r\n                    } else if( 1 < node.count && node.count < 4) {\r\n                        node.alive = true; \r\n                    } else if (node.count > 3) {\r\n                        node.alive = false\r\n                    }\r\n\r\n                    \r\n                }\r\n            }\r\n        }\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        if (this.playToggle) {\r\n            // const result = this.graph.propagation();\r\n            this.divTextIteration.textContent = `${this.frame++} iterations`;\r\n        }\r\n        // const result = this.graph.gePath();\r\n        if (this.graph.doneComputation) { this.Build(); }\r\n        // console.log(result)\r\n\r\n        if (this.frame % 10 === 0) {\r\n            this.update();\r\n        }\r\n\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                const node = this.graph.grid[i][j];\r\n                let color = 'rgb(255, 255, 255)';\r\n\r\n                if (node.blocked) { color = `rgba(0, 0, 0, 0.9)`; }\r\n                if (node === this.graph.endNode) { color = `rgba(255, 0, 255, 0.9)`; }\r\n                if (node.alive) { color = `rgba(0, 0, 0, 1)`; }\r\n\r\n                renderCell(ctx, node, color, this.cellSize);\r\n\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.openNodes.length; i++) { // render open nodes\r\n            const node = this.graph.openNodes[i];\r\n            const color = 'rgb(0, 0, 255)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.closedNodes.length; i++) { // visited nodes\r\n            const node = this.graph.closedNodes[i];\r\n            const color = 'rgb(255, 0, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        for (let i = 0; i < this.graph.path.length; i++) { // path\r\n            const node = this.graph.path[i];\r\n            const color = 'rgb(0, 255, 0)';\r\n            renderCell(ctx, node, color, this.cellSize);\r\n        }\r\n\r\n        // for (let i = 0; i < this.cols; i++) { // connection\r\n        //     for (let j = 0; j < this.rows; j++) {\r\n        //         const node = this.graph.grid[i][j];\r\n        //         if (node.blocked) { continue; }\r\n        //         for (let k = 0; k < node.neighbors.length; ++k) {\r\n        //             ctx.strokeStyle = '#fff';\r\n        //             ctx.lineWidth = 0.58;\r\n        //             ctx.beginPath();\r\n        //             ctx.moveTo(this.cellSize * node.x + this.cellSize * 0.5, this.cellSize * node.y + this.cellSize * 0.5);\r\n        //             ctx.lineTo(this.cellSize * node.neighbors[k].x + this.cellSize * 0.5, this.cellSize * node.neighbors[k].y + this.cellSize * 0.5);\r\n        //             ctx.stroke();\r\n        //         }\r\n\r\n        //     }\r\n        // }\r\n    }\r\n    public Build() {\r\n        this.frame = 0;\r\n        this.w = this.canvas.width;\r\n        this.h = this.canvas.height;\r\n        this.cols = Math.floor(this.w / this.cellSize);\r\n        this.rows = Math.floor(this.h / this.cellSize);\r\n        this.gridWidth = this.w;\r\n        this.gridHeight = this.h;\r\n\r\n\r\n        this.graph = new PixelMap();\r\n        this.graph.connectionDiagonal = this.connectionDiagonal;\r\n\r\n        //Build navigation grid\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                if (this.graph.grid[i] === undefined)\r\n                    this.graph.grid[i] = [];\r\n\r\n                const node = new Node(i, j);\r\n                if (Math.random() < this.chanceOfWalls) { node.alive = true; }\r\n                this.graph.grid[i][j] = node;\r\n            }\r\n        }\r\n\r\n        // this.graph.startNode = this.getRandomCell();\r\n        // this.graph.startNode.blocked = false;\r\n\r\n        // this.graph.endNode = this.getRandomCell();\r\n        // this.graph.endNode.blocked = false;\r\n\r\n        //find neighbors\r\n        for (let i = 0; i < this.cols; i++) {\r\n            for (let j = 0; j < this.rows; j++) {\r\n                this.graph.buildConnection(this.graph.grid[i][j], this.cols, this.rows);\r\n            }\r\n        }\r\n\r\n        // this.graph.openNodes.push(this.graph.startNode);\r\n\r\n    }\r\n}\r\n\r\nclass PixelMap {\r\n    public grid: Node[][] = [];\r\n    public openNodes: Node[] = [];\r\n    public closedNodes: Node[] = [];\r\n    public startNode: Node;\r\n    public endNode: Node;\r\n    public path: Node[] = [];\r\n    public heuristicConst = 1;\r\n    public doneComputation: boolean = false;\r\n    public connectionDiagonal = true;\r\n    // constructor() {\r\n    //     // TODO\r\n    // }\r\n    public buildConnection = (node: Node, cols: number, rows: number) => {\r\n        if (node.blocked) { return; }\r\n\r\n        let x = node.x;\r\n        let y = node.y;\r\n\r\n        if (x < cols - 1) {\r\n            if (!this.grid[x + 1][y].blocked) {\r\n                node.neighbors.push(this.grid[x + 1][y]);\r\n            } // right\r\n        }\r\n\r\n        if (y < rows - 1) {\r\n            if (!this.grid[x][y + 1].blocked) {\r\n                node.neighbors.push(this.grid[x][y + 1]);\r\n            } // bottom\r\n        }\r\n\r\n        if (x > 0) {\r\n            if (!this.grid[x - 1][y].blocked) {\r\n                node.neighbors.push(this.grid[x - 1][y]);\r\n            } // left\r\n        }\r\n\r\n        if (y > 0) {\r\n            if (!this.grid[x][y - 1].blocked) {\r\n                node.neighbors.push(this.grid[x][y - 1]);\r\n            } // top\r\n        }\r\n        if (this.connectionDiagonal) {\r\n            // console.log(this.connectionDiagonal);\r\n            if (x > 0 && y > 0) {\r\n                if (!this.grid[x - 1][y - 1].blocked) {\r\n                    node.neighbors.push(this.grid[x - 1][y - 1]);\r\n                }\r\n            } // left up\r\n            if (x < cols - 1 && y < rows - 1) {\r\n                if (!this.grid[x + 1][y + 1].blocked) {\r\n                    node.neighbors.push(this.grid[x + 1][y + 1]);\r\n                }\r\n            } // right bottom\r\n            if (x > 0 && y < rows - 1) {\r\n                if (!this.grid[x - 1][y + 1].blocked) {\r\n                    node.neighbors.push(this.grid[x - 1][y + 1]);\r\n                }\r\n            } // left bottom\r\n            if (x < cols - 1 && y > 0) {\r\n                if (!this.grid[x + 1][y - 1].blocked) {\r\n                    node.neighbors.push(this.grid[x + 1][y - 1]);\r\n                }\r\n            } // right top\r\n        }\r\n    }\r\n}\r\nclass Node {\r\n    public f = 0;\r\n    public h = 0;\r\n    public g = 0;\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n    public neighbors: Node[] = [];\r\n    public count = 0;\r\n    public alive = false;\r\n    public blocked = false;\r\n    constructor(x: number, y: number) {\r\n        this.f = 0;\r\n        this.h = 0;\r\n        this.g = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.neighbors = [];\r\n    }\r\n}\r\n\r\n"],"names":["Solution","constructor","id","divHost","renderer","this","document","getElementById","style","display","alignItems","div","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","Renderer","btn","textContent","onclick","Build","playToggle","destroy","lastElementChild","removeChild","renderCell","ctx","node","col","cellSize","fillStyle","beginPath","rect","x","y","closePath","fill","RendererCanvas","super","w","h","cols","rows","gridWidth","gridHeight","chanceOfWalls","connectionDiagonal","graph","frame","divTextIteration","canvas","position","start","update","i","j","grid","count","k","neighbors","length","alive","render","doneComputation","color","blocked","endNode","openNodes","closedNodes","path","Math","floor","PixelMap","undefined","Node","random","buildConnection","startNode","heuristicConst","push","f","g","z"],"sourceRoot":""}