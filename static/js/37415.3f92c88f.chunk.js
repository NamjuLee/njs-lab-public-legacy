"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[37415],{37415:(t,e,n)=>{n.r(e),n.d(e,{NVector3:()=>s});class s{static GetVecforGraphicApp(t,e,n,r,i,h){let l=new s(0,0,0);return l.long=t,l.lat=e,l.ele=n,l.proX=r,l.proY=i,l.proZ=h,l}static DeepCopy(t){const e=new s(t.x,t.y,t.z);return e.long=t.long,e.lat=t.lat,e.proX=t.proX,e.proY=t.proY,e.proZ=t.proZ,e}static Dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static GetAreayConvexGPS(t){let e=[],n=[];for(let c=0;c<t.length;++c)e.push(t[c].lat),n.push(t[c].long);e.push(t[0].lat),n.push(t[0].long);let s=0,r=0;for(let c=e.length;c--;)s+=e[c],r+=n[c];let i,h,l,a=s/e.length,o=r/n.length,y=new Array(e.length);for(let c=e.length;c--;)e[c]-=a,n[c]-=o,n[c]>=0&&e[c]>=0?y[c]=Math.abs(180*Math.atan(e[c]/n[c])/Math.PI):n[c]<0&&e[c]>=0?y[c]=90+Math.abs(180*Math.atan(e[c]/n[c])/Math.PI):n[c]<0&&e[c]<0?y[c]=180+Math.abs(180*Math.atan(e[c]/n[c])/Math.PI):n[c]>=0&&e[c]<0&&(y[c]=270+Math.abs(180*Math.atan(e[c]/n[c])/Math.PI));for(let c=0;c<y.length;c++)for(let t=0;t<y.length-1;t++)i=y[t],h=e[t],l=n[t],i<y[t+1]&&(y[t]=y[t+1],e[t]=e[t+1],n[t]=n[t+1],y[t+1]=i,e[t+1]=h,n[t+1]=l);let x=0,u=0;for(let c=0;c<e.length;c++)c!==e.length-1?(x+=e[c]*n[c+1],u+=n[c]*e[c+1]):(x+=e[c]*n[0],u+=n[c]*e[0]);return 20*((x-u)/2)}static ScalarRev_V_S_OUT(t,e,n){return n.x=e*t.x,n.y=e*t.y,n.z=e*t.z,n}static Add(t,e){return new s(t.x+e.x,t.y+e.y,t.z+e.z)}static Sub(t,e){return new s(t.x-e.x,t.y-e.y,t.z-e.z)}static Clone(t){return s.DeepCopy(t)}static ZAxis(){return new s(0,0,1)}static YAxis(){return new s(0,1,0)}static Zero(){return new s(0,0,0)}static Origin(){return new s(0,0,0)}static Plus(t,e){return new s(t.x+e.x,t.y+e.y,t.z+e.z)}static Scale(t,e){return new s(t.x*e,t.y*e,t.z*e)}static MidVec(t,e){return new s(.5*(t.x+e.x),.5*(t.y+e.y),.5*(t.z+e.z))}static CompareTwoVectors(t,e){return t.x===e.x&&t.y===e.y&&t.z===e.z}static Length(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z)}static Normalize(t){let e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);return new s(t.x/e,t.y/e,t.z/e)}static GetArea(t){let e=0;for(let n=0,s=t.length;n<s;n++){e+=t[n].x*t[n===t.length-1?0:n+1].y*.5,e-=t[n===t.length-1?0:n+1].x*t[n].y*.5}return Math.abs(e)}static GetAreaByLongLat(t){let e=0;for(let n=0;n<t.length-1;n++)e+=(t[n].long-t[n+1].long)*(t[n].lat+t[n+1].lat);return e*=.5,e}static GetGeoArea(t){let e=0;for(let n=0;n<t.length-1;n++)e+=(t[n].x-t[n+1].x)*(t[n].y+t[n+1].y);return e*=.5,Math.abs(e)}static GetGeoAreaBbyLongLat(t){let e=0;for(let n=0;n<t.length-1;n++)e+=(t[n].long-t[n+1].long)*(t[n].lat+t[n+1].lat);return e*=.5,Math.abs(e)}static Distance(t,e){return Math.sqrt((t.x-e.x)*(t.x-e.x)+(t.y-e.y)*(t.y-e.y)+(t.z-e.z)*(t.z-e.z))}static Distance2(t,e){return(t.x-e.x)*(t.x-e.x)+(t.y-e.y)*(t.y-e.y)+(t.z-e.z)*(t.z-e.z)}static DotProduct(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static CrossProduct(t,e){return new s(t.y*e.z-t.z*e.y,t.z*e.x-t.x*e.z,t.x*e.y-t.y*e.x)}static DivideByNum(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5,r=[],i=(e.x-t.x)/n,h=(e.y-t.y)/n,l=(e.z-t.z)/n;for(let a=0;a<n;++a){let e=t.x+i*a,n=t.y+h*a,o=t.z+l*a;r.push(new s(e,n,o))}return r}static KMeterFromGeoGPSPos(t,e){let n=e.lat*Math.PI/180-t.lat*Math.PI/180,s=e.long*Math.PI/180-t.long*Math.PI/180,r=Math.sin(n/2)*Math.sin(n/2)+Math.cos(t.lat*Math.PI/180)*Math.cos(e.lat*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6378.137*(2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)))}static KMeterByTwoGeoPos(t,e,n,r){let i=new s(0,0);i.long=t,i.lat=e;let h=new s(0,0);return h.long=n,h.lat=r,s.KMeterFromGeoGPSPos(i,h)}static KMeterFromGPSPos(t,e){let n=e.y*Math.PI/180-t.y*Math.PI/180,s=e.x*Math.PI/180-t.x*Math.PI/180,r=Math.sin(n/2)*Math.sin(n/2)+Math.cos(t.y*Math.PI/180)*Math.cos(e.y*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6378.137*(2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)))}static Get1KM_Long_ByGeoUnit(){let t=new s(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,0),e=0;for(let n=0;n<1e4;++n){let n=s.KMeterFromGPSPos(t,new s(t.x+e,t.y,t.z));if(1<n&&n<1.001)return t.x+e;e+=1e-5}return-1}static Get1KM_lat_ByGeoUnit(){let t=new s(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,0),e=0;for(let n=0;n<1e4;++n){let n=s.KMeterFromGPSPos(t,new s(t.x,t.y+e,t.z));if(1<n&&n<1.001)return t.y+e;e+=1e-5}return-1}static Get1KM_Lat_Long_GeoUnit(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=s.Get1KM_Long_ByGeoUnit(t,e),r=s.Get1KM_lat_ByGeoUnit(t,e);return new s(n,r,0)}static CalculateFalloff(t,e,n,s){let r=e.Sub(t).Length();return r*(n*Math.exp(-s*r*r))}static Attractor(t,e,n,s){let r=e.Sub(t);r.Unitize();let i=r.Length();return r.Mult(n*Math.exp(-s*i*i))}static Explosion(t,e,n,s){let r=e.Sub(t);r.Unitize();let i=r.Length();return r.Mult(-n*Math.exp(-s*i*i))}static Rotor(t,e,n,r){return e.Sub(t).Unitize(),s.Origin()}static GetAngleBetween(t,e){return Math.atan2(e.x-t.x,e.y-t.y)}static GetCosAngleByTwoVectors(t,e){return s.DotProduct(s.Normalize(t),s.Normalize(e))}static GetAngleByTwoVectorsRadian(t,e){return Math.acos(s.GetCosAngleByTwoVectors(t,e))}static GetAngleByTwoVectors(t,e){return 180*s.GetAngleByTwoVectorsRadian(t,e)/Math.PI}static GetRotationByWorldCoodinate(t){let e=new s(1,0,0);return s.GetAngleByTwoVectors(e,t)}static GetRotationByWorldCoodinateByTwo(t,e){let n=e.Sub(t),r=new s(1,0,0);return n.y>0?-1*s.GetAngleByTwoVectors(r,n):s.GetAngleByTwoVectors(r,n)}static ComputeDotProducts(t){let e=[];for(let n=0;n<t.length;++n)if(n<t.length-1){let r=new s(t[n].x,t[n].y,t[n].z),i=new s(t[n+1].x,t[n+1].y,t[n+1].z);i.x-=r.x,i.y-=r.y,i.z-=r.z;let h=s.DotProduct(new s(1,0,0),s.Normalize(i));Number.isNaN(h)?e.push(e[e.length-1]):e.push(h)}else{let r=new s(t[n].x,t[n].y,t[n].z),i=new s(t[0].x,t[0].y,t[0].z);i.x-=r.x,i.y-=r.y,i.z-=r.z;let h=s.DotProduct(new s(1,0,0),s.Normalize(i));Number.isNaN(h)?e.push(e[e.length-1]):e.push(h)}return e}static ComputeDotProductsWithCenter(t){let e=s.GetCenterVecFromVecs(t),n=[];for(let r=0;r<t.length;++r){let i,h;r<t.length-1?(i=new s(t[r].x-e.x,t[r].y-e.y,t[r].z-e.z),h=new s(t[r+1].x-e.x,t[r+1].y-e.y,t[r+1].z-e.z)):(i=new s(t[r].x-e.x,t[r].y-e.y,t[r].z-e.z),h=new s(t[0].x-e.x,t[0].y-e.y,t[0].z-e.z));let l=s.DotProduct(s.Normalize(i),s.Normalize(h));n.push(l)}return n}static GetXYDimForCircle(t){let e=s.GetCenterVecFromVecs(t),n=0,r=0,i=t.length;for(let s=0;s<i;++s)n+=Math.abs(t[s].x-e.x),r+=Math.abs(t[s].y-e.y);return i+=2,[n/i,r/i]}static DistanceMouseWithTwoVecs(t,e,n){e.x+=1e-5,e.y+=1e-5;let r=s.GetBoundingVecs(e,n),i=s.GetCloseVec(e,n,t.x,t.y,r,!0);return s.Distance(t,i)}static GetCloseVec(t,e,n,r,i){let h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],l=new s(t.x,t.y,t.z),a=new s(e.x,e.y,e.z).Sub(l),o=new s(n,r,0).Sub(l);a.Unitize();let y=l.Add(a.Mult(o.DotProduct(a)));return h?s.IsInsideOfVecs(y,i)?y:t.Distance(y)<e.Distance(y)?new s(t.x,t.y,t.z):new s(e.x,e.y,e.z):y}static GetBoundingVecs(t,e){let n=[],r=0,i=0,h=0;r=t.x<e.x?t.x:e.x,i=t.y<e.y?t.y:e.y,h=t.z<e.z?t.z:e.z;let l=new s(r,i,h);r=t.x>e.x?t.x:e.x,i=t.y>e.y?t.y:e.y,h=t.z>e.z?t.z:e.z;let a=new s(r,i,h);return n.push(new s(l.x,l.y,l.z)),n.push(new s(a.x,l.y,l.z)),n.push(new s(a.x,a.y,l.z)),n.push(new s(l.x,a.y,l.z)),n}static GetBoundaryByVecWidthHeight(t,e,n){let r=[];return r.push(new s(t.x,t.y,t.z)),r.push(new s(t.x+e,t.y,t.z)),r.push(new s(t.x+e,t.y+n,t.z)),r.push(new s(t.x,t.y+n,t.z)),r}static GetMinMaxVecFromVecs(t){let e=Number.MAX_VALUE,n=Number.MAX_VALUE,r=Number.MAX_VALUE,i=Number.MIN_VALUE,h=Number.MIN_VALUE,l=Number.MIN_VALUE;for(let s of t)e>s.x&&(e=s.x),n>s.y&&(n=s.y),r>s.z&&(r=s.z),i<s.x&&(i=s.x),h<s.y&&(h=s.y),l<s.z&&(l=s.z);return[new s(e,n,r),new s(i,h,l)]}static RemoveVecsWithinDis(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,n=[];for(let r=0;r<t.length-1;++r){let n=t[r];if(!1!==n.d)for(let i=r+1;i<t.length;++i)s.Distance(n,t[i])<e&&(t[i].d=!1)}for(let s=0;s<t.length;++s)!0===t[s].d&&n.push(t[s]);return n}static IsInsideOfVecsWtihVecs(t,e){let n=!0;for(let r=0;r<t.length;r++)if(n=s.IsInsideOfVecs(t[r],e),!n)return!1;return!0}static IsInsideOfVecs(t,e){let n=t.x,s=t.y,r=!1;for(let i=0,h=e.length-1;i<e.length;h=i++){let t=e[i].x,l=e[i].y,a=e[h].x,o=e[h].y;l>s!==o>s&&n<(a-t)*(s-l)/(o-l)+t&&(r=!r)}return r}static IsInsideOfVecsByCrossing(t,e,n,r){return!!this.IsInsideOfVecs(new s(t.x-.5*e,t.y-.5*n),r)||(!!this.IsInsideOfVecs(new s(t.x+.5*e,t.y-.5*n),r)||(!!this.IsInsideOfVecs(new s(t.x+.5*e,t.y+.5*n),r)||!!this.IsInsideOfVecs(new s(t.x-.5*e,t.y+.5*n),r)))}static IsInsideOfVecsByConcaveHull(t,e){}static IsInsideOfVecsByConvexHull(t,e){return e=s.ConvexHull(e),!!s.IsInsideOfVecs(t,e)}static ConvexHull(t){t.sort((function(t,e){return t.x===e.x?t.y-e.y:t.x-e.x}));let e=[];for(let r=0;r<t.length;r++){for(;e.length>=2&&s.Cross(e[e.length-2],e[e.length-1],t[r])<=0;)e.pop();e.push(t[r])}let n=[];for(let r=t.length-1;r>=0;r--){for(;n.length>=2&&s.Cross(n[n.length-2],n[n.length-1],t[r])<=0;)n.pop();n.push(t[r])}n.pop(),e.pop();for(let s=0;s<n.length;++s)e.push(n[s]);return e}static Cross(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static Cross_A_B_OUT(t,e,n){const s=t.x,r=t.y,i=t.z,h=e.x,l=e.y,a=e.z;return n.x=r*a-i*l,n.y=i*h-s*a,n.z=s*l-r*h,n}static CheckLineIntersection(t,e,n,r){let i=0,h=0,l=0,a=0,o=0,y=!1,x=!1;i=(r.y-n.y)*(e.x-t.x)-(r.x-n.x)*(e.y-t.y);let u=new s(0,0,0);if(0!==i)return h=t.y-n.y,l=t.x-n.x,a=(r.x-n.x)*h-(r.y-n.y)*l,o=(e.x-t.x)*h-(e.y-t.y)*l,h=a/i,l=o/i,u.x=t.x+h*(e.x-t.x),u.y=t.y+h*(e.y-t.y),h>0&&h<1&&(y=!0),l>0&&l<1&&(x=!0),y&&x?u:void 0}static CheckConvexity(t){if(t.length<3)return!1;let e,n,r,i=0;for(let h=0;h<t.length;h++){e=t[h];let l=t[(h+1)%t.length];if(n=new s(l.x-e.x,l.y-e.y,0),r=t[(h+2)%t.length],0===h)i=r.x*n.y-r.y*n.x+n.x*e.y-n.y*e.x;else{let t=r.x*n.y-r.y*n.x+n.x*e.y-n.y*e.x;if(t>0&&i<0||t<0&&i>0)return!1}}return!0}static MoveVecs(t,e){let n=[];for(let r=0;r<t.length;++r)n.push(s.MoveVec(t[r],e));return n}static MoveVec(t,e){return new s(t.x+e.x,t.y+e.y,t.z+e.z)}static RotateVecsLoal(t,e){let n=s.GetCenterVecFromVecs(t),r=new s(-n.x,-n.y,-n.z),i=s.MoveVecs(t,r);return i=s.RotateVecs(i,e),i=s.MoveVecs(i,n),i}static RotateVecs(t,e){let n=[];for(let r=0;r<t.length;++r)n.push(s.RotateVec(t[r],e));return n}static RotateVec(t,e){let n=Math.cos(.017453292519943278*e),r=Math.sin(.017453292519943278*e),i=t.x*n-t.y*r,h=t.x*r+t.y*n;return new s(i,h,t.z)}static GetCenterVecFromVecs(t){let e=new s(0,0,0);for(let n=0,s=t.length;n<s;++n)e.Add(t[n]);return e.Mult(1/t.length),e}static MidVecGeo(t,e){return new s(t.x+.5*e.x,t.y+.5*e.y,0)}static GetVecFromIntersection(t){let e=[];for(let n=0;n<t.length-1;++n)for(let r=n+1;r<t.length-1;++r){let i=s.CheckLineIntersection(t[n],t[n+1],t[r],t[r+1]);i&&e.push(i)}return 0===e.length?void 0:e}static between(t,e,n){return t-s.eps<=e&&e<=n+s.eps}static segment_intersection(t,e,n,r){var i=((t.x*e.y-t.y*e.x)*(n.x-r.x)-(t.x-e.x)*(n.x*r.y-n.y*r.x))/((t.x-e.x)*(n.y-r.y)-(t.y-e.y)*(n.x-r.x)),h=((t.x*e.y-t.y*e.x)*(n.y-r.y)-(t.y-e.y)*(n.x*r.y-n.y*r.x))/((t.x-e.x)*(n.y-r.y)-(t.y-e.y)*(n.x-r.x));if(isNaN(i)||isNaN(h))return!1;if(t.x>=e.x){if(!s.between(e.x,i,t.x))return!1}else if(!s.between(t.x,i,e.x))return!1;if(t.y>=e.y){if(!s.between(e.y,h,t.y))return!1}else if(!s.between(t.y,h,e.y))return!1;if(n.x>=r.x){if(!s.between(r.x,i,n.x))return!1}else if(!s.between(n.x,i,r.x))return!1;if(n.y>=r.y){if(!s.between(r.y,h,n.y))return!1}else if(!s.between(n.y,h,r.y))return!1;return new s(i,h)}constructor(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.x=0,this.y=0,this.z=0,this.w=0,this.long=0,this.lat=0,this.ele=0,this.proX=0,this.proY=0,this.proZ=0,this.alt=0,this.d=!0,this.isModified=!1,this.parent=void 0,this.x=t,this.y=e,this.z=n}Set(t,e,n){return this.x=t,this.y=e,this.z=n,new s(this.x,this.y,this.z)}Scale(t){return this.x*=t,this.y*=t,this.z*=t,new s(this.x,this.y,this.z)}Mult(t){return this.x*=t,this.y*=t,this.z*=t,new s(this.x,this.y,this.z)}DivByVal(t){return this.x/=t,this.y/=t,this.z/=t,new s(this.x,this.y,this.z)}DivByVec(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,new s(this.x,this.y,this.z)}Add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,new s(this.x,this.y,this.z)}Sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,new s(this.x,this.y,this.z)}Negate(){return this.x*=-1,this.y*=-1,this.z*=-1,new s(this.x,this.y,this.z)}Equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}Clone(){return new s(this.x,this.y,this.z)}Length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}Unitize(){return this.Normalize()}IsOverlap(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;return this.Distance(t)<e}Normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,new s(this.x,this.y,this.z)}Distance(t){return s.Distance(new s(this.x,this.y,this.z),t)}Distance2(t){return s.Distance2(new s(this.x,this.y,this.z),t)}DotProduct(t){return s.DotProduct(new s(this.x,this.y,this.z),t)}CrossProduct(t){return s.CrossProduct(new s(this.x,this.y,this.z),t)}SquareLength(){let t=s.Length(new s(this.x,this.y,this.z));return t*t}FadeExp(t,e){let n=new s(this.x,this.y,this.z);return n.Sub(t),Math.exp(-e*n.SquareLength())}GetAngle(){return Math.atan2(this.y,this.x)}GetAngleDegree(){return 180*this.GetAngle()/Math.PI}ToJSON(){}ToString(){return"x: "+this.x.toFixed(3).toString()+" , y: "+this.y.toFixed(3).toString()+", z: "+this.z.toFixed(3).toString()}ToFloat32Array(){return new Float32Array([this.x,this.y,this.z])}}s.eps=1e-7,s.origin=new s(0,0,0)}}]);
//# sourceMappingURL=37415.3f92c88f.chunk.js.map