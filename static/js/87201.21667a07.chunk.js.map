{"version":3,"file":"static/js/87201.21667a07.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Controller/EventController.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Controller/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Renderer/Camera/Cameras.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Renderer/Camera/CameraController.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Renderer/WebGPU.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Renderer/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Geometry/NGeojsonPoint/Geometry.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Geometry/Base/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Geometry/NGeojsonPoint/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Geometry/NGeojsonLine/Geometry.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Geometry/NGeojsonLine/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Geometry/NSphereWire/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/Scene/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/lib/index.ts"],"sourcesContent":["import { Float32BufferAttribute } from 'three';\nimport { Controller } from '.';\nexport class EventController {\n    public controller: Controller;\n    public pos = [0, 0]\n    public mNormalized = new Float32Array([0,0]);\n    public isDown = false\n    constructor(controller: Controller) {\n        this.controller = controller;\n\n    }\n    public init() {\n        this.appendEvent();\n    }\n    public appendEvent() {\n        this.controller.app.renderer.canvas.addEventListener('ondrag', (e: MouseEvent) => {\n            // console.log('click', e);\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('click', (e: MouseEvent) => {\n            // console.log('click', e);\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('dblclick', (e: MouseEvent) => {\n            // console.log('d-click', e);\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('drag', (e: MouseEvent) => {\n            // console.log('drag', e);\n        }, true);\n        this.controller.app.renderer.canvas.addEventListener('mouseup', (e: MouseEvent) => {\n            // console.log('mouse up', e);\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('mousedown', (e: MouseEvent) => {\n            this.isDown = true;\n            this.pos[0] = e.offsetX;\n            this.pos[1] = e.offsetY;\n\n            // canvas.addEventListener(\"mousemove\", (event) => {\n    \n            //   });\n            // this.controller.app.renderer.camera.translateX(0.25)\n            // this.controller.app.renderer.cameraController.translateX();\n            // this.controller.app.renderer.cameraController.rotateZ();\n            // console.log('pointer down', e);\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('mouseup', (e: MouseEvent) => {\n            // console.log('pointer up', e);\n            this.isDown = false;\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('mousemove', (e: MouseEvent) => {\n            if (this.isDown) {\n                // console.log('move dragging')\n                const xOff = this.pos[0] - e.offsetX;\n                const yOff = this.pos[1] - e.offsetY;\n\n                this.controller.app.renderer.cameraController.moveCamera(xOff, yOff)\n                this.pos[0] = e.offsetX;\n                this.pos[1] = e.offsetY;\n\n\n\n            } else {\n                // console.log('move')\n\n                const rect = this.controller.app.renderer.canvas.getBoundingClientRect();\n                this.mNormalized[0] = (e.clientX - rect.left) / this.controller.app.renderer.canvas.width;\n                this.mNormalized[1] = (e.clientY - rect.top) / this.controller.app.renderer.canvas.height;\n                // console.log(this.mNormalized)\n            \n\n            }\n\n            // console.log('mousemove', e);\n        }, false);\n        this.controller.app.renderer.canvas.addEventListener('wheel', (e:  WheelEvent) => {\n            // console.log('wheel', e.deltaY);\n            this.controller.app.renderer.cameraController.zoomWheel(e.deltaY)\n        }, false);\n\n        window.addEventListener('keydown', (e:  KeyboardEvent) => {\n            this.controller.keyboard(e);\n        }, false);\n    }\n}","import { App } from \"..\";\nimport { EventController } from './EventController';\nexport class Controller {\n    app: App;\n    eventController: EventController;\n\n    constructor(app: App) {\n        this.app = app;\n        this.eventController = new EventController(this);\n    }\n    public init() {\n        this.eventController.init()\n    }\n    public keyboard(k: KeyboardEvent) {\n        if(k.key === 'p') {\n           this.app.renderer.cameraController.shiftCamera();\n        }\n\n    }\n    \n}","import { vec2, vec3, mat4 } from 'gl-matrix';\nimport { } from '../../lib';\n\nexport class Camera {\n    public viewMatrix = mat4.create();\n    public projectionMatrix = mat4.create(); \n    public viewProjectionMatrix = mat4.create();\n\n    public zoomMax = 100;\n    public zoomSpeed = 2;\n\n    public near = 0.01;\n    public far = 10000;\n\n    public mvpMatrix = mat4.create();\n\n    public eye = vec3.fromValues(0,0,0);\n    // public eye = vec3.fromValues(0, 1, 0);\n    public center = vec3.fromValues(0, 0, 0);\n    public up = vec3.fromValues(0, 1, 0);\n\n    public type ='camera';\n\n    public respectRatio: number;\n    public width: number;\n    public height: number;\n\n    public angleXY = Math.PI; \n    public angleZ = Math.PI * 0.25;\n    public distance = 1;\n\n    constructor(width: number = 100, height: number = 100, cameraPosition: vec3 = [2, 2, 4], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance: number = 5) {\n        this.distance = distance; this.width = width; this.height = height; this.respectRatio = width / height\n        this.eye = cameraPosition;\n        this.center = center;\n        this.up = up;\n    }\n    public zoom(v: number) { \n        //\n    }\n    public update() {\n        mat4.lookAt(this.viewMatrix, this.eye, this.center, this.up);\n        mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);\n\n        // createTransforms(this.modelMatrix, this.translation, this.rotation);\n        // mat4.multiply(this.mvpMatrix, this.viewProjectionMatrix, this.viewMatrix);\n        // console.log(this.type);\n    }\n    \n}\n\nexport class CameraPerspective extends Camera {\n    constructor(width = 100, height = 100, cameraPosition: vec3 = [2, 2, 4], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance = 3){\n        super(width, height, cameraPosition, center, up, distance);\n        this.type = 'CameraPerspective';\n        this.init();\n    }\n    public init() {\n        mat4.perspective(this.projectionMatrix, 2 * Math.PI / 5, this.respectRatio, this.near, this.far);\n        this.update();\n    }\n    public zoom (v: number ) {\n        this.distance += v * 0.01;\n    }\n\n}\nexport class CameraOrth extends Camera {\n    constructor(width = 100, height = 100, cameraPosition: vec3 = [0 ,0, 1], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance = 300.1){\n        super(width, height, cameraPosition, center, up, distance);\n        this.type = 'CameraOrth';\n        this.init()\n    }\n    public init() {\n        projection(this.projectionMatrix, this.width, this.height, this.near , this.far, this.distance);\n\n        // const aspectRatio = width / height;\n        // const zoomFactor = 0.1; //this.distance;\n        // const projectionMatrix = mat4.ortho(\n        //   -aspectRatio * zoomFactor,\n        //   aspectRatio * zoomFactor,\n        //   -1 * zoomFactor,\n        //   1 * zoomFactor,\n        //   0.1,\n        //   100.0\n        // );\n\n        // mat4.ortho(this.projectionMatrix, -aspectRatio * zoomFactor, aspectRatio * zoomFactor,  -1 * zoomFactor, 1 * zoomFactor, this.near, this.far);\n        // mat4.ortho(this.projectionMatrix, 0, 500, 800, 0, 0.1, 5000);\n        // mat4.ortho(this.projectionMatrix, 0, 0, 800, 800, -400 , 400);\n        // mat4.frustum(this.projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n\n        this.angleXY = 0;\n        this.angleZ = 0;\n        this.update();\n    }\n    public zoom(v: number) {\n        this.distance += v + 50 / this.distance;\n        if (this.distance < 0.000001) { this.distance = 0.000001; }\n        if (this.distance > 100000) { this.distance = 100000; }\n        projection(this.projectionMatrix, this.width, this.height, this.near, this.far, this.distance);\n    }\n}\n\nconst projection = (dst, width, height, near , far, scale) => {\n    // Note: This matrix flips the Y axis so that 0 is at the top.\n    // dst = dst || new Float32Array(16);\n    dst[ 0] = 2 / width * scale;    dst[ 1] = 0;                    dst[ 2] = 0;                        dst[ 3] = 0;\n    dst[ 4] = 0;                    dst[ 5] = 2 / height * scale;   dst[ 6] = 0;                        dst[ 7] = 0;\n    dst[ 8] = 0;                    dst[ 9] = 0;                    dst[10] = -2 / (far - near);       dst[11] = 0;\n    dst[12] = 0;                    dst[13] = 0;                    dst[14] = 0.1;                      dst[15] = 1;\n    // dst[12] = -1;                dst[13] = 1;                    dst[14] = 0.5;                      dst[15] = 1;\n    return dst;\n};\n\n// const createOrthographicMatrix = (left, right, bottom, top, near, far) => {\n//     const tx = -(right + left) / (right - left);\n//     const ty = -(top + bottom) / (top - bottom);\n//     const tz = -(far + near) / (far - near);\n  \n//     return [\n//       2 / (right - left), 0, 0, 0,\n//       0, 2 / (top - bottom), 0, 0,\n//       0, 0, -2 / (far - near), 0,\n//       tx, ty, tz, 1,\n//     ];\n//   }","import { vec2, vec3, mat4 } from 'gl-matrix';\nimport { Camera, CameraPerspective, CameraOrth } from './Cameras';\nimport { Renderer } from '..';\n\nexport class CameraController {\n    public solution: Renderer;\n    public canvas: HTMLCanvasElement\n\n    public cameraOrth: Camera;\n    public cameraPerspective: Camera;\n\n    public camera: Camera;\n\n    private modelMatrix: mat4 = mat4.create();\n    private mvpMatrix: mat4 = mat4.create();\n\n    // public vMatrix: mat4;\n    // public vpMatrix: mat4;\n    public rotation =vec3.fromValues(0, 0, 0); \n    public translation =vec3.fromValues(0, 0, 0);\n    public screen2 = vec2.fromValues(0, 0);\n\n    // public projectionMatrix = mat4.create();\n\n    // public eye = vec3.fromValues(0,10,0);\n    // angleXY 1.9300000000000026 angleZ -0.47999999999999976 5 distance\n\n    // angleXY 2.6400000000000046 angleZ 0.6799999999999998 3.3800000000000017 distance\n    // src_njslab_Infrastructure_WebGPU_WebGPU_NJS_Sandbox_01_index_ts.chunk.js:1121 camera.eye Float32Array(3) [1.2636959552764893, -2.3044490814208984, 2.1253204345703125,\n\n\n    constructor(solution: Renderer) {\n        this.solution = solution;\n        this.canvas = solution.canvas;\n\n        const eye = vec3.fromValues(2.6451475620269775, 3.130298137664795, 2.864337205886841); // 1.6399056911468506, 1.1976807117462158, 1.162699580192566\n        // const eye = vec3.fromValues(10, -10, 2);\n        const center = vec3.fromValues(0, 0, 0);\n        const up = vec3.fromValues(0, 0, 1);\n\n        this.cameraPerspective = new CameraPerspective(this.canvas.width, this.canvas.height, eye, center, up);\n        this.camera = this.cameraPerspective; \n        this.arcRotation(0, 0);\n\n        this.cameraOrth = new CameraOrth(this.canvas.width, this.canvas.height);\n        this.camera = this.cameraOrth; // this.cameraPerspective // this.cameraOrth;\n\n        this.update();\n    }\n    public update() {\n        // mat4.lookAt(this.vMatrix, this.eye, this.center, this.up);\n        this.camera.update();\n\n        // mat4.multiply(this.camera.viewProjectionMatrix, this.camera.projectionMatrix, this.camera.viewMatrix);\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n        mat4.multiply(this.mvpMatrix, this.camera.viewProjectionMatrix, this.modelMatrix);\n        // console.log('camera updated...');\n    }\n    public rotateZ(val = 0.1) {\n        this.rotation[2] += val;\n        this.update();\n    }\n    public translateX(val = 0.1) {\n        this.translation[0] += val;\n        this.update();\n    }\n    public get getMatrix() {\n        return this.mvpMatrix;\n    }\n    public shiftCamera() {\n        // console.log('shiftCamera');\n        if (this.camera === this.cameraPerspective){\n            this.camera = this.cameraOrth;\n        } else {\n            this.camera = this.cameraPerspective;\n        }\n        this.update();\n    }\n    public moveCamera(x: number, y: number) {\n        if (this.camera === this.cameraPerspective){\n            this.arcRotation(x, y);\n        } else {\n            this.pan(x, y);\n        }\n    }\n    public arcRotation(x: number, y: number) {\n        x = x * -0.01;\n        y = y * -0.01;\n        this.camera.angleXY += x;\n        this.camera.angleZ += y;\n        this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.camera.angleXY) * Math.cos(this.camera.angleZ)) * this.camera.distance;\n        this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.camera.angleXY) * Math.cos(this.camera.angleZ)) * this.camera.distance;\n        this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.camera.angleZ) * this.camera.distance);\n\n        // console.log('angleXY', this.camera.angleXY, 'angleZ', this.camera.angleZ, this.camera.distance, 'distance' )\n        // console.log('camera.eye', this.camera.eye )\n\n\n        this.update();\n    }\n    public zoomWheel(v: number) {\n\n        if (this.camera === this.cameraPerspective){\n            this.camera.zoom(v)\n            this.arcRotation(0, 0);\n        } else {\n            this.camera.zoom(v)\n        }\n        \n        // \n\n        // console.log(this.scale);\n\n        this.update();\n    }\n    public pan(x: number, y: number) {\n        const scale = 0.01\n        this.camera.center[0] += x / this.camera.distance ;\n        this.camera.center[1] -= y / this.camera.distance;\n        this.camera.eye[0] += x / this.camera.distance;\n        this.camera.eye[1] -= y / this.camera.distance;\n        this.update();\n\n    }\n    // public arcRotation(x: number, y: number) {\n    //     x = x * 0.01;\n    //     y = y * 0.01;\n    //     this.angleXY += x;\n    //     this.angleZ += y;\n    //     this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n    //     this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n    //     this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.angleZ) * this.distance);\n\n    //     console.log('angleXY', this.angleXY, 'angleZ', this.angleZ, this.distance, 'distance' )\n    //     console.log('camera.eye', this.camera.eye )\n    //     this.update();\n    // }\n}\n\nconst createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};","import { Renderer } from '.';\n\nexport enum PrimitiveTopology {\n    PointList = 'point-list',\n    LineList = 'line-list',\n    LineStrip = 'line-strip',\n    TriangleList = 'triangle-list',\n    TriangleStrip = 'triangle-strip',\n}\n\nexport class WebGPU {\n    public renderer: Renderer;\n\n    ctx: GPUCanvasContext;\n    device: GPUDevice;\n    format: GPUTextureFormat;\n\n    commandEncoder: GPUCommandEncoder;\n    renderPass: GPURenderPassEncoder;\n\n    textureView: GPUTextureView;\n\n    PrimitiveTopology = PrimitiveTopology;\n\n\n    renderPassDescription: GPURenderPassDescriptor;\n\n    depthTexture : GPUTexture;\n\n    constructor(renderer: Renderer) {\n        this.renderer = renderer;\n    }\n    public async initWebGPU() {\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\n        const adapter = await navigator.gpu.requestAdapter({\n            powerPreference: 'high-performance'\n            // powerPreference: 'low-power'\n        })\n        if (!adapter) { throw new Error('No Adapter Found'); }\n\n        const device = await adapter.requestDevice()\n        this.ctx = this.renderer.canvas.getContext('webgpu') as GPUCanvasContext\n        // this.format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\n        this.format = \"bgra8unorm\";\n\n        this.ctx.configure({\n            device: device, \n            format: this.format,\n            // prevent chrome warning\n            alphaMode: 'opaque'\n        });\n\n        // this.size = { width: this.canvas.width, height: this.canvas.height }\n        this.device = device;\n\n        this.textureView = this.ctx.getCurrentTexture().createView();\n        this.depthTexture = this.device.createTexture({\n            size: [this.ctx.canvas.width, this.ctx.canvas.height, 1],\n            format: \"depth24plus\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        // this.renderPassDescription = {\n        //     colorAttachments: [{\n        //         view: this.textureView,\n        //         clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, //background color\n        //         loadOp: 'clear',\n        //         storeOp: 'store',\n        //         //@ts-ignore\n        //         loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        //     }],\n        //     depthStencilAttachment: {\n        //         view: this.depthTexture.createView(),\n        //         depthClearValue: 1.0,\n        //         depthLoadOp: 'clear',\n        //         depthStoreOp: \"store\",\n        //     }\n        // };\n        this.renderPassDescription = {\n            // @ts-ignore\n            colorAttachments: [{\n                view: this.textureView,\n                clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, //background color\n                loadOp: 'clear',\n                storeOp: 'store'\n            }],\n            depthStencilAttachment: {\n                view: this.depthTexture.createView(),\n                depthClearValue: 1.0,\n                depthLoadOp: 'clear',\n                depthStoreOp: \"store\",\n                //stencilLoadValue: 0,\n                //stencilStoreOp: \"store\"\n            }\n        }\n    }\n    public destroy() {\n        this.device.destroy();\n    }\n}\n\n","import { App } from '..';\nimport { CameraController } from './Camera/CameraController';\nimport { WebGPU } from './WebGPU';\n\nexport class Renderer {\n    public app: App;\n    public canvas: HTMLCanvasElement;\n\n    public cameraController: CameraController;\n    public webGPU: WebGPU;\n\n    public isAnimation: boolean = true;\n    private requestAni: any;\n\n    constructor(app: App) {\n        this.app = app;\n\n        this.canvas = document.createElement('canvas');\n        // this.canvas.style.width = '100px';\n        // this.canvas.style.height = '100px';\n        this.canvas.width = this.app.divHost.clientWidth;\n        this.canvas.height = this.app.divHost.clientHeight;\n        this.app.divHost.appendChild(this.canvas);\n        \n        // window.addEventListener('resize', (ev: UIEvent) => {\n        //     console.log(ev)\n        //     this.canvas.width = this.app.divHost.clientWidth;\n        //     this.canvas.height = this.app.divHost.clientHeight;\n        //     // this.canvas.width = e\n        // });\n\n        this.webGPU = new WebGPU(this);\n    }\n    async init() {\n        await this.webGPU.initWebGPU();\n\n        this.cameraController = new CameraController(this);\n        this.requestAni = requestAnimationFrame(this.loop);\n    }\n\n    public loop = () => {\n        if (this.isAnimation) {\n            this.requestAni = requestAnimationFrame(this.loop);\n        }\n        // this.cameraController.update();\n        this.drawing();\n    }\n    public drawing() {\n        this.app.scene.render();\n    }\n    public destroy() {\n        this.webGPU.destroy();\n        // this.isAnimation = false;\n        cancelAnimationFrame(this.requestAni);\n        // this.requestAni = undefined;\n        while (this.app.divHost.lastElementChild) {\n            this.app.divHost.removeChild(this.app.divHost.lastElementChild);\n        }\n    }\n}\n\n","import { getJSONFromURL, MercatorProjection } from 'njscore';\n\nexport class Geometry {\n    streetOSM: any = [];\n\n    pos: any;\n    colors: any;\n\n    constructor() {\n\n    }\n    async init() {\n        await getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\n            for (let i = 0; i < data['features'].length; ++i) {\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\n            }\n            this.renderLines(this.streetOSM, [0, 1, 1]);\n        });\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    }\n    renderLines = (paths: any, color: number[]) => {\n\n        const positions = [];\n        const colors = [];\n        const indices = [];\n\n        const xOFf =  15478749.591872748 // 48.85635555014451; -15478803.88731685; 15478749.591872748 4766690.415614613 // 15478749.591872748 4766690.415614613\n        const yOFf =  4766690.415614613 // -4766681.448690384;\n        const scale = 0.0001;\n\n\n        let xC = 0\n        let yC = 0\n        let Count = 0\n\n        for (let i = 0; i < paths.length; ++i) {\n            const route = paths[i]\n\n            for (let j = 0; j < route.length; ++j) {\n                for (let k = 0; k < route[j].length - 1; ++k) {\n\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\n                    // xC += xPro;\n                    // yC += yPro;\n\n                    const [xPro1, yPro1] = MercatorProjection(route[j][k+1][0], route[j][k+1][1]);\n                    // const xPro = route[j][k][0];\n                    // const yPro = route[j][k][1];\n\n                    // const xPro1 = route[j][k+1][0];\n                    // const yPro1 = route[j][k+1][1];\n\n                    xC += xPro;\n                    yC += yPro;\n\n                    Count += 1;\n\n                    const x = (xPro - xOFf) * scale\n                    const y = (yPro - yOFf) * scale\n\n                    const x1 = (xPro1 - xOFf) * scale\n                    const y1 = (yPro1 - yOFf) * scale\n\n                    // console.log(x, y)\n                    positions.push(x, y, 0)\n\n                    colors.push(color[0], color[1],  color[2]);\n\n                    // if (k !== 0) {\n                        positions.push(x1, y1, 0)\n                        // positions.push(x, y, Math.random() * 0.01)\n                        colors.push(color[0], color[1],  color[2]);\n                    // }\n\n                    if (k < route[j].length - 1) {\n                        indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\n                    }\n                }\n\n                // positions.push(positions[positions.length-3], positions[positions.length-2], positions[positions.length-1])\n                // colors.push(color[0], color[1],  color[2]);\n\n                // positions.push(0, 0, 0)\n                // colors.push(0,0,0);\n            }\n        }\n\n        console.log(positions)\n        console.log(xC / Count, yC / Count )\n        // geometry.setIndex(indices);\n        // geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        // geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n        // // generateMorphTargets( geometry );\n\n        // geometry.computeBoundingSphere();\n\n        // const line = new THREE.LineSegments(geometry, material);\n        // scene.add(line);\n\n        this.pos = new Float32Array(positions.flat());\n        this.colors = new Float32Array(colors.flat());\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    };\n}","import { Scene } from '../../Scene';\nimport { WebGPU } from '../../Renderer/WebGPU';\nexport class ObjectBase {\n    public scene: Scene;\n    public webGPU: WebGPU;\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.webGPU = scene.app.renderer.webGPU;\n        this.scene.objects.push(this);\n\n    }\n    public async initPipeline() {\n\n    }\n    public update() {\n\n    }\n    public render() {\n\n    }\n}","// import { InitGPU, CreateGPUBuffer, CreateGPUBufferUint, CreateTransforms, CreateViewProjection, CreateAnimation } from './helper';\n// import { Shaders } from './shaders';\n// import { vec3, mat4 } from 'gl-matrix';\n// const createCamera = require('3d-view-controls');\n\n\nimport { vec3, mat4 } from 'gl-matrix';\nimport { createTransforms, createGPUBuffer, loadWGSL } from '../../lib';\n\nimport { Geometry } from './Geometry';\n\nimport { Scene } from '../../Scene';\nimport { ObjectBase } from '../Base';\n\nconst shaderPath = require('./shader.wgsl');\n\nexport class NGeojsonPoint extends ObjectBase {\n    isRenderable= false;\n\n    numberOfVertices: number = 0;\n    vertexBuffer;\n    colorBuffer;\n    normalBuffer;\n    uvBuffer;\n    uniformBindGroup;\n    uniformBindGroup1;\n    uniformBindGroup2;\n    uniformBuffer;\n\n    commandEncoder;\n\n    textureView;\n    renderPassDescription;\n    pipeline: GPURenderPipeline;\n\n    isAnimation = false;\n\n    modelMatrix: mat4;\n    translation: vec3 = vec3.fromValues(0,0,0);\n    rotation: vec3 = vec3.fromValues(0,0,0);\n\n    mouseBuffer;\n    frameBuffer;\n\n    t: number = 0;\n\n    resultBuffer;\n\n    geometry: Geometry;\n\n    constructor(scene: Scene) {\n        super(scene)\n\n        this.initPipeline();\n\n    }\n    async initPipeline () {\n        this.geometry = new Geometry();\n        await this.geometry.init();\n        console.log(this.geometry)\n\n        // create vertex buffers\n        // const sphereData = SphereData(1.5, 70, 40);\n\n        // console.log(sphereData);\n\n        this.numberOfVertices = (this.geometry.pos!).length/3;\n        // console.log(this.numberOfVertices);\n        this.vertexBuffer = createGPUBuffer(this.webGPU.device, this.geometry.pos);   \n        this.colorBuffer = createGPUBuffer(this.webGPU.device, this.geometry.colors);\n        // this.normalBuffer = createGPUBuffer(this.webGPU.device, this.pos?.normalData!);\n\n\n\n        \n        // const bindGroupLayout = this.webGPU.device.createBindGroupLayout({\n        //     entries: [\n        //       {\n        //         binding: 0,\n        //         visibility: GPUShaderStage.VERTEX,\n        //         type: \"uniform-buffer\",\n        //       },\n        //     ],\n        //   });\n\n        //   const bindGroupLayout = this.webGPU.device.createBindGroupLayout({\n        //     entries: [\n        //       {\n        //         binding: 0,\n        //         visibility: GPUShaderStage.VERTEX,\n        //         buffer: {\n        //           type: \"uniform\",\n        //         },\n        //       },\n        //     ],\n        //   });\n\n\n        // const mouseBuffer = device.createBuffer({\n        //     size: 8,\n        //     usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        //   });\n\n        // this.mouseBuffer = createGPUBuffer(this.webGPU.device, this.scene.app.controller.eventController.mNormalized);\n\n        // this.numberOfVertices = (sphereData?.vertexData!).length/3;\n        // this.vertexBuffer = createGPUBuffer(this.webGPU.device, sphereData?.vertexData!);   \n        // this.normalBuffer = createGPUBuffer(this.webGPU.device, sphereData?.normalData!);\n        // this.uvBuffer = createGPUBuffer(this.webGPU.device, sphereData?.uvData!);\n        const shader = (await loadWGSL(shaderPath)) as string;\n        // console.log(shader)\n        this.pipeline = this.webGPU.device.createRenderPipeline({\n            layout: 'auto',\n            vertex: {\n                module: this.webGPU.device.createShaderModule({ code: shader }),\n                entryPoint: \"vs_main\",\n                // @ts-ignore\n                buffers: [\n                    {\n                        arrayStride: 4 * 3,\n                        attributes: [{\n                            shaderLocation: 0,\n                            format: \"float32x3\",\n                            offset: 0\n                        }]\n                    },\n                    {\n                        arrayStride: 4 * 3,\n                        attributes: [{\n                            shaderLocation: 1,\n                            format: \"float32x3\",\n                            offset: 0\n                        }]\n                    }, \n\n                ]\n            },\n            fragment: {\n                module: this.webGPU.device.createShaderModule({ code: shader }),\n                entryPoint: \"fs_main\",\n                targets: [\n                    {\n                        format: this.webGPU.format as GPUTextureFormat\n                    }\n                ]\n            },\n            primitive: {\n                // https://learn.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-primitive-topologies\n                topology: this.webGPU.PrimitiveTopology.PointList // TriangleStrip // .PointList, //  \"line-strip\", //\"line-list\",\n            },\n            depthStencil: {\n                format: \"depth24plus\",\n                depthWriteEnabled: true,\n                depthCompare: \"less\"\n            }\n        });\n\n        // // create uniform data\n        this.modelMatrix = mat4.create();\n        // const mvpMatrix = mat4.create();\n        // let vMatrix = mat4.create();\n        // let vpMatrix = mat4.create();\n        // const vp = CreateViewProjection(gpu.canvas.width / gpu.canvas.height);\n        // vpMatrix = vp.viewProjectionMatrix;\n\n        // add rotation and camera:\n        this.rotation = vec3.fromValues(0, 0, 0);\n        // var camera = createCamera(gpu.canvas, vp.cameraOption);\n\n        // create uniform buffer and layout\n        this.uniformBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n        this.mouseBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.frameBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        // const bindGroup = device.createBindGroup({\n        //     layout: bindGroupLayout,\n        //     entries: [\n        //       {\n        //         binding: 0,\n        //         resource: {\n        //           buffer: mouseBuffer,\n        //         },\n        //       },\n        //     ],\n        //   });\n\n\n        this.uniformBindGroup = this.webGPU.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: this.uniformBuffer,\n                    offset: 0,\n                    size: 64\n                }\n            },\n            // {\n            //     binding: 1,\n            //     resource: { buffer: this.resultBuffer },\n            //   },\n            // {\n            //     binding: 1,\n            //     resource: {\n            //       buffer: this.mouseBuffer,\n            //     },\n            // },\n            ]\n        });\n\n\n        // var bindGroupLayout = this.webGPU.device.createBindGroupLayout({\n        //     entries: [\n        //         {binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {type: \"uniform\"}}]\n        // });\n\n\n        this.uniformBindGroup1 = this.webGPU.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(1), // bindGroupLayout,\n            entries: [\n              {\n                binding: 0,\n                resource: {\n                  buffer: this.mouseBuffer,\n                },\n              },\n              \n            //   {\n            //     binding: 1,\n            //     resource: {\n            //       buffer: this.frameBuffer,\n            //     },\n            //   },\n            ],\n        });\n\n        // this.uniformBindGroup2 = this.webGPU.device.createBindGroup({\n        //     layout: this.pipeline.getBindGroupLayout(3), // bindGroupLayout,\n        //     entries: [\n        //       {\n        //         binding: 0,\n        //         resource: {\n        //           buffer: this.frameBuffer,\n        //         },\n        //       },\n        //     ],\n        // });\n\n\n        this.textureView = this.webGPU.ctx.getCurrentTexture().createView();\n        const depthTexture = this.webGPU.device.createTexture({\n            size: [this.webGPU.ctx.canvas.width, this.webGPU.ctx.canvas.height, 1],\n            format: \"depth24plus\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.renderPassDescription = {\n            colorAttachments: [{\n                view: this.textureView,\n                clearValue: { r: 0.2, g: 0.247, b: 0.314, a: 1.0 }, //background color\n                loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                loadOp: 'clear',\n                storeOp: 'store'\n            }],\n            depthStencilAttachment: {\n                view: depthTexture.createView(),\n                depthClearValue: 1.0,\n                depthLoadOp: 'clear',\n                depthStoreOp: \"store\",\n                //stencilLoadValue: 0,\n                //stencilStoreOp: \"store\"\n            }\n        };\n\n        // const sceneBuffer = this.webGPU.device.createBuffer({\n        //     size: sceneData.byteLength,\n        //     usage: GPUBufferUsage.STORAGE,\n        //     mappedAtCreation: true,\n        //   });\n        //   new Float32Array(sceneBuffer.getMappedRange()).set(sceneData);\n        //   sceneBuffer.unmap();\n\n        // this.resultBuffer = this.webGPU.device.createBuffer({\n        //     size: 4, // Assuming 32-bit unsigned integer for object IDs.\n        //     usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        //   });\n\n        this.isRenderable = true;\n    }\n    async render() {\n        if (!this.isRenderable) { return; }\n\n        // const commandEncoder = device.createCommandEncoder()\n        // const computePass = commandEncoder.beginComputePass()\n        // computePass.setPipeline(pipelineObj.computePipeline)\n        // computePass.setBindGroup(0, pipelineObj.computeGroup)\n        // computePass.dispatchWorkgroups(Math.ceil(NUM / 128))\n        // computePass.end()\n\n\n        // this.translation[0] += 0.005;\n        // this.rotation[1] += 0.005;\n\n        // console.log(this.translation)\n        // console.log(this.rotation)\n        // console.log(this.modelMatrix)\n\n        this.webGPU.device.queue.writeBuffer(this.mouseBuffer, 0, new Float32Array([this.scene.app.controller.eventController.mNormalized[0], this.scene.app.controller.eventController.mNormalized[1], this.t]));\n        \n        this.webGPU.device.queue.writeBuffer(this.frameBuffer, 0, new Float32Array([this.t, 0]));\n\n        // const mouseData = new Float32Array([mouseX, mouseY]);\n        // device.queue.writeBuffer(mouseBuffer, 0, mouseData);\n\n        // console.log(this.scene.app.controller.eventController.mNormalized)\n\n        // updateMouseBuffer(this.mouseBuffer, this.scene.app.controller.eventController.mNormalized[0], this.scene.app.controller.eventController.mNormalized[1])\n\n\n        if (false) {\n            this.geometry.pos[2] = Math.sin(this.t);\n            this.webGPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.geometry.pos )\n        }\n\n\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n        mat4.multiply(this.modelMatrix, this.webGPU.renderer.cameraController.getMatrix, this.modelMatrix);\n        this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.modelMatrix as ArrayBuffer);\n        \n        // this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.webGPU.renderer.cameraController.camera.projectionMatrix as ArrayBuffer);\n        // this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.webGPU.renderer.camera.mvpMatrix as ArrayBuffer);\n\n\n        // contextTexture.destroy();\n        // texture.destroy();\n        \n        // contextTexture = gpu.context.getCurrentTexture();      \n        // texture = device.createTexture({\n        //     size: [gpu.canvas.width, gpu.canvas.height, 1],\n        //     sampleCount: 4,\n        //     format: gpu.format as GPUTextureFormat,\n        //     usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        // });\n        // renderPassDescription.colorAttachments[0].resolveTarget = contextTexture.createView();\n        // renderPassDescription.colorAttachments[0].view = texture.createView() as GPUTextureView;\n\n        // const commandEncoder = this.webGPU.device.createCommandEncoder();\n        // // const renderPass = commandEncoder.beginRenderPass(renderPassDescription as GPURenderPassDescriptor);\n        // this.textureView = this.webGPU.ctx.getCurrentTexture().createView();\n        // this.renderPassDescription.colorAttachments[0].view = this.textureView;\n        // const renderPass = commandEncoder.beginRenderPass(this.renderPassDescription as GPURenderPassDescriptor);\n\n        this.webGPU.renderPass.setPipeline(this.pipeline);\n        this.webGPU.renderPass.setVertexBuffer(0, this.vertexBuffer);\n        this.webGPU.renderPass.setVertexBuffer(1, this.colorBuffer);\n\n        this.webGPU.renderPass.setBindGroup(0, this.uniformBindGroup);\n        this.webGPU.renderPass.setBindGroup(1, this.uniformBindGroup1);\n        // this.webGPU.renderPass.setBindGroup(2, this.uniformBindGroup2);\n\n        this.webGPU.renderPass.draw(this.numberOfVertices);\n\n        this.t += 0.01;\n\n        // const resultBufferArrayBuffer = await this.resultBuffer.mapReadAsync();\n        // const pickedObjectID = new Uint32Array(resultBufferArrayBuffer)[0];\n        // console.log(pickedObjectID)\n        // this.webGPU.renderPass.end();\n        // this.webGPU.device.queue.submit([this.commandEncoder.finish()]);\n    }\n}\n\nfunction updateMouseBuffer(mouseBuffer, x, y) {\n    const data = new Float32Array([x, y]);\n    const bufferMapped = mouseBuffer.getMappedRange();\n    new Float32Array(bufferMapped).set(data);\n    mouseBuffer.unmap();\n  }","import { getJSONFromURL, MercatorProjection } from 'njscore';\n\nexport class Geometry {\n    streetOSM: any = [];\n\n    pos: any;\n    colors: any;\n\n    constructor() {\n\n    }\n    async init() {\n        await getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\n            for (let i = 0; i < data['features'].length; ++i) {\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\n            }\n            this.renderLines(this.streetOSM, [0, 1, 1]);\n        });\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    }\n    renderLines = (paths: any, color: number[]) => {\n\n        const positions = [];\n        const colors = [];\n        const indices = [];\n\n        const xOFf =  15478749.591872748 // 48.85635555014451; -15478803.88731685; 15478749.591872748 4766690.415614613 // 15478749.591872748 4766690.415614613\n        const yOFf =  4766690.415614613 // -4766681.448690384;\n        const scale = 0.0001;\n\n\n        let xC = 0\n        let yC = 0\n        let Count = 0\n\n        for (let i = 0; i < paths.length; ++i) {\n            const route = paths[i]\n\n            for (let j = 0; j < route.length; ++j) {\n                for (let k = 0; k < route[j].length - 1; ++k) {\n\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\n                    // xC += xPro;\n                    // yC += yPro;\n\n                    const [xPro1, yPro1] = MercatorProjection(route[j][k+1][0], route[j][k+1][1]);\n                    // const xPro = route[j][k][0];\n                    // const yPro = route[j][k][1];\n\n                    // const xPro1 = route[j][k+1][0];\n                    // const yPro1 = route[j][k+1][1];\n\n                    xC += xPro;\n                    yC += yPro;\n\n                    Count += 1;\n\n                    const x = (xPro - xOFf) * scale\n                    const y = (yPro - yOFf) * scale\n\n                    const x1 = (xPro1 - xOFf) * scale\n                    const y1 = (yPro1 - yOFf) * scale\n\n                    // console.log(x, y)\n                    positions.push(x, y, 0)\n\n                    colors.push(color[0], color[1],  color[2]);\n\n                    // if (k !== 0) {\n                        positions.push(x1, y1, 0)\n                        // positions.push(x, y, Math.random() * 0.01)\n                        colors.push(color[0], color[1],  color[2]);\n                    // }\n\n                    if (k < route[j].length - 1) {\n                        indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\n                    }\n                }\n\n                // positions.push(positions[positions.length-3], positions[positions.length-2], positions[positions.length-1])\n                // colors.push(color[0], color[1],  color[2]);\n\n                // positions.push(0, 0, 0)\n                // colors.push(0,0,0);\n            }\n        }\n\n        console.log(positions)\n        console.log(xC / Count, yC / Count )\n        // geometry.setIndex(indices);\n        // geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        // geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n        // // generateMorphTargets( geometry );\n\n        // geometry.computeBoundingSphere();\n\n        // const line = new THREE.LineSegments(geometry, material);\n        // scene.add(line);\n\n        this.pos = new Float32Array(positions.flat());\n        this.colors = new Float32Array(colors.flat());\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    };\n}","// import { InitGPU, CreateGPUBuffer, CreateGPUBufferUint, CreateTransforms, CreateViewProjection, CreateAnimation } from './helper';\n// import { Shaders } from './shaders';\n// import { vec3, mat4 } from 'gl-matrix';\n// const createCamera = require('3d-view-controls');\n\n\nimport { vec3, mat4 } from 'gl-matrix';\nimport { createTransforms, createGPUBuffer, loadWGSL } from '../../lib';\n\nimport { Geometry } from './Geometry';\n\nimport { Scene } from '../../Scene';\nimport { ObjectBase } from '../Base';\n\nconst shaderPath = require('./shader.wgsl');\n\nexport class NGeojsonLine extends ObjectBase {\n    isRenderable= false;\n\n    numberOfVertices: number = 0;\n    vertexBuffer;\n    colorBuffer;\n    normalBuffer;\n    uvBuffer;\n    uniformBindGroup;\n    uniformBindGroup1;\n    uniformBindGroup2;\n    uniformBuffer;\n\n    commandEncoder;\n\n    textureView;\n    renderPassDescription;\n    pipeline: GPURenderPipeline;\n\n    isAnimation = false;\n\n    modelMatrix: mat4;\n    translation: vec3 = vec3.fromValues(0,0,0);\n    rotation: vec3 = vec3.fromValues(0,0,0);\n\n    mouseBuffer;\n    frameBuffer;\n\n    t: number = 0;\n\n    resultBuffer;\n\n    geometry: Geometry;\n\n    constructor(scene: Scene) {\n        super(scene)\n\n        this.initPipeline();\n\n    }\n    async initPipeline () {\n        this.geometry = new Geometry();\n        await this.geometry.init();\n        console.log(this.geometry)\n\n        // create vertex buffers\n        // const sphereData = SphereData(1.5, 70, 40);\n\n        // console.log(sphereData);\n\n        this.numberOfVertices = (this.geometry.pos!).length/3;\n        // console.log(this.numberOfVertices);\n        this.vertexBuffer = createGPUBuffer(this.webGPU.device, this.geometry.pos);   \n        this.colorBuffer = createGPUBuffer(this.webGPU.device, this.geometry.colors);\n        // this.normalBuffer = createGPUBuffer(this.webGPU.device, this.pos?.normalData!);\n\n\n\n        \n        // const bindGroupLayout = this.webGPU.device.createBindGroupLayout({\n        //     entries: [\n        //       {\n        //         binding: 0,\n        //         visibility: GPUShaderStage.VERTEX,\n        //         type: \"uniform-buffer\",\n        //       },\n        //     ],\n        //   });\n\n        //   const bindGroupLayout = this.webGPU.device.createBindGroupLayout({\n        //     entries: [\n        //       {\n        //         binding: 0,\n        //         visibility: GPUShaderStage.VERTEX,\n        //         buffer: {\n        //           type: \"uniform\",\n        //         },\n        //       },\n        //     ],\n        //   });\n\n\n        // const mouseBuffer = device.createBuffer({\n        //     size: 8,\n        //     usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        //   });\n\n        // this.mouseBuffer = createGPUBuffer(this.webGPU.device, this.scene.app.controller.eventController.mNormalized);\n\n        // this.numberOfVertices = (sphereData?.vertexData!).length/3;\n        // this.vertexBuffer = createGPUBuffer(this.webGPU.device, sphereData?.vertexData!);   \n        // this.normalBuffer = createGPUBuffer(this.webGPU.device, sphereData?.normalData!);\n        // this.uvBuffer = createGPUBuffer(this.webGPU.device, sphereData?.uvData!);\n        const shader = (await loadWGSL(shaderPath)) as string;\n        // console.log(shader)\n        this.pipeline = this.webGPU.device.createRenderPipeline({\n            layout: 'auto',\n            vertex: {\n                module: this.webGPU.device.createShaderModule({ code: shader }),\n                entryPoint: \"vs_main\",\n                // @ts-ignore\n                buffers: [\n                    {\n                        arrayStride: 4 * 3,\n                        attributes: [{\n                            shaderLocation: 0,\n                            format: \"float32x3\",\n                            offset: 0\n                        }]\n                    },\n                    {\n                        arrayStride: 4 * 3,\n                        attributes: [{\n                            shaderLocation: 1,\n                            format: \"float32x3\",\n                            offset: 0\n                        }]\n                    }, \n\n                ]\n            },\n            fragment: {\n                module: this.webGPU.device.createShaderModule({ code: shader }),\n                entryPoint: \"fs_main\",\n                targets: [\n                    {\n                        format: this.webGPU.format as GPUTextureFormat\n                    }\n                ]\n            },\n            primitive: {\n                // https://learn.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-primitive-topologies\n                topology: this.webGPU.PrimitiveTopology.LineList // TriangleStrip // .PointList, //  \"line-strip\", //\"line-list\",\n            },\n            depthStencil: {\n                format: \"depth24plus\",\n                depthWriteEnabled: true,\n                depthCompare: \"less\"\n            }\n        });\n\n        // // create uniform data\n        this.modelMatrix = mat4.create();\n        // const mvpMatrix = mat4.create();\n        // let vMatrix = mat4.create();\n        // let vpMatrix = mat4.create();\n        // const vp = CreateViewProjection(gpu.canvas.width / gpu.canvas.height);\n        // vpMatrix = vp.viewProjectionMatrix;\n\n        // add rotation and camera:\n        this.rotation = vec3.fromValues(0, 0, 0);\n        // var camera = createCamera(gpu.canvas, vp.cameraOption);\n\n        // create uniform buffer and layout\n        this.uniformBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n        this.mouseBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.frameBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.uniformBindGroup = this.webGPU.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: this.uniformBuffer,\n                    offset: 0,\n                    size: 64\n                }\n            },\n\n            ]\n        });\n\n\n        // var bindGroupLayout = this.webGPU.device.createBindGroupLayout({\n        //     entries: [\n        //         {binding: 0, visibility: GPUShaderStage.VERTEX, buffer: {type: \"uniform\"}}]\n        // });\n\n\n        this.uniformBindGroup1 = this.webGPU.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(1), // bindGroupLayout,\n            entries: [\n              {\n                binding: 0,\n                resource: {\n                  buffer: this.mouseBuffer,\n                },\n              },\n              \n            ],\n        });\n\n\n        this.textureView = this.webGPU.ctx.getCurrentTexture().createView();\n        const depthTexture = this.webGPU.device.createTexture({\n            size: [this.webGPU.ctx.canvas.width, this.webGPU.ctx.canvas.height, 1],\n            format: \"depth24plus\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.renderPassDescription = {\n            colorAttachments: [{\n                view: this.textureView,\n                clearValue: { r: 0.2, g: 0.247, b: 0.314, a: 1.0 }, //background color\n                loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                loadOp: 'clear',\n                storeOp: 'store'\n            }],\n            depthStencilAttachment: {\n                view: depthTexture.createView(),\n                depthClearValue: 1.0,\n                depthLoadOp: 'clear',\n                depthStoreOp: \"store\",\n                //stencilLoadValue: 0,\n                //stencilStoreOp: \"store\"\n            }\n        };\n\n\n        this.isRenderable = true;\n    }\n    async render() {\n        if (!this.isRenderable) { return; }\n\n        // const commandEncoder = device.createCommandEncoder()\n        // const computePass = commandEncoder.beginComputePass()\n        // computePass.setPipeline(pipelineObj.computePipeline)\n        // computePass.setBindGroup(0, pipelineObj.computeGroup)\n        // computePass.dispatchWorkgroups(Math.ceil(NUM / 128))\n        // computePass.end()\n\n\n        // this.translation[0] += 0.005;\n        // this.rotation[1] += 0.005;\n\n        // console.log(this.translation)\n        // console.log(this.rotation)\n        // console.log(this.modelMatrix)\n\n        this.webGPU.device.queue.writeBuffer(this.mouseBuffer, 0, new Float32Array([this.scene.app.controller.eventController.mNormalized[0], this.scene.app.controller.eventController.mNormalized[1], this.t]));\n        \n        this.webGPU.device.queue.writeBuffer(this.frameBuffer, 0, new Float32Array([this.t, 0]));\n\n        // const mouseData = new Float32Array([mouseX, mouseY]);\n        // device.queue.writeBuffer(mouseBuffer, 0, mouseData);\n\n        // console.log(this.scene.app.controller.eventController.mNormalized)\n\n        // updateMouseBuffer(this.mouseBuffer, this.scene.app.controller.eventController.mNormalized[0], this.scene.app.controller.eventController.mNormalized[1])\n\n\n        if (false) {\n            this.geometry.pos[2] = Math.sin(this.t);\n            this.webGPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.geometry.pos )\n        }\n\n\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n        mat4.multiply(this.modelMatrix, this.webGPU.renderer.cameraController.getMatrix, this.modelMatrix);\n        this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.modelMatrix as ArrayBuffer);\n        \n        // this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.webGPU.renderer.cameraController.camera.projectionMatrix as ArrayBuffer);\n        // this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.webGPU.renderer.camera.mvpMatrix as ArrayBuffer);\n\n\n        // contextTexture.destroy();\n        // texture.destroy();\n        \n        // contextTexture = gpu.context.getCurrentTexture();      \n        // texture = device.createTexture({\n        //     size: [gpu.canvas.width, gpu.canvas.height, 1],\n        //     sampleCount: 4,\n        //     format: gpu.format as GPUTextureFormat,\n        //     usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        // });\n        // renderPassDescription.colorAttachments[0].resolveTarget = contextTexture.createView();\n        // renderPassDescription.colorAttachments[0].view = texture.createView() as GPUTextureView;\n\n        // const commandEncoder = this.webGPU.device.createCommandEncoder();\n        // // const renderPass = commandEncoder.beginRenderPass(renderPassDescription as GPURenderPassDescriptor);\n        // this.textureView = this.webGPU.ctx.getCurrentTexture().createView();\n        // this.renderPassDescription.colorAttachments[0].view = this.textureView;\n        // const renderPass = commandEncoder.beginRenderPass(this.renderPassDescription as GPURenderPassDescriptor);\n\n        this.webGPU.renderPass.setPipeline(this.pipeline);\n        this.webGPU.renderPass.setVertexBuffer(0, this.vertexBuffer);\n        this.webGPU.renderPass.setVertexBuffer(1, this.colorBuffer);\n\n        this.webGPU.renderPass.setBindGroup(0, this.uniformBindGroup);\n        this.webGPU.renderPass.setBindGroup(1, this.uniformBindGroup1);\n        // this.webGPU.renderPass.setBindGroup(2, this.uniformBindGroup2);\n\n        this.webGPU.renderPass.draw(this.numberOfVertices);\n\n        this.t += 0.01;\n\n        // const resultBufferArrayBuffer = await this.resultBuffer.mapReadAsync();\n        // const pickedObjectID = new Uint32Array(resultBufferArrayBuffer)[0];\n        // console.log(pickedObjectID)\n        // this.webGPU.renderPass.end();\n        // this.webGPU.device.queue.submit([this.commandEncoder.finish()]);\n    }\n}\n","// import { InitGPU, CreateGPUBuffer, CreateGPUBufferUint, CreateTransforms, CreateViewProjection, CreateAnimation } from './helper';\n// import { Shaders } from './shaders';\n// import { vec3, mat4 } from 'gl-matrix';\n// const createCamera = require('3d-view-controls');\nimport { vec3, mat4 } from 'gl-matrix';\nimport { createTransforms, createGPUBuffer } from '../../lib';\n\nimport { Scene } from '../../Scene';\nimport { ObjectBase } from '../Base';\n\n\nexport class NSphereWire extends ObjectBase {\n\n    numberOfVertices: number = 0;\n    vertexBuffer;\n    normalBuffer;\n    uvBuffer;\n    uniformBindGroup;\n    uniformBuffer;\n\n    commandEncoder;\n\n    textureView;\n    renderPassDescription;\n    pipeline\n\n    isAnimation = true;\n\n    modelMatrix: mat4;\n    translation: vec3 = vec3.fromValues(0,0,0);\n    rotation: vec3 = vec3.fromValues(0, 0, 0);\n\n    pos;\n    t = 0.0;\n\n    constructor(scene: Scene) {\n        super(scene)\n\n        this.initPipeline();\n    }\n    async initPipeline () {\n        // create vertex buffers\n        const sphereData = SphereData(1.5, 70, 40);\n\n        this.pos = sphereData?.vertexData;\n\n        this.numberOfVertices = (sphereData?.vertexData!).length/3;\n        this.vertexBuffer = createGPUBuffer(this.webGPU.device, sphereData?.vertexData!);   \n        this.normalBuffer = createGPUBuffer(this.webGPU.device, sphereData?.normalData!);\n        this.uvBuffer = createGPUBuffer(this.webGPU.device, sphereData?.uvData!);\n\n        const shader = Shaders();\n        this.pipeline = this.webGPU.device.createRenderPipeline({\n            layout: 'auto',\n            vertex: {\n                module: this.webGPU.device.createShaderModule({\n                    code: shader.vertex\n                }),\n                entryPoint: \"main\",\n                // @ts-ignore\n                buffers: [\n                    {\n                        arrayStride: 12,\n                        attributes: [{\n                            shaderLocation: 0,\n                            format: \"float32x3\",\n                            offset: 0\n                        }]\n                    }\n                ]\n            },\n            fragment: {\n                module: this.webGPU.device.createShaderModule({\n                    code: shader.fragment\n                }),\n                entryPoint: \"main\",\n                targets: [\n                    {\n                        format: this.webGPU.format as GPUTextureFormat\n                    }\n                ]\n            },\n            primitive: {\n                topology: this.webGPU.PrimitiveTopology.PointList // .PointList, //  \"line-strip\", //\"line-list\",\n            },\n            depthStencil: {\n                format: \"depth24plus\",\n                depthWriteEnabled: true,\n                depthCompare: \"less\"\n            }\n        });\n\n        // // create uniform data\n        this.modelMatrix = mat4.create();\n        // const mvpMatrix = mat4.create();\n        // let vMatrix = mat4.create();\n        // let vpMatrix = mat4.create();\n        // const vp = CreateViewProjection(gpu.canvas.width / gpu.canvas.height);\n        // vpMatrix = vp.viewProjectionMatrix;\n\n        // add rotation and camera:\n        this.rotation = vec3.fromValues(Math.PI * 0.15, 0, 0);\n        // var camera = createCamera(gpu.canvas, vp.cameraOption);\n\n        // create uniform buffer and layout\n        this.uniformBuffer = this.webGPU.device.createBuffer({\n            size: 64,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n        });\n\n        this.uniformBindGroup = this.webGPU.device.createBindGroup({\n            layout: this.pipeline.getBindGroupLayout(0),\n            entries: [{\n                binding: 0,\n                resource: {\n                    buffer: this.uniformBuffer,\n                    offset: 0,\n                    size: 64\n                }\n            }]\n        });\n\n        this.textureView = this.webGPU.ctx.getCurrentTexture().createView();\n        const depthTexture = this.webGPU.device.createTexture({\n            size: [this.webGPU.ctx.canvas.width, this.webGPU.ctx.canvas.height, 1],\n            format: \"depth24plus\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.renderPassDescription = {\n            colorAttachments: [{\n                view: this.textureView,\n                clearValue: { r: 0.2, g: 0.247, b: 0.314, a: 1.0 }, //background color\n                loadOp: 'clear',\n                storeOp: 'store'\n            }],\n            depthStencilAttachment: {\n                view: depthTexture.createView(),\n                depthClearValue: 1.0,\n                depthLoadOp: 'clear',\n                depthStoreOp: \"store\",\n                //stencilLoadValue: 0,\n                //stencilStoreOp: \"store\"\n            }\n        };\n\n    }\n    render() {\n        if (!this.isAnimation) {\n            // if (camera.tick()) {\n                // const pMatrix = vp.projectionMatrix;\n                // vMatrix = camera.matrix;\n                // mat4.multiply(vpMatrix, pMatrix, vMatrix);\n            // }\n        }\n\n        //         const commandEncoder = device.createCommandEncoder()\n        // const computePass = commandEncoder.beginComputePass()\n        // computePass.setPipeline(pipelineObj.computePipeline)\n        // computePass.setBindGroup(0, pipelineObj.computeGroup)\n        // computePass.dispatchWorkgroups(Math.ceil(NUM / 128))\n        // computePass.end()\n\n\n        if (false) {\n\n            for (let i = 0 ; i < this.pos.length; i+=3) {\n                // console.log(this.pos[i])\n                this.pos[i] = Math.sin(this.t * i * 0.00001);\n            }\n            // this.pos[2] = Math.sin(this.t);\n            this.webGPU.device.queue.writeBuffer(this.vertexBuffer, 0, this.pos )\n        }\n\n\n\n        // this.translation[0] += 0.005;\n        this.rotation[1] += 0.005;\n\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n\n        mat4.multiply(this.modelMatrix, this.webGPU.renderer.cameraController.getMatrix, this.modelMatrix);\n        this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.modelMatrix as ArrayBuffer);\n        \n        // this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.webGPU.renderer.camera.mvpMatrix as ArrayBuffer);\n\n\n        // contextTexture.destroy();\n        // texture.destroy();\n        \n        // contextTexture = gpu.context.getCurrentTexture();      \n        // texture = device.createTexture({\n        //     size: [gpu.canvas.width, gpu.canvas.height, 1],\n        //     sampleCount: 4,\n        //     format: gpu.format as GPUTextureFormat,\n        //     usage: GPUTextureUsage.RENDER_ATTACHMENT,\n        // });\n        // renderPassDescription.colorAttachments[0].resolveTarget = contextTexture.createView();\n        // renderPassDescription.colorAttachments[0].view = texture.createView() as GPUTextureView;\n\n        // const commandEncoder = this.webGPU.device.createCommandEncoder();\n        // // const renderPass = commandEncoder.beginRenderPass(renderPassDescription as GPURenderPassDescriptor);\n\n        // this.textureView = this.webGPU.ctx.getCurrentTexture().createView();\n        // this.renderPassDescription.colorAttachments[0].view = this.textureView;\n        \n        // const renderPass = commandEncoder.beginRenderPass(this.renderPassDescription as GPURenderPassDescriptor);\n\n        this.webGPU.renderPass.setPipeline(this.pipeline);\n        this.webGPU.renderPass.setVertexBuffer(0, this.vertexBuffer);\n        this.webGPU.renderPass.setBindGroup(0, this.uniformBindGroup);\n        this.webGPU.renderPass.draw(this.numberOfVertices);\n\n        // this.webGPU.renderPass.end();\n        // this.webGPU.device.queue.submit([this.commandEncoder.finish()]);\n        this.t += 0.01;\n    }\n}\nexport const Shaders = () => {\n    const vertex = `\n        struct Uniforms {\n            mvpMatrix : mat4x4<f32>,\n        };\n        @binding(0) @group(0) var<uniform> uniforms : Uniforms;\n        \n        @vertex\n        fn main(@location(0) pos: vec4<f32>) ->  @builtin(position) vec4<f32> {\n            return uniforms.mvpMatrix * pos;     \n        }`;\n\n    const fragment = `\n        @fragment\n        fn main() -> @location(0) vec4<f32> {\n            return vec4<f32>(1.0, 1.0, 0.0, 1.0);            \n        }`;\n\n    return {\n        vertex, \n        fragment\n    };\n}\n\n\nexport const SphereData = (radius:number = 2, u:number = 20, v:number = 15, center:vec3 = [0,0,0], ul = 1, vl = 1) => {\n    if(u<2 || v<2) return;\n    let pts = [];\n    let pt:vec3;\n    for(let i = 0;i<u;i++){\n        let pt1:vec3[] = [];\n        for(let j=0;j<v;j++){\n            pt = SpherePosition(radius, i*180/(u-1), j*360/(v-1), center);                \n            pt1.push(pt);\n        }\n        pts.push(pt1);\n    }\n\n    let vertex = [] as any, normal = [] as any;\n    let uv = [] as any;\n    let u0, u1, u2,u3, v0,v1,v2,v3;\n    let p0:vec3,p1:vec3,p2:vec3,p3:vec3,a:vec3, b:vec3;\n\n    for(let i=0;i<u-1;i++){\n        for(let j=0;j<v-1;j++){\n            p0 = pts[i][j];\n            p1 = pts[i+1][j];\n            p2 = pts[i+1][j+1];\n            p3 = pts[i][j+1];\n            a = vec3.create();\n            b = vec3.create();\n            vec3.subtract(a, p2,p0);\n            vec3.subtract(b, p1,p3); \n            \n            // vertex data\n            vertex.push([\n                //first triangle                    \n                p0[0],p0[1],p0[2], p1[0],p1[1],p1[2], p3[0],p3[1],p3[2],  \n\n                //second triangle                    \n                p1[0],p1[1],p1[2], p2[0],p2[1],p2[2], p3[0],p3[1],p3[2]  \n            ]);\n\n            //normal data\n            normal.push([\n                //first triangle\n                p0[0]/radius,p0[1]/radius,p0[2]/radius,\n                p1[0]/radius,p1[1]/radius,p1[2]/radius,\n                p3[0]/radius,p3[1]/radius,p3[2]/radius,\n\n                //second triangle                    \n                p1[0]/radius,p1[1]/radius,p1[2]/radius, \n                p2[0]/radius,p2[1]/radius,p2[2]/radius,\n                p3[0]/radius,p3[1]/radius,p3[2]/radius\n            ]);\n\n            // uv data\n            u0 = ul * (0.5+Math.atan2(p0[0]/radius,p0[2]/radius)/Math.PI/2);\n            u1 = ul * (0.5+Math.atan2(p1[0]/radius,p1[2]/radius)/Math.PI/2);\n            u2 = ul * (0.5+Math.atan2(p2[0]/radius,p2[2]/radius)/Math.PI/2);\n            u3 = ul * (0.5+Math.atan2(p3[0]/radius,p3[2]/radius)/Math.PI/2);\n            v0 = vl * (0.5-Math.asin(p0[1]/radius)/Math.PI);\n            v1 = vl * (0.5-Math.asin(p1[1]/radius)/Math.PI);\n            v2 = vl * (0.5-Math.asin(p2[1]/radius)/Math.PI);\n            v3 = vl * (0.5-Math.asin(p3[1]/radius)/Math.PI);\n\n            uv.push([\n                //first triangle\n                u0, v0, u1, v1, u3, v3,                   \n\n                //second triangle \n                u1, v1, u2, v2, u3, v3                   \n            ]);\n        }\n    }\n    return {\n        vertexData: new Float32Array(vertex.flat()),\n        normalData: new Float32Array(normal.flat()),\n        uvData: new Float32Array(uv.flat())\n    }\n};\n\nexport const SpherePosition = (radius:number, theta:number, phi:number, center:vec3 = [0,0,0]) => {\n    let snt = Math.sin(theta*Math.PI/180);\n    let cnt = Math.cos(theta*Math.PI/180);\n    let snp = Math.sin(phi*Math.PI/180);\n    let cnp = Math.cos(phi*Math.PI/180);\n    return vec3.fromValues(radius*snt*cnp + center[0], radius*cnt + center[1], -radius*snt*snp + center[2]);     \n};","import { App } from \"..\";\n\nimport { ObjectBase } from '../Geometry/Base';\nimport { Quad } from '../Geometry/BaseTemplate';\n\nimport { ExShader } from '../Geometry/ExSh';\n\nimport { NBox } from '../Geometry/NBox';\nimport { NGeojsonPoint } from '../Geometry/NGeojsonPoint';\nimport { NGeojsonLine } from '../Geometry/NGeojsonLine';\nimport { NSphereWire } from '../Geometry/NSphereWire';\n\nimport { Line } from '../Geometry/Line';\nimport { Tri } from '../Geometry/Tri';\nimport { TriangleMesh } from \"../Geometry/TriMesh\";\n\nimport { TriMeshUniform } from \"../Object/TriMeshUniform\";\nimport { SphereWire } from '../Object/SphereWire';\nimport { Box } from \"../Object/Box\";\nimport { BoxF } from \"../Object/BoxF\";\nimport { PolylineRandom } from \"../Object/PolylineRandom\";\n\nexport class Scene {\n    public app: App;\n    public objects: ObjectBase[] = [];\n\n    independentPipeline = false;\n    \n    public t = 0.0;\n    constructor(app: App) {\n        this.app = app;\n\n        \n    }\n    async init() {\n\n        // new TriMeshUniform(this);\n\n\n        // new Box(this);\n        // new SphereWire(this);\n\n        // new BoxF(this);\n        // new TriangleMesh(this);\n\n\n        \n        // new NBox(this)\n        new NSphereWire(this)\n\n        new NGeojsonPoint(this);\n        new NGeojsonLine(this);\n\n        // new Quad(this);\n\n        // new ExShader(this);\n\n        // new PolylineRandom(this);\n    }\n    public render() {\n        if (this.independentPipeline) {\n            this.renderObject();\n        } else {\n            this.renderScene();\n        }\n        this.t+= 1;\n    }\n    public renderObject() {\n        for (let i = 0 ; i < this.objects.length; ++i) {\n            this.objects[i].update();\n            this.objects[i].render();\n        }\n    }\n    public renderScene() {\n        // this.webGPU.device.queue.writeBuffer(this.uniformBuffer, 0, this.modelMatrix as ArrayBuffer);\n        this.app.renderer.webGPU.textureView = this.app.renderer.webGPU.ctx.getCurrentTexture().createView();\n        this.app.renderer.webGPU.renderPassDescription.colorAttachments[0].view = this.app.renderer.webGPU.textureView;\n        this.app.renderer.webGPU.commandEncoder = this.app.renderer.webGPU.device.createCommandEncoder();\n        this.app.renderer.webGPU.renderPass = this.app.renderer.webGPU.commandEncoder.beginRenderPass(this.app.renderer.webGPU.renderPassDescription as GPURenderPassDescriptor);\n\n        for (let i = 0 ; i < this.objects.length; ++i) {\n            this.objects[i].update();\n            this.objects[i].render();\n        }\n\n\n        if (this.t % 300 === 0) {\n            // new TriMeshUniform(this);\n            // new Box(this);\n            // console.log('ddd');\n        }\n\n\n        this.app.renderer.webGPU.renderPass.end();\n        this.app.renderer.webGPU.device.queue.submit([this.app.renderer.webGPU.commandEncoder.finish()]);\n    }\n}","import { Controller } from './Controller';\r\nimport { Renderer } from './Renderer';\r\nimport { Scene } from './Scene';\r\n\r\nexport { Renderer } from './Renderer';\r\n\r\n// https://www.youtube.com/playlist?list=PLn3eTxaOtL2Ns3wkxdyS3CiqkJuwQdZzn\r\n// https://www.youtube.com/playlist?list=PL_UrKDEhALdKh0118flOjuAnVIGKFUJXN\r\n\r\n// https://webgpufundamentals.org/\r\n// https://webgpu.github.io/webgpu-samples/\r\n\r\n// https://antongerdelan.net/opengl/raycasting.html\r\n\r\n// https://github.com/jack1232/webgpu-simplified/blob/main/src/index.ts\r\n// https://webgpu-gpu-book.drxudotnet.com/#index\r\n// https://webgpu-gpu-book.drxudotnet.com/#ch01-triangle-primitive\r\n// https://github.com/jack1232/webgpu-new-video-series/tree/main\r\n\r\n// https://codepen.io/g-vitrac/pen/JjeoKgY\r\n\r\n\r\nexport class App {\r\n    public divHost: HTMLElement;\r\n\r\n    public controller: Controller;\r\n    public renderer: Renderer;\r\n    public scene: Scene;\r\n\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        this.renderer = new Renderer(this)\r\n        this.controller = new Controller(this);\r\n        this.scene = new Scene(this);\r\n\r\n        this.init();\r\n        // console.log('NWebGPU');\r\n    }\r\n    public async init() {\r\n        this.controller.init();\r\n        await this.renderer.init();\r\n        await this.scene.init();\r\n    };\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nexport class Solution {\r\n    public app: App\r\n    constructor(id: string) {\r\n        this.app = new App(id)\r\n    }\r\n    public destroy() {\r\n        this.app.destroy();\r\n    }\r\n}","import { vec3, mat4 } from 'gl-matrix';\n\nexport const loadWGSL = async (path: string) => {\n    return fetch(`${path}`)\n        .then((response: Response) => {\n            return response.text();\n        }).catch((err: Error) => {\n            console.debug(err);\n        });\n\n}\n\nexport const createViewProjection = (respectRatio = 1.0, cameraPosition:vec3 = [2, 2, 4], lookDirection:vec3 = [0, 0, 0], \n    upDirection:vec3 = [0, 1, 0]) => {\n\n    const viewMatrix = mat4.create();\n    const projectionMatrix = mat4.create();       \n    const viewProjectionMatrix = mat4.create();\n\n    // mat4.perspective(projectionMatrix, 2 * Math.PI / 5, respectRatio, 0.1, 100.0);\n    mat4.ortho(projectionMatrix, 0, 0, 800, 800, -400 , 400);\n    // mat4.frustum(projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n    mat4.lookAt(viewMatrix, cameraPosition, lookDirection, upDirection);\n    mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);\n\n    const cameraOption = {\n        eye: cameraPosition,\n        center: lookDirection,\n        zoomMax: 100,\n        zoomSpeed: 2\n    };\n\n    return {\n        viewMatrix,\n        projectionMatrix,\n        viewProjectionMatrix,\n        cameraOption\n    }\n};\n\nexport const createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};\n\nexport const createGPUBuffer = (device:GPUDevice, data:Float32Array, usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\n    // console.log(data.byteLength, data)\n    const buffer = device.createBuffer({\n        size: data.byteLength,\n        usage: usageFlag,\n        mappedAtCreation: true\n    });\n    new Float32Array(buffer.getMappedRange()).set(data);\n    buffer.unmap();\n    return buffer;\n};"],"names":["EventController","constructor","controller","pos","mNormalized","Float32Array","isDown","this","init","appendEvent","app","renderer","canvas","addEventListener","e","offsetX","offsetY","xOff","yOff","cameraController","moveCamera","rect","getBoundingClientRect","clientX","left","width","clientY","top","height","zoomWheel","deltaY","window","keyboard","Controller","eventController","k","key","shiftCamera","Camera","cameraPosition","center","up","distance","viewMatrix","mat4","projectionMatrix","viewProjectionMatrix","zoomMax","zoomSpeed","near","far","mvpMatrix","eye","vec3","type","respectRatio","angleXY","Math","PI","angleZ","zoom","v","update","CameraPerspective","super","CameraOrth","projection","dst","scale","CameraController","solution","cameraOrth","cameraPerspective","camera","modelMatrix","rotation","translation","screen2","vec2","arcRotation","createTransforms","rotateZ","val","translateX","getMatrix","x","y","pan","sin","cos","modelMat","scaling","rotateXMat","rotateYMat","rotateZMat","translateMat","scaleMat","PrimitiveTopology","WebGPU","ctx","device","format","commandEncoder","renderPass","textureView","renderPassDescription","depthTexture","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","configure","alphaMode","getCurrentTexture","createView","createTexture","size","usage","GPUTextureUsage","RENDER_ATTACHMENT","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","depthStencilAttachment","depthClearValue","depthLoadOp","depthStoreOp","destroy","Renderer","webGPU","isAnimation","requestAni","loop","requestAnimationFrame","drawing","document","createElement","divHost","clientWidth","clientHeight","appendChild","async","initWebGPU","scene","render","cancelAnimationFrame","lastElementChild","removeChild","Geometry","streetOSM","colors","renderLines","paths","color","positions","indices","xOFf","yOFf","xC","yC","Count","i","length","route","j","xPro","yPro","MercatorProjection","xPro1","yPro1","x1","y1","push","floor","console","log","flat","getJSONFromURL","then","data","ObjectBase","objects","shaderPath","require","NGeojsonPoint","isRenderable","numberOfVertices","vertexBuffer","colorBuffer","normalBuffer","uvBuffer","uniformBindGroup","uniformBindGroup1","uniformBindGroup2","uniformBuffer","pipeline","mouseBuffer","frameBuffer","t","resultBuffer","geometry","initPipeline","createGPUBuffer","shader","loadWGSL","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","PointList","depthStencil","depthWriteEnabled","depthCompare","createBuffer","GPUBufferUsage","UNIFORM","COPY_DST","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","loadValue","queue","writeBuffer","setPipeline","setVertexBuffer","setBindGroup","draw","NGeojsonLine","LineList","NSphereWire","sphereData","SphereData","vertexData","normalData","uvData","Shaders","radius","u","ul","vl","pt","pts","pt1","SpherePosition","u0","u1","u2","u3","v0","v1","v2","v3","p0","p1","p2","p3","normal","uv","atan2","asin","theta","phi","snt","cnt","snp","cnp","Scene","independentPipeline","renderObject","renderScene","createCommandEncoder","beginRenderPass","end","submit","finish","App","id","getElementById","Solution","fetch","path","response","text","catch","err","debug","usageFlag","VERTEX","byteLength","mappedAtCreation","getMappedRange","set","unmap"],"sourceRoot":""}