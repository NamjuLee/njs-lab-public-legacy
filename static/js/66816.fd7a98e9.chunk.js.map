{"version":3,"file":"static/js/66816.fd7a98e9.chunk.js","mappings":"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","sources":["lib/NJSCore/Core/Geometry/NGeometry/GeospatialAnalysis.ts","njslab/Tools/TurfPlayground/index.ts","../node_modules/geojson-validation/index.js"],"sourcesContent":["export const earthRadius = 6371008.8;\nexport const UNIT = {\n    centimeters: earthRadius * 100,\n    degrees: 360 / (2 * Math.PI),\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    meters: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    yards: earthRadius * 1.0936,\n  };\nexport const degreesToRadians = (degrees: number): number => {\n  return ((degrees % 360) * Math.PI) / 180;\n};\nexport const distance = (coord0: number[], coord1: number[], unit = UNIT.meters ) => {\n  const dLat = degreesToRadians(coord1[1] - coord0[1]);\n  const dLon = degreesToRadians(coord1[0] - coord0[0]);\n  const lat1 = degreesToRadians(coord0[1]);\n  const lat2 = degreesToRadians(coord1[1]);\n  const val = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * Math.atan2(Math.sqrt(val), Math.sqrt(1 - val)) * unit;\n};","import { RendererCanvas, NJSCORE } from '../../../lib'\r\n\r\nimport { distance, UNIT} from '../../../lib/NJSCore/Core/Geometry/NGeometry/GeospatialAnalysis';\r\n\r\n// var jsv = require('json-validator');\r\n\r\nimport gjv from 'geojson-validation'; // https://www.npmjs.com/package/geojson-validation\r\n\r\nimport * as turf from '@turf/turf'\r\n\r\n// https://turfjs.org/\r\n// https://github.com/Turfjs/turf/\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id)\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n\r\n        this.divHost.appendChild(div);\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n\r\n        this.renderer = new Renderer(div);\r\n\r\n        // console.log(this.renderer);\r\n        // !! you should execute it for rendering\r\n        // this.start();\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nexport class Renderer extends RendererCanvas {\r\n\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // turf.\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        // \r\n\r\n        TestJsonVal();\r\n        // TestLength();\r\n  \r\n        this.start();\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        // TODO\r\n        // You code goes here for the rending loop\r\n\r\n\r\n        // !! can stop render after this frame.\r\n        // this.isStatic = true;\r\n    }\r\n\r\n}\r\n\r\n\r\nconst TestJsonVal = () => {\r\n\r\n    const validFeatureCollection = {\r\n        \"type\": \"FeatureCollection\",\r\n        \"features\": [\r\n            {\r\n                \"type\": \"Feature\",\r\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [102.0, 0.5]},\r\n                \"properties\": {\"prop0\": \"value0\"}\r\n            },\r\n            {\r\n                \"type\": \"Feature\",\r\n                \"geometry\": {\r\n                    \"type\": \"LineString\",\r\n                    \"coordinates\": [\r\n                        [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0] , [255, 0]\r\n                    ]\r\n                },\r\n                \"properties\": {\r\n                    \"prop0\": \"value0\",\r\n                    \"prop1\": 0.0\r\n                }\r\n            }\r\n        ]\r\n    };\r\n     \r\n    //simple test\r\n    if(gjv.valid(validFeatureCollection)){\r\n        // console.log(\"this is valid GeoJSON!\");\r\n\r\n        downloadGeoJson(validFeatureCollection)\r\n    }\r\n\r\n\r\n\r\n    const invalidFeature =  {\r\n        \"type\": \"feature\",\r\n        \"geometry\": {\r\n            \"type\": \"LineString\",\r\n            \"coordinates\": [\r\n                [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]\r\n            ]\r\n        },\r\n        \"properties\": {\r\n            \"prop0\": \"value0\",\r\n            \"prop1\": 0.0\r\n        }\r\n    };\r\n     \r\n    //test to see if `invalidFeature` is valid and return a \"trace\" which contains the error\r\n    const trace = gjv.isFeature(invalidFeature, true)\r\n    // console.log(trace)\r\n\r\n\r\n\r\n    gjv.define(\"Position\", (position) => {\r\n        //the postion must be valid point on the earth, x between -180 and 180\r\n        let errors = [];\r\n        if(position[0] < -180 || position[0] > 180){\r\n            errors.push(\"the x must be between -180 and 180\");\r\n        }\r\n        if(position[1] < -90 || position[1] > 90){\r\n            errors.push(\"the y must be between -90 and 90\");\r\n        }\r\n        return errors;\r\n     \r\n    });\r\n    const gj = {type: \"Point\", coordinates: [-200,3]};\r\n    //returns false\r\n    // gjv.isPoint(gj);\r\n\r\n\r\n}\r\n\r\nconst TestLength = () => {\r\n    const vs = [[115, -32], [131, -22]];\r\n    let len0 = 0;\r\n    for(let i = 0 ; i < vs.length - 1; ++i) {\r\n        const v0 = new NJSCORE.NVector3(vs[i][0], vs[i][1], 0);\r\n        const v1 = new NJSCORE.NVector3(vs[i+1][0], vs[i+1][1], 0);\r\n        const v = NJSCORE.NVector3.KMeterFromGPSPos(v0, v1)\r\n        len0 += v;\r\n    }\r\n\r\n    let len1 = 0;\r\n    for(let i = 0 ; i < vs.length - 1; ++i) {\r\n        const v0 = new NJSCORE.NVector3(vs[i][0], vs[i][1], 0);\r\n        const v1 = new NJSCORE.NVector3(vs[i+1][0], vs[i+1][1], 0);\r\n        const v = distance([v0.x, v0.y], [v1.x, v1.y], UNIT.kilometers);\r\n        len1 += v;\r\n    }\r\n\r\n    var line = turf.lineString(vs);\r\n    var length = turf.length(line, { units: 'kilometers' });\r\n\r\n    // console.log(length, 'len0', len0);\r\n    // console.log(length, 'len1', len1);\r\n};\r\n\r\nexport const downloadGeoJson = (collection, name = 'download', ) => {\r\n    const link = document.createElement('a');\r\n    link.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(collection));\r\n    link.download = `${name}.geojson`;\r\n    link.click();\r\n};\r\n\r\n","/**\n * geoJSON validation according to the GeoJSON spefication Version 1\n * @module geoJSONValidation\n * @class Main\n * @exports {GJV}\n */\n\nconst definitions = {}\n\n/**\n * Test an object to see if it is a function\n * @method isFunction\n * @param object {Object}\n * @return {Boolean}\n */\nfunction isFunction (object) {\n  return typeof (object) === 'function'\n}\n\n/**\n * A truthy test for objects\n * @method isObject\n * @param {Object}\n * @return {Boolean}\n */\nfunction isObject (object) {\n  return object === Object(object)\n}\n\n/**\n * Formats error messages, calls the callback\n * @method done\n * @private\n * @param trace {Boolean} Whether or not to return the trace\n * @param [message]\n * @return {Boolean} is the object valid or not?\n */\nfunction _done (trace, message) {\n  let valid = false\n\n  if (typeof message === 'string') {\n    message = [message]\n  } else if (Object.prototype.toString.call(message) === '[object Array]') {\n    if (message.length === 0) {\n      valid = true\n    }\n  } else {\n    valid = true\n  }\n\n  if (trace) {\n    return message\n  } else {\n    return valid\n  }\n}\n\n/**\n * calls a custom definition if one is avalible for the given type\n * @method _customDefinitions\n * @private\n * @param type {'String'} a GeoJSON object type\n * @param object {Object} the Object being tested\n * @return {Array} an array of errors\n */\nfunction _customDefinitions (type, object) {\n  let errors\n\n  if (isFunction(definitions[type])) {\n    try {\n      errors = definitions[type](object)\n    } catch (e) {\n      errors = ['Problem with custom definition for '+type+': '+e]\n    }\n    if (typeof result === 'string') {\n      errors = [errors]\n    }\n    if (Object.prototype.toString.call(errors) === '[object Array]') {\n      return errors\n    }\n  }\n  return []\n}\n\n/**\n * Define a custom validation function for one of GeoJSON objects\n * @method define\n * @param type {GeoJSON Type} the type\n * @param definition {Function} A validation function\n * @return {Boolean} Return true if the function was loaded corectly else false\n */\nexports.define = (type, definition) => {\n  if ((type in allTypes) && isFunction(definition)) {\n    // TODO: check to see if the type is valid\n    definitions[type] = definition\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Determines if an object is a position or not\n * @method isPosition\n * @param position {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPosition = (position, trace = false) => {\n  let errors = []\n\n  // It must be an array\n  if (Array.isArray(position)) {\n    // and the array must have more than one element\n    if (position.length <= 1) {\n      errors.push('Position must be at least two elements')\n    }\n\n    position.forEach((pos, index) => {\n      if (typeof pos !== 'number') {\n        errors.push('Position must only contain numbers. Item '+pos+' at index '+index+' is invalid.')\n      }\n    })\n  } else {\n    errors.push('Position must be an array')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Position', position))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a GeoJSON Object or not\n * @method isGeoJSONObject|valid\n * @param geoJSONObject {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isGeoJSONObject = exports.valid = (geoJSONObject, trace = false) => {\n  if (!isObject(geoJSONObject)) {\n    return _done(trace, ['must be a JSON Object'])\n  } else {\n    let errors = []\n    if ('type' in geoJSONObject) {\n      if (nonGeoTypes[geoJSONObject.type]) {\n        return nonGeoTypes[geoJSONObject.type](geoJSONObject, trace)\n      } else if (geoTypes[geoJSONObject.type]) {\n        return geoTypes[geoJSONObject.type](geoJSONObject, trace)\n      } else {\n        errors.push('type must be one of: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", \"GeometryCollection\", \"Feature\", or \"FeatureCollection\"')\n      }\n    } else {\n      errors.push('must have a member with the name \"type\"')\n    }\n\n    // run custom checks\n    errors = errors.concat(_customDefinitions('GeoJSONObject', geoJSONObject))\n    return _done(trace, errors)\n  }\n}\n\n/**\n * Determines if an object is a Geometry Object or not\n * @method isGeometryObject\n * @param geometryObject {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isGeometryObject = (geometryObject, trace = false) => {\n  if (!isObject(geometryObject)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('type' in geometryObject) {\n    if (geoTypes[geometryObject.type]) {\n      return geoTypes[geometryObject.type](geometryObject, trace)\n    } else {\n      errors.push('type must be one of: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\" or \"GeometryCollection\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('GeometryObject', geometryObject))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a Point or not\n * @method isPoint\n * @param point {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPoint = (point, trace = false) => {\n  if (!isObject(point)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in point) {\n    const t = exports.isBbox(point.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in point) {\n    if (point.type !== 'Point') {\n      errors.push('type must be \"Point\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in point) {\n    const t = exports.isPosition(point.coordinates, true)\n    if (t.length) {\n\terrors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Point', point))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a MultiPoint\n * @method isMultiPointCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPointCoor = (coordinates, trace = false) => {\n  let errors = []\n\n  if (Array.isArray(coordinates)) {\n    coordinates.forEach((val, index) => {\n      const t = exports.isPosition(val, true)\n      if (t.length) {\n        // modify the err msg from \"isPosition\" to note the element number\n        t[0] = 'at ' + index + ': '.concat(t[0])\n        // build a list of invalide positions\n        errors = errors.concat(t)\n      }\n    })\n  } else {\n    errors.push('coordinates must be an array')\n  }\n  return _done(trace, errors)\n}\n/**\n * Determines if an object is a MultiPoint or not\n * @method isMultiPoint\n * @param position {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPoint = (multiPoint, trace = false) => {\n  if (!isObject(multiPoint)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in multiPoint) {\n    const t = exports.isBbox(multiPoint.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in multiPoint) {\n    if (multiPoint.type !== 'MultiPoint') {\n      errors.push('type must be \"MultiPoint\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in multiPoint) {\n    const t = exports.isMultiPointCoor(multiPoint.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('MultiPoint', multiPoint))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a lineString\n * @method isLineStringCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isLineStringCoor = (coordinates, trace = false) => {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    if (coordinates.length > 1) {\n      coordinates.forEach((val, index) => {\n        const t = exports.isPosition(val, true)\n        if (t.length) {\n          // modify the err msg from 'isPosition' to note the element number\n          t[0] = 'at ' + index + ': '.concat(t[0])\n          // build a list of invalide positions\n          errors = errors.concat(t)\n        }\n      })\n    } else {\n      errors.push('coordinates must have at least two elements')\n    }\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a lineString or not\n * @method isLineString\n * @param lineString {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isLineString = (lineString, trace = false) => {\n  if (!isObject(lineString)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in lineString) {\n    const t = exports.isBbox(lineString.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in lineString) {\n    if (lineString.type !== 'LineString') {\n      errors.push('type must be \"LineString\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in lineString) {\n    const t = exports.isLineStringCoor(lineString.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('LineString', lineString))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a MultiLineString\n * @method isMultiLineStringCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiLineStringCoor = (coordinates, trace = false) => {\n    let errors = []\n    if (Array.isArray(coordinates)) {\n\tcoordinates.forEach((val, index) => {\n\t    const t = exports.isLineStringCoor(val, true)\n\t    if (t.length) {\n\t\t// modify the err msg from 'isPosition' to note the element number\n\t\tt[0] = 'at ' + index + ': '.concat(t[0])\n\t\t// build a list of invalide positions\n\t\terrors = errors.concat(t)\n\t    }\n\t})\n    } else {\n\terrors.push('coordinates must be an array')\n    }\n    return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a MultiLine String or not\n * @method isMultiLineString\n * @param multilineString {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiLineString = (multilineString, trace = false) => {\n  if (!isObject(multilineString)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in multilineString) {\n    const t = exports.isBbox(multilineString.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in multilineString) {\n    if (multilineString.type !== 'MultiLineString') {\n      errors.push('type must be \"MultiLineString\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in multilineString) {\n    const t = exports.isMultiLineStringCoor(multilineString.coordinates, true)\n\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('MultiPoint', multilineString))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array is a linear Ring String or not\n * @method isMultiLineString\n * @private\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nfunction _linearRingCoor (coordinates, trace) {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    // 4 or more positions\n    coordinates.forEach((val, index) => {\n      const t = exports.isPosition(val, true)\n      if (t.length) {\n\t// modify the err msg from 'isPosition' to note the element number\n\tt[0] = 'at ' + index + ': '.concat(t[0])\n\t// build a list of invalide positions\n\terrors = errors.concat(t)\n      }\n    })\n\n    // check the first and last positions to see if they are equivalent\n    // TODO: maybe better checking?\n    if (coordinates[0].toString() !== coordinates[coordinates.length - 1].toString()) {\n      errors.push('The first and last positions must be equivalent')\n    }\n\n    if (coordinates.length < 4) {\n      errors.push('coordinates must have at least four positions')\n    }\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array is valid Polygon Coordinates or not\n * @method _polygonCoor\n * @private\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPolygonCoor = (coordinates, trace = false) => {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    coordinates.forEach((val, index) => {\n      const t = _linearRingCoor(val, true)\n\n      if (t.length) {\n        // modify the err msg from 'isPosition' to note the element number\n        t[0] = 'at ' + index + ': '.concat(t[0])\n        // build a list of invalid positions\n        errors = errors.concat(t)\n      }\n    })\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Polygon\n * @method isPolygon\n * @param polygon {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isPolygon = (polygon, trace = false) => {\n  if (!isObject(polygon)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n\n  if ('bbox' in polygon) {\n    const t = exports.isBbox(polygon.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in polygon) {\n    if (polygon.type !== 'Polygon') {\n      errors.push('type must be \"Polygon\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in polygon) {\n    const t = exports.isPolygonCoor(polygon.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Polygon', polygon))\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an array can be interperted as coordinates for a MultiPolygon\n * @method isMultiPolygonCoor\n * @param coordinates {Array}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPolygonCoor = (coordinates, trace = false) => {\n  let errors = []\n  if (Array.isArray(coordinates)) {\n    coordinates.forEach((val, index) => {\n      const t = exports.isPolygonCoor(val, true)\n      if (t.length) {\n        // modify the err msg from 'isPosition' to note the element number\n        t[0] = 'at ' + index + ': '.concat(t[0])\n        // build a list of invalide positions\n        errors = errors.concat(t)\n      }\n    })\n  } else {\n    errors.push('coordinates must be an array')\n  }\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid MultiPolygon\n * @method isMultiPolygon\n * @param multiPolygon {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isMultiPolygon = (multiPolygon, trace = false) => {\n  if (!isObject(multiPolygon)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in multiPolygon) {\n    const t = exports.isBbox(multiPolygon.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in multiPolygon) {\n    if (multiPolygon.type !== 'MultiPolygon') {\n      errors.push('type must be \"MultiPolygon\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('coordinates' in multiPolygon) {\n    const t = exports.isMultiPolygonCoor(multiPolygon.coordinates, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  } else {\n    errors.push('must have a member with the name \"coordinates\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('MultiPolygon', multiPolygon))\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Geometry Collection\n * @method isGeometryCollection\n * @param geometryCollection {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isGeometryCollection = (geometryCollection, trace = false) => {\n  if (!isObject(geometryCollection)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in geometryCollection) {\n    const t = exports.isBbox(geometryCollection.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in geometryCollection) {\n    if (geometryCollection.type !== 'GeometryCollection') {\n      errors.push('type must be \"GeometryCollection\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('geometries' in geometryCollection) {\n    if (Array.isArray(geometryCollection.geometries)) {\n      geometryCollection.geometries.forEach((val, index) => {\n        const t = exports.isGeometryObject(val, true)\n        if (t.length) {\n          // modify the err msg from 'isPosition' to note the element number\n          t[0] = 'at ' + index + ': '.concat(t[0])\n          // build a list of invalide positions\n          errors = errors.concat(t)\n        }\n      })\n    } else {\n      errors.push('\"geometries\" must be an array')\n    }\n  } else {\n    errors.push('must have a member with the name \"geometries\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('GeometryCollection', geometryCollection))\n\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Feature\n * @method isFeature\n * @param feature {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isFeature = (feature, trace = false) => {\n  if (!isObject(feature)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in feature) {\n    const t = exports.isBbox(feature.bbox, true)\n    if (t.length) {\n      errors = errors.concat(t)\n    }\n  }\n\n  if ('type' in feature) {\n    if (feature.type !== 'Feature') {\n      errors.push('type must be \"Feature\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if (!('properties' in feature)) {\n    errors.push('must have a member with the name \"properties\"')\n  }\n\n  if ('geometry' in feature) {\n    if (feature.geometry !== null) {\n      const t = exports.isGeometryObject(feature.geometry, true)\n      if (t.length) {\n        errors = errors.concat(t)\n      }\n    }\n  } else {\n    errors.push('must have a member with the name \"geometry\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Feature', feature))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Feature Collection\n * @method isFeatureCollection\n * @param featureCollection {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isFeatureCollection = (featureCollection, trace = false) => {\n  if (!isObject(featureCollection)) {\n    return _done(trace, ['must be a JSON Object'])\n  }\n\n  let errors = []\n  if ('bbox' in featureCollection) {\n    const t = exports.isBbox(featureCollection.bbox, true)\n    if (t.length) {\n      errors = t\n    }\n  }\n\n  if ('type' in featureCollection) {\n    if (featureCollection.type !== 'FeatureCollection') {\n      errors.push('type must be \"FeatureCollection\"')\n    }\n  } else {\n    errors.push('must have a member with the name \"type\"')\n  }\n\n  if ('features' in featureCollection) {\n    if (Array.isArray(featureCollection.features)) {\n      featureCollection.features.forEach((val, index) => {\n        const t = exports.isFeature(val, true)\n        if (t.length) {\n\n          // modify the err msg from 'isPosition' to note the element number\n          t[0] = 'at ' + index + ': '.concat(t[0])\n          // build a list of invalide positions\n          errors = errors.concat(t)\n        }\n      })\n    } else {\n      errors.push('\"Features\" must be an array')\n    }\n  } else {\n    errors.push('must have a member with the name \"Features\"')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('FeatureCollection', featureCollection))\n  return _done(trace, errors)\n}\n\n/**\n * Determines if an object is a valid Bounding Box\n * @method isBbox\n * @param bbox {Object}\n * @param [trace] {Boolean}\n * @return {Boolean}\n */\nexports.isBbox = (bbox, trace = false) => {\n  let errors = []\n  if (Array.isArray(bbox)) {\n    if (bbox.length % 2 !== 0) {\n      errors.push('bbox, must be a 2*n array')\n    }\n  } else {\n    errors.push('bbox must be an array')\n  }\n\n  // run custom checks\n  errors = errors.concat(_customDefinitions('Bbox', bbox))\n  return _done(trace, errors)\n}\n\nconst nonGeoTypes = {\n  'Feature': exports.isFeature,\n  'FeatureCollection': exports.isFeatureCollection\n}\n\nconst geoTypes = {\n  'Point': exports.isPoint,\n  'MultiPoint': exports.isMultiPoint,\n  'LineString': exports.isLineString,\n  'MultiLineString': exports.isMultiLineString,\n  'Polygon': exports.isPolygon,\n  'MultiPolygon': exports.isMultiPolygon,\n  'GeometryCollection': exports.isGeometryCollection\n}\n\nconst allTypes = {\n  'Feature': exports.isFeature,\n  'FeatureCollection': exports.isFeatureCollection,\n  'Point': exports.isPoint,\n  'MultiPoint': exports.isMultiPoint,\n  'LineString': exports.isLineString,\n  'MultiLineString': exports.isMultiLineString,\n  'Polygon': exports.isPolygon,\n  'MultiPolygon': exports.isMultiPolygon,\n  'GeometryCollection': exports.isGeometryCollection,\n  'Bbox': exports.isBbox,\n  'Position': exports.isPosition,\n  'GeoJSON': exports.isGeoJSONObject,\n  'GeometryObject': exports.isGeometryObject\n}\n\nexports.allTypes = allTypes\n"],"names":["earthRadius","Math","PI","Solution","constructor","id","divHost","renderer","this","document","getElementById","style","display","alignItems","div","createElement","marginLeft","marginRight","backgroundColor","width","height","appendChild","Renderer","destroy","lastElementChild","removeChild","RendererCanvas","super","canvas","position","TestJsonVal","start","render","ctx","validFeatureCollection","gjv","downloadGeoJson","errors","push","collection","name","link","href","encodeURIComponent","JSON","stringify","download","click","definitions","isFunction","object","isObject","Object","_done","trace","message","valid","prototype","toString","call","length","_customDefinitions","type","e","result","exports","define","definition","allTypes","isPosition","Array","isArray","forEach","pos","index","concat","isGeoJSONObject","geoJSONObject","nonGeoTypes","geoTypes","isGeometryObject","geometryObject","isPoint","point","t","isBbox","bbox","coordinates","isMultiPointCoor","val","isMultiPoint","multiPoint","isLineStringCoor","isLineString","lineString","isMultiLineStringCoor","isMultiLineString","multilineString","isPolygonCoor","_linearRingCoor","isPolygon","polygon","isMultiPolygonCoor","isMultiPolygon","multiPolygon","isGeometryCollection","geometryCollection","geometries","isFeature","feature","geometry","isFeatureCollection","featureCollection","features"],"sourceRoot":""}