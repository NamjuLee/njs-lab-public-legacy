{"version":3,"file":"static/js/46759.428ef2b6.chunk.js","mappings":"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","sources":["njslab/Project/Project_03_SlowZone/01_JSAPI/Tint/FilterGLViewDarkForDarken.ts","njslab/Project/Project_03_SlowZone/PolygonInteraction/index.ts"],"sourcesContent":["import { NVector3, GLShaderCommon } from '../../../../../lib/NJSCore';\n\n// import { Mat3 } from '../../AppCore/GLUtility/Mat3';\n\nexport class FilterGLViewDarkForDarken {\n\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    fragmentShader: WebGLShader;\n    vertexShader: WebGLShader;\n    matrixLocation: WebGLProgram;\n    posBuffer: WebGLBuffer;\n    colBuffer: WebGLBuffer;\n    vertexs: Float32Array;\n\n    posLocAtt: number;\n    colLocAtt: number;\n    matLoc: WebGLUniformLocation;\n    colLoc: WebGLUniformLocation;\n    cVecLoc: WebGLUniformLocation;\n    mouseLoc: WebGLUniformLocation;\n    timeGL: WebGLUniformLocation;\n    // startTime: number;\n    // randomSeed: number;\n\n    vShader: WebGLShader;\n    fShader: WebGLShader;\n\n    v = `\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    \n    varying vec4 f_color;\n\n    void main() {\n\n        vec2 mouse_distance = vec2(0,0) - (a_position.xy /vec2(2,2));\n        float red = 1.0 - length(mouse_distance);\n        f_color = vec4(a_position, 0, 1.0);\n    \n        // float dis = distance(vec2(a_position.xy), vec2(0,0));\n\n        // f_color = vec4(dis * 0.6, 0,0,1);\n        gl_Position = vec4( a_position, 0, 1);\n    }\n    `;\n\n    f = `\n    precision highp float;\n\n    varying vec4 f_color;\n    \n    void main() {\n        vec2 mouse_distance = vec2(0,0) - (f_color.xy /vec2(5,5));\n\n        float col =  length(mouse_distance*5.);\n        float val = 1.0 - length(mouse_distance*8.);\n        \n        gl_FragColor = vec4(0.19,0.19,0.19, col);\n\n    }\n    `;\n\n    positionAttribLocation: WebGLProgram;\n    colorAttribLocation: WebGLProgram;\n    translation: NVector3;\n    color: number[];\n    colArray: Float32Array;\n\n    constructor(gl: WebGLRenderingContext, xt: number = 100, yt: number = 100, zt: number = 0, xs: number = 1, ys: number = 1, zs: number = 1) {\n        this.gl = gl;\n        // this.translation = new NVector3(xt, yt, zt);\n        // this.angleInRadians = 0;\n        // this.scale = new NVector3(xs, ys, zs);\n        this.color = [Math.random(), Math.random(), Math.random(), 1];\n        this.InitShader();\n    }\n    InitShader() {\n        // let vShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.VERTEX_SHADER,'/shader/vsCanvas.glsl');\n        // let fShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.FRAGMENT_SHADER, '/shader/fsColor.glsl');\n\n        let vShader = GLShaderCommon.CreateShader(this.gl, this.gl.VERTEX_SHADER, this.v); // '/shader/vsCanvas.glsl');\n        let fShader = GLShaderCommon.CreateShader(this.gl, this.gl.FRAGMENT_SHADER, this.f); // '/shader/fsColor.glsl');\n\n        if (vShader && fShader) {\n            this.vShader = vShader;\n            this.fShader = fShader;\n            let program = GLShaderCommon.CreateProgram(this.gl, vShader, fShader);\n            if (program) { this.program = program; }\n        }\n\n        // this.InitVerext();\n    }\n    Render(gl: WebGLRenderingContext) {\n\n        let col = [0.1, 0, 0, 1];\n\n        this.vertexs = new Float32Array([\n            // left column\n            -1, -1, 1, 1, 1, 1,\n            - 1, 1, col[0], col[1], col[2], col[3],\n            1, -1, col[0], col[1], col[2], col[3],\n\n            -1, 1, 1, 1, 1, 1,\n            1, -1, col[0], col[1], col[2], col[3],\n            1, 1, col[0], col[1], col[2], col[3],\n\n        ]);\n\n        this.posBuffer = this.gl.createBuffer() as WebGLBuffer;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertexs), gl.STATIC_DRAW);\n\n        this.posLocAtt = this.gl.getAttribLocation(this.program, 'a_position');\n        // Tell the attribute how to get data out of posBuffer (ARRAY_BUFFER)\n        let size = 2;          // 2 components per iteration\n        let type = gl.FLOAT;   // the data is 32bit floats\n        let normalize = false; // don't normalize the data\n        let stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        let offset = 0;        // start at the beginning of the buffer\n        gl.vertexAttribPointer(this.posLocAtt, size, type, normalize, stride, offset);\n        gl.enableVertexAttribArray(this.posLocAtt);\n\n        // this.colLocAtt = this.gl.getAttribLocation(this.program, 'a_color');\n        // size = 4;          // 2 components per iteration\n        // type = gl.FLOAT;   // the data is 32bit floats\n        // normalize = false; // don't normalize the data\n        // stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        // offset = 2 * Float32Array.BYTES_PER_ELEMENT;        // start at the beginning of the buffer\n        // gl.vertexAttribPointer(this.colLocAtt, size, type, normalize, stride, offset);\n        // gl.enableVertexAttribArray(this.colLocAtt);\n\n        gl.useProgram(this.program);\n        let primitiveType = gl.TRIANGLES; // LINE_LOOP; // gl.TRIANGLE_STRIP;\n        offset = 0;\n        let count = 6; // this.vertexs.length * 0.5;\n        gl.drawArrays(primitiveType, offset, count);\n\n    }\n}","import * as THREE from 'three';\r\nimport { RendererThree, MercatorProjection, } from '../../../../lib';\r\nimport { getJSONFromURL, } from 'njscore';\r\n\r\nimport { FilterGLViewDarkForDarken } from '../01_JSAPI/Tint/FilterGLViewDarkForDarken';\r\nimport { meshgrid } from '@tensorflow/tfjs-core';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    meshArea: THREE.Mesh[];\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Mesh.threshold = 3;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.2, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n        const canvasGL = document.createElement('canvas');\r\n        canvasGL.style.position = 'absolute';\r\n        canvasGL.style.pointerEvents = 'none';\r\n        canvasGL.style.mixBlendMode = 'darken';\r\n        canvasGL.width = this.hostDiv.clientWidth;\r\n        canvasGL.height = this.hostDiv.clientHeight;\r\n        this.hostDiv.appendChild(canvasGL);\r\n        const glCtx = canvasGL.getContext('webgl');\r\n        const d = new FilterGLViewDarkForDarken(glCtx, 0.5, 5)\r\n        d.Render(glCtx);\r\n\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        // const path = '/static/research/slow-zone/';\r\n        // getJSONFromURL(process.env.PUBLIC_URL + path + 'street_osm.geojson').then((data) => {\r\n        getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            // renderLines(this.scene, this.streetOSM, [0, 1, 1]);\r\n            renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n\r\n\r\n            getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/treated-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesTreated.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                // renderLines(this.scene, this.routesTreated, [1, 0, 0]);\r\n            });\r\n\r\n            getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/control-st.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.routesControl.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                // renderLines(this.scene, this.routesControl, [0, 1, 0]);\r\n            });\r\n\r\n            getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/zones-30.geojson').then((data) => {\r\n                for (let i = 0; i < data['features'].length; ++i) {\r\n                    this.zones30.push(data['features'][i]['geometry']['coordinates']);\r\n                }\r\n                this.meshArea = renderMultiPolygon(this.scene, this.zones30, [0, 1, 0]);\r\n                this.start();\r\n            });\r\n\r\n\r\n\r\n        });\r\n    }\r\n\r\n    public update(scene: THREE.Scene) {\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObjects(this.meshArea, true);\r\n\r\n        if (intersects.length > 0) {\r\n            this.sphere.visible = true;\r\n            this.sphere.position.copy(intersects[0].point);\r\n        } else {\r\n\r\n            this.sphere.visible = false;\r\n        }\r\n\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        // console.log(e)\r\n        this.pointer.x = ((e.offsetX) / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - ((e.offsetY) / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public mouseDown(e: MouseEvent): void {\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersects = this.raycaster.intersectObjects(this.meshArea, false);\r\n\r\n        //     console.log(intersects);\r\n\r\n        if (intersects.length > 0) {\r\n            this.sphere.visible = true;\r\n\r\n            const captured = this.scene.getObjectById(intersects[0].object.id) as THREE.Mesh;\r\n\r\n            const dd = captured.material as THREE.MeshBasicMaterial;\r\n            // console.log(dd);\r\n            dd.color.r += 0.2;\r\n            // console.log(col)\r\n            // const INTERSECTED = intersects[ 0 ].object;\r\n\r\n        } else {\r\n\r\n            this.sphere.visible = false;\r\n        }\r\n    }\r\n}\r\n\r\nconst renderMultiPolygon = (scene: THREE.Scene, paths: any, colorArray: number[]) => {\r\n    // if (multiPolygons === undefined) return;\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n    // const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.MeshBasicMaterial( { vertexColors: true } );\r\n    const meshes = []\r\n\r\n    const positions = [];\r\n\r\n\r\n    for (let multi = 0; multi < paths.length; ++multi) {\r\n        const multiPolygon = paths[multi];\r\n\r\n        for (let polyI = 0; polyI < multiPolygon.length; ++polyI) {\r\n            const polygon = multiPolygon[polyI];\r\n\r\n\r\n\r\n            if (polygon.length === 1) {\r\n                const thePolygon = polygon[0];\r\n\r\n                const shape = [];\r\n\r\n                for (let i = 0; i < thePolygon.length; ++i) {\r\n\r\n                    const [xPro, yPro] = MercatorProjection(thePolygon[i][0], thePolygon[i][1]);\r\n\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n                    // console.log(x, y)\r\n                    positions.push(x, 0, y)\r\n\r\n                    shape.push(new THREE.Vector2(x, y));\r\n                }\r\n\r\n\r\n                let geometry = new THREE.ShapeGeometry(new THREE.Shape(shape));\r\n                let mat = new THREE.MeshBasicMaterial({\r\n                    side: THREE.DoubleSide, color: 0x00ff00,\r\n                    transparent: true,\r\n                    opacity: 0.3\r\n                });\r\n                let mesh = new THREE.Mesh(geometry, mat);\r\n                scene.add(mesh);\r\n                meshes.push(mesh);\r\n                mesh.rotateOnAxis(new THREE.Vector3(1, 0, 0), Math.PI * 0.5);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n    return meshes;\r\n};\r\n\r\nconst renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.5 });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.Points(geometry, material);\r\n    scene.add(line);\r\n\r\n\r\n}\r\n\r\nconst renderLines = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n\r\n    const geometry = new THREE.BufferGeometry();\r\n    // const material = new THREE.PointsMaterial( { vertexColors: true, size: 0.1 } );\r\n    const material = new THREE.LineBasicMaterial({ vertexColors: true });\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                if (k < route[j].length - 1) {\r\n                    indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //     console.log(xC / Count, yC / Count, Count)\r\n    geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    // generateMorphTargets( geometry );\r\n\r\n    geometry.computeBoundingSphere();\r\n\r\n    const line = new THREE.LineSegments(geometry, material);\r\n    scene.add(line);\r\n};"],"names":["FilterGLViewDarkForDarken","constructor","gl","program","fragmentShader","vertexShader","matrixLocation","posBuffer","colBuffer","vertexs","posLocAtt","colLocAtt","matLoc","colLoc","cVecLoc","mouseLoc","timeGL","vShader","fShader","v","f","positionAttribLocation","colorAttribLocation","translation","color","colArray","this","Math","random","InitShader","GLShaderCommon","VERTEX_SHADER","FRAGMENT_SHADER","Render","col","Float32Array","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","type","FLOAT","stride","BYTES_PER_ELEMENT","offset","vertexAttribPointer","enableVertexAttribArray","useProgram","primitiveType","TRIANGLES","drawArrays","Solution","RendererThree","super","streetOSM","routesTreated","routesControl","zones30","meshArea","raycaster","THREE","pointer","sphere","light","camera","add","scene","params","Mesh","threshold","far","sphereGeometry","sphereMaterial","canvasGL","document","createElement","style","position","pointerEvents","mixBlendMode","width","hostDiv","clientWidth","height","clientHeight","appendChild","glCtx","getContext","set","getJSONFromURL","then","data","i","length","push","renderPoints","renderMultiPolygon","start","update","setFromCamera","intersects","intersectObjects","visible","copy","point","mouseMove","e","x","offsetX","y","offsetY","mouseDown","getObjectById","object","id","material","r","paths","colorArray","meshes","positions","multi","multiPolygon","polyI","polygon","thePolygon","shape","xPro","yPro","MercatorProjection","geometry","mat","side","transparent","opacity","mesh","rotateOnAxis","PI","vertexColors","size","colors","route","j","k","setAttribute","computeBoundingSphere","line"],"sourceRoot":""}