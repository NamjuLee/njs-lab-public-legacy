{"version":3,"file":"static/js/93926.732381bf.chunk.js","mappings":"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","sources":["../node_modules/@deck.gl/core/src/lib/composite-layer.js","../node_modules/@luma.gl/core/node_modules/@luma.gl/shadertools/src/modules/lights/lights.glsl.js","../node_modules/@luma.gl/core/node_modules/@luma.gl/shadertools/src/modules/lights/lights.js","../node_modules/@luma.gl/core/node_modules/@luma.gl/shadertools/src/modules/phong-lighting/phong-lighting.glsl.js","../node_modules/@luma.gl/core/node_modules/@luma.gl/shadertools/src/modules/phong-lighting/phong-lighting.js","../node_modules/@math.gl/polygon/src/polygon-utils.ts","../node_modules/@math.gl/polygon/src/lineclip.ts","../node_modules/@math.gl/polygon/src/utils.ts","../node_modules/@math.gl/polygon/src/cut-by-grid.ts","../node_modules/@math.gl/polygon/src/cut-by-mercator-bounds.ts","../node_modules/@deck.gl/layers/src/solid-polygon-layer/polygon.js","../node_modules/@deck.gl/core/src/utils/tesselator.js","../node_modules/@deck.gl/layers/src/solid-polygon-layer/polygon-tesselator.js","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer.js","../node_modules/@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js","../node_modules/@deck.gl/layers/src/path-layer/path.js","../node_modules/@deck.gl/layers/src/path-layer/path-tesselator.js","../node_modules/@deck.gl/layers/src/path-layer/path-layer-vertex.glsl.js","../node_modules/@deck.gl/layers/src/path-layer/path-layer.js","../node_modules/@deck.gl/layers/src/path-layer/path-layer-fragment.glsl.js","../node_modules/@deck.gl/layers/src/polygon-layer/polygon-layer.js","../node_modules/@deck.gl/layers/src/utils.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport Layer from './layer';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\n\nconst TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';\n\nexport default class CompositeLayer extends Layer {\n  get isComposite() {\n    return true;\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);\n  }\n\n  getSubLayers() {\n    return (this.internalState && this.internalState.subLayers) || [];\n  }\n\n  // initializeState is usually not needed for composite layers\n  // Provide empty definition to disable check for missing definition\n  initializeState() {}\n\n  // Updates selected state members and marks the composite layer to need rerender\n  setState(updateObject) {\n    super.setState(updateObject);\n    // Trigger a layer update\n    // Although conceptually layer.draw and compositeLayer.renderLayers are equivalent,\n    // they are executed during different lifecycles.\n    // draw can be called without calling updateState (e.g. most viewport changes),\n    // while renderLayers can only be called during a recursive layer update.\n    this.setNeedsUpdate();\n  }\n\n  // called to augment the info object that is bubbled up from a sublayer\n  // override Layer.getPickingInfo() because decoding / setting uniform do\n  // not apply to a composite layer.\n  // @return null to cancel event\n  getPickingInfo({info}) {\n    const {object} = info;\n    const isDataWrapped =\n      object && object.__source && object.__source.parent && object.__source.parent.id === this.id;\n\n    if (!isDataWrapped) {\n      return info;\n    }\n\n    // override object with picked data\n    info.object = object.__source.object;\n    info.index = object.__source.index;\n\n    return info;\n  }\n\n  // Implement to generate subLayers\n  renderLayers() {\n    return null;\n  }\n\n  /**\n   * Filters sub layers at draw time\n   * @param {Layer} context.layer - sub layer instance\n   * @param {Viewport} context.viewport - the viewport being rendered in\n   * @param {Boolean} context.isPicking - whether it is a picking pass\n   * @param {String} context.pass - the current pass\n   * @return {Boolean} true if the sub layer should be drawn\n   */\n  filterSubLayer(context) {\n    return true;\n  }\n\n  // Returns true if sub layer needs to be rendered\n  shouldRenderSubLayer(id, data) {\n    return data && data.length;\n  }\n\n  // Returns sub layer class for a specific sublayer\n  getSubLayerClass(id, DefaultLayerClass) {\n    const {_subLayerProps: overridingProps} = this.props;\n\n    return (\n      (overridingProps && overridingProps[id] && overridingProps[id].type) || DefaultLayerClass\n    );\n  }\n\n  // When casting user data into another format to pass to sublayers,\n  // add reference to the original object and object index\n  getSubLayerRow(row, sourceObject, sourceObjectIndex) {\n    row.__source = {\n      parent: this,\n      object: sourceObject,\n      index: sourceObjectIndex\n    };\n    return row;\n  }\n\n  // Some composite layers cast user data into another format before passing to sublayers\n  // We need to unwrap them before calling the accessor so that they see the original data\n  // objects\n  getSubLayerAccessor(accessor) {\n    if (typeof accessor === 'function') {\n      const objectInfo = {\n        data: this.props.data,\n        target: []\n      };\n      return (x, i) => {\n        if (x && x.__source) {\n          objectInfo.index = x.__source.index;\n          return accessor(x.__source.object, objectInfo);\n        }\n        return accessor(x, i);\n      };\n    }\n    return accessor;\n  }\n\n  // Returns sub layer props for a specific sublayer\n  // eslint-disable-next-line complexity\n  getSubLayerProps(sublayerProps = {}) {\n    const {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch,\n      _subLayerProps: overridingProps\n    } = this.props;\n    const newProps = {\n      opacity,\n      pickable,\n      visible,\n      parameters,\n      getPolygonOffset,\n      highlightedObjectIndex,\n      autoHighlight,\n      highlightColor,\n      coordinateSystem,\n      coordinateOrigin,\n      wrapLongitude,\n      positionFormat,\n      modelMatrix,\n      extensions,\n      fetch\n    };\n\n    const overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];\n    const overridingSublayerTriggers =\n      overridingSublayerProps && overridingSublayerProps.updateTriggers;\n    const sublayerId = sublayerProps.id || 'sublayer';\n\n    if (overridingSublayerProps) {\n      const propTypes = this.constructor._propTypes;\n      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};\n      for (const key in overridingSublayerProps) {\n        const propType = subLayerPropTypes[key] || propTypes[key];\n        // eslint-disable-next-line\n        if (propType && propType.type === 'accessor') {\n          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);\n        }\n      }\n    }\n\n    Object.assign(\n      newProps,\n      sublayerProps,\n      // experimental feature that allows users to override sublayer props via parent layer prop\n      overridingSublayerProps\n    );\n    newProps.id = `${this.props.id}-${sublayerId}`;\n    newProps.updateTriggers = {\n      all: this.props.updateTriggers.all,\n      ...sublayerProps.updateTriggers,\n      ...overridingSublayerTriggers\n    };\n\n    // Pass through extension props\n    for (const extension of extensions) {\n      const passThroughProps = extension.getSubLayerProps.call(this, extension);\n      if (passThroughProps) {\n        Object.assign(newProps, passThroughProps, {\n          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)\n        });\n      }\n    }\n\n    return newProps;\n  }\n\n  _updateAutoHighlight(info) {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  _getAttributeManager() {\n    return null;\n  }\n\n  // Called by layer manager to render subLayers\n  _renderLayers() {\n    let {subLayers} = this.internalState;\n    const shouldUpdate = !subLayers || this.needsUpdate();\n    if (shouldUpdate) {\n      subLayers = this.renderLayers();\n      // Flatten the returned array, removing any null, undefined or false\n      // this allows layers to render sublayers conditionally\n      // (see CompositeLayer.renderLayers docs)\n      subLayers = flatten(subLayers, Boolean);\n      this.internalState.subLayers = subLayers;\n    }\n    debug(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);\n\n    // populate reference to parent layer (this layer)\n    // NOTE: needs to be done even when reusing layers as the parent may have changed\n    for (const layer of subLayers) {\n      layer.parent = this;\n    }\n  }\n}\n\nCompositeLayer.layerName = 'CompositeLayer';\n","export default `\\\n#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n\n // Constant-Linear-Exponential\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n`;\n","/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport lightingShader from './lights.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {\n  lightSources: {}\n};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    // @ts-ignore\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n\n/** @type {ShaderModule} */\nexport const lights = {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n","export default `\\\n\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n`;\n","/** @typedef {import('../../types').ShaderModule} ShaderModule */\n\nimport {lights} from '../lights/lights';\nimport lightingShader from './phong-lighting.glsl';\n\nconst INITIAL_MODULE_OPTIONS = {};\n\nfunction getMaterialUniforms(material) {\n  const {ambient = 0.35, diffuse = 0.6, shininess = 32, specularColor = [30, 30, 30]} = material;\n\n  return {\n    lighting_uAmbient: ambient,\n    lighting_uDiffuse: diffuse,\n    lighting_uShininess: shininess,\n    lighting_uSpecularColor: specularColor.map(x => x / 255)\n  };\n}\n\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  if (!('material' in opts)) {\n    return {};\n  }\n\n  const {material} = opts;\n\n  if (!material) {\n    return {lighting_uEnabled: false};\n  }\n\n  return getMaterialUniforms(material);\n}\n\n/** @type {ShaderModule} */\nexport const gouraudLighting = {\n  name: 'gouraud-lighting',\n  dependencies: [lights],\n  vs: lightingShader,\n  defines: {\n    LIGHTING_VERTEX: 1\n  },\n  getUniforms\n};\n\n/** @type {ShaderModule} */\nexport const phongLighting = {\n  name: 'phong-lighting',\n  dependencies: [lights],\n  fs: lightingShader,\n  defines: {\n    LIGHTING_FRAGMENT: 1\n  },\n  getUniforms\n};\n","/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  start?: number; // Start index of the polygon in the array of positions. Defaults to 0.\n  end?: number; // End index of the polygon in the array of positions. Defaults to number of positions.\n  size?: number; // Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays.\n  isClosed?: boolean; // Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n","/*\n  Adapted from https://github.com/mapbox/lineclip to work with flat arrays\n  and 3d positions\n\n  ISC License\n\n  Copyright (c) 2015, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n/* eslint-disable max-statements, max-depth, complexity */\n\nimport {push, copy, getPointAtIndex} from './utils';\nimport type {NumericArray} from '@math.gl/core';\n\nexport type BoundingBox = [number, number, number, number];\n\n/**\n * Cohen-Sutherland line clipping algorithm, adapted to efficiently\n * handle polylines rather than just segments\n */\nexport function clipPolyline(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length} = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result: number[][] = [];\n  let part: number[] = [];\n  let a: number[];\n  let b: number[];\n  let codeA: number = -1;\n  let codeB: number;\n  let lastCode: number;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n    codeB = lastCode = bitCode(b, bbox);\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (!(codeA | codeB)) {\n        // accept\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          // segment went outside\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            // start a new line\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        // trivial reject\n        break;\n      } else if (codeA) {\n        // a outside, intersect with clip edge\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        // b outside\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n\n  return result;\n}\n\n/**\n * Sutherland-Hodgeman polygon clipping algorithm\n * polygon must be closed (first vertex == last vertex)\n */\nexport function clipPolygon(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] {\n  const {size = 2, endIndex = positions.length} = options || {};\n  let {startIndex = 0} = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result: number[];\n  let p: number[];\n  let prev: number[];\n  let inside: boolean;\n  let prevInside: boolean;\n\n  // clip against each side of the clip rectangle\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n\n      // if segment goes through the clip window, add an intersection\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n\n      if (inside) push(result, p); // add a point if it's inside\n\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    // close loop\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n\n    if (!numPoints) break;\n  }\n\n  return result;\n}\n\n/** intersect a segment against one of the 4 lines that make up the bbox */\n\nexport function intersect(\n  a: number[],\n  b: number[],\n  edge: number,\n  bbox: BoundingBox,\n  out: number[] = []\n): number[] {\n  let t;\n  // Forces out[snapI] to be on the bbox edge\n  // Interpolation introduces precision issue which may cause lineclip to be\n  // stuck in an infinite loop\n  let snap: number;\n  if (edge & 8) {\n    // top\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    // bottom\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    // right\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    // left\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n  return out;\n}\n\n/**\n * bit code reflects the point position relative to the bbox:\n *         left  mid  right\n *    top  1001  1000  1010\n *    mid  0001  0000  0010\n * bottom  0101  0100  0110\n */\nexport function bitCode(p: number[], bbox: BoundingBox): number {\n  let code = 0;\n\n  if (p[0] < bbox[0]) code |= 1;\n  // left\n  else if (p[0] > bbox[2]) code |= 2; // right\n\n  if (p[1] < bbox[1]) code |= 4;\n  // bottom\n  else if (p[1] > bbox[3]) code |= 8; // top\n\n  return code;\n}\n","import type {NumericArray} from '@math.gl/core';\n\nexport function push(target: number[], source: number[]): boolean {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target: number[], source: Readonly<NumericArray>): void {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(\n  positions: Readonly<NumericArray>,\n  index: number,\n  size: number,\n  offset: number,\n  out: number[] = []\n): number[] {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n","/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect, BoundingBox} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport type Polygon = {\n  positions: Readonly<NumericArray>;\n  holeIndices?: Readonly<NumericArray>;\n  edgeTypes?: Readonly<NumericArray>;\n};\n\nexport function cutPolylineByGrid(\n  positions: NumericArray,\n  options?: {\n    size?: number;\n    broken?: boolean;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] | number[][] {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part: number[] = [];\n  const result: number[][] = [part];\n  const a: number[] = getPointAtIndex(positions, 0, size, startIndex);\n  let b: number[];\n  let codeB: number;\n  const cell: BoundingBox = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint: number[] = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1: number[], arr2: number[]): number[] {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n\nexport function cutPolygonByGrid(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options || {};\n  const result: Polygon[] = [];\n  const queue: {pos: Readonly<NumericArray>; types: number[]; holes: Readonly<NumericArray>}[] = [\n    {\n      pos: positions,\n      types: edgeTypes ? (new Array(positions.length / size).fill(TYPE_BORDER) as number[]) : null,\n      holes: holeIndices || []\n    }\n  ];\n  const bbox: number[][] = [[], []];\n  // @ts-ignore\n  let cell: BoundingBox = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon: Polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(\n  positions: Readonly<NumericArray>,\n  edgeTypes: number[] | undefined,\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  bbox: BoundingBox,\n  edge: number\n): {\n  pos: number[];\n  types?: number[];\n}[] {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow: number[] = [];\n  const resultHigh: number[] = [];\n  const typesLow: number[] = [];\n  const typesHigh: number[] = [];\n  const scratchPoint: number[] = [];\n\n  let p: number[];\n  let side: number;\n  let type: number;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(\n  p: number[],\n  gridResolution: number,\n  gridOffset: [number, number],\n  out: number[]\n): BoundingBox {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out as BoundingBox;\n}\n\nfunction moveToNeighborCell(cell: number[], gridResolution: number, edge: number): void {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(\n  positions: Readonly<NumericArray>,\n  size: number,\n  endIndex: number,\n  out: number[][]\n): number[][] {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n","import {cutPolylineByGrid, cutPolygonByGrid} from './cut-by-grid';\nimport {getPointAtIndex, push} from './utils';\nimport type {Polygon} from './cut-by-grid';\nimport type {NumericArray} from '@math.gl/core';\n\n// https://en.wikipedia.org/wiki/Web_Mercator_projection\nconst DEFAULT_MAX_LATITUDE = 85.051129;\n\n/** https://user-images.githubusercontent.com/2059298/78465769-938b7a00-76ae-11ea-9b95-1f4c26425ab9.png */\nexport function cutPolylineByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n    normalize?: boolean;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length, normalize = true} = options || {};\n\n  // Remap longitudes so that each segment takes the shorter path\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  }) as number[][];\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n  return parts;\n}\n\n/** https://user-images.githubusercontent.com/2059298/78465770-94241080-76ae-11ea-809a-6a8534dac1d9.png */\nexport function cutPolygonByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    normalize?: boolean;\n    maxLatitude?: number;\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  const {size = 2, normalize = true, edgeTypes = false} = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions: number[] = [];\n  const newHoleIndices: number[] = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    // srcStartIndex/srcEndIndex define the ring in the original positions\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    // targetStartIndex/targetIndex define the ring in newPositions\n    const targetStartIndex = targetIndex;\n\n    // In case the ring contains a pole (e.g. Antarctica), we'll have to insert vertices\n    // The insertion point is defined by the vertex closest to the pole\n    // Split the the ring by the insertion point when copying to newPositions\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    // Remap longitudes so that each segment takes the shorter path\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n\n    // Handle the case when the ring contains a pole\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);\n\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n  newHoleIndices.pop();\n\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      // @ts-expect-error (mutates readonly array) May mutate newPositions, which is created by us\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n  return parts;\n}\n\n/* Helpers */\n\n// See comments for insertPoleVertices\nfunction findSplitIndex(\n  positions: Readonly<NumericArray>,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): number {\n  let maxLat = -1;\n  let pointIndex = -1;\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n  return pointIndex;\n}\n\n// https://user-images.githubusercontent.com/2059298/78857483-5987e400-79de-11ea-98fc-0631287a8431.png\n//\n// If the polygon contains a pole, to tesselate it correctly, we need to insert the edge\n// of map into the polygon. This requires adding two vertices that represent the pole, by\n// drawing a perpendicular line to the Mercator map edge from a selected vertex on the ring.\n//\n// We select the insertion position carefully so that the inserted line segments do not\n// intersect with the ring itself. This is ensured by findSplitIndex, which returns the\n// vertex closest to the pole.\nfunction insertPoleVertices(\n  positions: number[],\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  maxLatitude: number = DEFAULT_MAX_LATITUDE\n): void {\n  // Check if the ring contains a pole\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n  if (Math.abs(firstLng - lastLng) > 180) {\n    // The ring does not make a round trip\n    // Add the nearest pole to the vertices so that the polygon tesselates correctly\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    // Copy the first vertex to the world of the last vertex\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    // Project the copied vertex to the edge of the map\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    // Project the first vertex to the edge of the map\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(\n  positions: NumericArray,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): void {\n  let prevLng: number = positions[0];\n  let lng: number;\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions: NumericArray, size: number): void {\n  let refLng: number;\n  const pointCount = positions.length / size;\n\n  // Find a longitude that is not on the edge of a world\n  // Which we will use to determine which world copy it is\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n  if (delta === 0) {\n    return;\n  }\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\n\nconst windingOptions = {\n  isClosed: true\n};\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [windingDirection] - modify polygon to be of the specified winding direction\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @param {Number} [windingDirection] - modify polygon to be of the specified winding direction\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(\n  target,\n  targetStartIndex,\n  positions,\n  size,\n  srcStartIndex = 0,\n  srcEndIndex,\n  windingDirection\n) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n\n  const positions = [];\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i],\n          i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(\n        positions,\n        targetIndex,\n        simplePolygon,\n        positionSize,\n        polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n      );\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    const p = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value)); // invalid binary geometries\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n    }\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return (polygon.positions || polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, hasFeatures, FEATURES} from '@luma.gl/core';\n\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from './polygon-tesselator';\n\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  filled: true,\n  // Whether to extrude\n  extruded: false,\n  // Whether to draw a GL.LINES wireframe of the polygon\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n\n  // elevation multiplier\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // Accessor for polygon geometry\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  // Accessor for extrusion height\n  getElevation: {type: 'accessor', value: 1000},\n  // Accessor for colors\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // Optional settings for 'lighting' shader module\n  material: true\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class SolidPolygonLayer extends Layer {\n  getShaders(type) {\n    return super.getShaders({\n      vs: type === 'top' ? vsTop : vsSide,\n      fs,\n      defines: {\n        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1\n      },\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const {gl, viewport} = this.context;\n    let {coordinateSystem} = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat,\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n\n    attributeManager.remove(['instancePickingColors']);\n\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {size: 1, isIndexed: true, update: this.calculateIndices, noAlloc},\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        alias: 'colors',\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        alias: 'colors',\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {extruded, filled, wireframe, elevationScale} = this.props;\n    const {topModel, sideModel, polygonTesselator} = this.state;\n\n    const renderUniforms = {\n      ...uniforms,\n      extruded: Boolean(extruded),\n      elevationScale\n    };\n\n    // Note: the order is important\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n      if (wireframe) {\n        sideModel.setDrawMode(GL.LINE_STRIP);\n        sideModel.setUniforms({isWireframe: true}).draw();\n      }\n      if (filled) {\n        sideModel.setDrawMode(GL.TRIANGLE_FAN);\n        sideModel.setUniforms({isWireframe: false}).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n\n    this.updateGeometry(updateParams);\n\n    const {props, oldProps, changeFlags} = updateParams;\n    const attributeManager = this.getAttributeManager();\n\n    const regenerateModels =\n      changeFlags.extensionsChanged ||\n      props.filled !== oldProps.filled ||\n      props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      this.state.models?.forEach(model => model.delete());\n\n      this.setState(this._getModels(this.context.gl));\n      attributeManager.invalidateAll();\n    }\n  }\n\n  updateGeometry({props, oldProps, changeFlags}) {\n    const geometryConfigChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {polygonTesselator} = this.state;\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged\n      });\n\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n\n  _getModels(gl) {\n    const {id, filled, extruded} = this.props;\n\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders('top');\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n\n      topModel = new Model(gl, {\n        ...shaders,\n        id: `${id}-top`,\n        drawMode: GL.TRIANGLES,\n        attributes: {\n          vertexPositions: new Float32Array([0, 1])\n        },\n        uniforms: {\n          isWireframe: false,\n          isSideVertex: false\n        },\n        vertexCount: 0,\n        isIndexed: true\n      });\n    }\n    if (extruded) {\n      sideModel = new Model(gl, {\n        ...this.getShaders('side'),\n        id: `${id}-side`,\n        geometry: new Geometry({\n          drawMode: GL.LINES,\n          vertexCount: 4,\n          attributes: {\n            // top right - top left - bootom left - bottom right\n            vertexPositions: {\n              size: 2,\n              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n            }\n          }\n        }),\n        instanceCount: 0,\n        isInstanced: 1\n      });\n\n      sideModel.userData.excludeAttributes = {indices: true};\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  calculateIndices(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  calculatePositions(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\n\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","import {cutPolylineByGrid, cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\n/** Returns a flat array of path positions\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n */\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath = path;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {size, gridResolution});\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {size});\n  }\n  return flatPath;\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Tesselator} from '@deck.gl/core';\nimport {normalizePath} from './path';\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({\n      ...opts,\n      attributes: {\n        // Padding covers shaderAttributes for last segment in largest case fp64\n        // additional vertex + hi & low parts, 3 * 6\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {size: 1, type: Uint8ClampedArray}\n      }\n    });\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization\n    return () => null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n    return path;\n  }\n\n  /* Getters */\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  getGeometrySize(path) {\n    if (Array.isArray(path[0])) {\n      let size = 0;\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n      return size;\n    }\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n    if (path && Array.isArray(path[0])) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const {segmentTypes} = this.attributes;\n    const isPathClosed = this.isClosed(path);\n    const {vertexStart, geometrySize} = context;\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {positions} = this.attributes;\n    if (!positions) {\n      return;\n    }\n    const {vertexStart, geometrySize} = context;\n    const p = new Array(3);\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  /* Utilities */\n  // Returns the number of points in the path\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  // Returns a point on the path at the specified index\n  getPointOnPath(path, index, target = []) {\n    const {positionSize} = this;\n    if (index * positionSize >= path.length) {\n      // loop\n      index += 1 - path.length / positionSize;\n    }\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = (positionSize === 3 && path[i + 2]) || 0;\n    return target;\n  }\n\n  // Returns true if the first and last points are identical\n  isClosed(path) {\n    if (!this.normalize) {\n      return this.opts.loop;\n    }\n    const {positionSize} = this;\n    const lastPointIndex = path.length - positionSize;\n    return (\n      path[0] === path[lastPointIndex] &&\n      path[1] === path[lastPointIndex + 1] &&\n      (positionSize === 2 || path[2] === path[lastPointIndex + 2])\n    );\n  }\n}\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking, log, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport PathTesselator from './path-tesselator';\n\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {type: 'number', min: 0, value: 1}, // stroke width in meters\n  widthMinPixels: {type: 'number', min: 0, value: 0}, //  min stroke width in pixels\n  widthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max stroke width in pixels\n  jointRounded: false,\n  capRounded: false,\n  miterLimit: {type: 'number', min: 0, value: 4},\n  billboard: false,\n  // `loop` or `open`\n  _pathType: null,\n\n  getPath: {type: 'accessor', value: object => object.path},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1},\n\n  // deprecated props\n  rounded: {deprecatedFor: ['jointRounded', 'capRounded']}\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class PathLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]}); // 'project' module added by default.\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      positions: {\n        size: 3,\n        // Start filling buffer from 1 vertex in\n        vertexOffset: 1,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    /* eslint-enable max-len */\n\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n\n    if (this.props.getDashArray && !this.props.extensions.length) {\n      log.removed('getDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath));\n\n    if (geometryChanged) {\n      const {pathTesselator} = this.state;\n      const buffers = props.data.attributes || {};\n\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  disablePickingIndex(objectIndex) {\n    const {data} = this.props;\n\n    // Check if data comes from a composite layer, wrapped with getSubLayerRow\n    if (data[0] && data[0].__source) {\n      // index decoded from picking color refers to the source index\n      for (let i = 0; i < data.length; i++) {\n        if (data[i].__source.index === objectIndex) {\n          this._disablePickingIndex(i);\n        }\n      }\n    } else {\n      this._disablePickingIndex(objectIndex);\n    }\n  }\n\n  draw({uniforms}) {\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        jointType: Number(jointRounded),\n        capType: Number(capRounded),\n        billboard,\n        widthUnits: UNIT[widthUnits],\n        widthScale,\n        miterLimit,\n        widthMinPixels,\n        widthMaxPixels\n      })\n      .draw();\n  }\n\n  _getModel(gl) {\n    /*\n     *       _\n     *        \"-_ 1                   3                       5\n     *     _     \"o---------------------o-------------------_-o\n     *       -   / \"\"--..__              '.             _.-' /\n     *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n     *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n     *       \"o----------------------------\"\"-o'    :     /\n     *      0,2                            4 / '.  :     /\n     *                                      /   '.:     /\n     *                                     /     :'.   /\n     *                                    /     :  ', /\n     *                                   /     :     o\n     */\n\n    // prettier-ignore\n    const SEGMENT_INDICES = [\n      // start corner\n      0, 1, 2,\n      // body\n      1, 4, 2,\n      1, 3, 4,\n      // end corner\n      3, 5, 4\n    ];\n\n    // [0] position on segment - 0: start, 1: end\n    // [1] side of path - -1: left, 0: center (joint), 1: right\n    // prettier-ignore\n    const SEGMENT_POSITIONS = [\n      // bevel start corner\n      0, 0,\n      // start inner corner\n      0, -1,\n      // start outer corner\n      0, 1,\n      // end inner corner\n      1, -1,\n      // end outer corner\n      1, 1,\n      // bevel end corner\n      1, 0\n    ];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: {\n          indices: new Uint16Array(SEGMENT_INDICES),\n          positions: {value: new Float32Array(SEGMENT_POSITIONS), size: 2}\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  calculatePositions(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  calculateSegmentTypes(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n}\n\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n","// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable, log} from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport {replaceInRange} from '../utils';\n\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\n\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n  _windingOrder: 'CW',\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  // Polygon fill color\n  getFillColor: {type: 'accessor', value: defaultFillColor},\n  // Point, line and polygon outline color\n  getLineColor: {type: 'accessor', value: defaultLineColor},\n  // Line and polygon outline accessors\n  getLineWidth: {type: 'accessor', value: 1},\n  // Polygon extrusion accessor\n  getElevation: {type: 'accessor', value: 1000},\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\nexport default class PolygonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      paths: []\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange =>\n        replaceInRange({\n          data: paths,\n          getIndex: p => p.__source.index,\n          dataRange,\n          replace: this._getPaths(dataRange)\n        })\n      );\n      this.setState({paths, pathsDiff});\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n\n  _getPaths(dataRange = {}) {\n    const {data, getPolygon, positionFormat, _normalize} = this.props;\n    const paths = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {startRow, endRow} = dataRange;\n\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n      if (_normalize) {\n        polygon = Polygon.normalize(polygon, positionSize);\n      }\n      const {holeIndices} = polygon;\n      const positions = polygon.positions || polygon;\n\n      if (holeIndices) {\n        // split the positions array into `holeIndices.length + 1` rings\n        // holeIndices[-1] falls back to 0\n        // holeIndices[holeIndices.length] falls back to positions.length\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({path}, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({path: positions}, object, objectInfo.index));\n      }\n    }\n    return paths;\n  }\n\n  /* eslint-disable complexity */\n  renderLayers() {\n    // Layer composition props\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      _windingOrder,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n\n    // Rendering props underlying layer\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n\n    // Accessor props for underlying layers\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n\n    const {paths, pathsDiff} = this.state;\n\n    const FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n    const StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n\n    // Filled Polygon Layer\n    const polygonLayer =\n      this.shouldRenderSubLayer('fill', paths) &&\n      new FillLayer(\n        {\n          _dataDiff,\n          extruded,\n          elevationScale,\n\n          filled,\n          wireframe,\n          _normalize,\n          _windingOrder,\n\n          getElevation,\n          getFillColor,\n          getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,\n\n          material,\n          transitions\n        },\n        this.getSubLayerProps({\n          id: 'fill',\n          updateTriggers: {\n            getPolygon: updateTriggers.getPolygon,\n            getElevation: updateTriggers.getElevation,\n            getFillColor: updateTriggers.getFillColor,\n            // using a legacy API to invalid lineColor attributes\n            // if (extruded && wireframe) has changed\n            lineColors: extruded && wireframe,\n            getLineColor: updateTriggers.getLineColor\n          }\n        }),\n        {\n          data,\n          positionFormat,\n          getPolygon\n        }\n      );\n\n    // Polygon line layer\n    const polygonLineLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer('stroke', paths) &&\n      new StrokeLayer(\n        {\n          _dataDiff: pathsDiff && (() => pathsDiff),\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          jointRounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          // Already normalized\n          _pathType: 'loop',\n\n          transitions: transitions && {\n            getWidth: transitions.getLineWidth,\n            getColor: transitions.getLineColor,\n            getPath: transitions.getPolygon\n          },\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray)\n        },\n        this.getSubLayerProps({\n          id: 'stroke',\n          updateTriggers: {\n            getWidth: updateTriggers.getLineWidth,\n            getColor: updateTriggers.getLineColor,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        {\n          data: paths,\n          positionFormat,\n          getPath: x => x.path\n        }\n      );\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonLayer,\n      polygonLineLayer,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonLayer\n    ];\n  }\n  /* eslint-enable complexity */\n}\n\nPolygonLayer.layerName = 'PolygonLayer';\nPolygonLayer.defaultProps = defaultProps;\n","// Assume data array is sorted by <accessor>\n// Replaces the specified range with a new subarray\n// Mutates the data array\n// Returns {startRow, endRow} of the inserted items\nexport function replaceInRange({data, getIndex, dataRange, replace}) {\n  const {startRow = 0, endRow = Infinity} = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  // Save the items after replaceEnd before we overwrite data\n  const endChunk = dataLengthChanged && data.slice(replaceEnd);\n  // Insert new items\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n  if (dataLengthChanged) {\n    // Append items after replaceEnd\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n    // Trim additional items\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n"],"names":["CompositeLayer","Layer","isComposite","isLoaded","super","this","getSubLayers","every","layer","internalState","subLayers","initializeState","setState","updateObject","setNeedsUpdate","getPickingInfo","info","object","__source","parent","id","index","renderLayers","filterSubLayer","context","shouldRenderSubLayer","data","length","getSubLayerClass","DefaultLayerClass","_subLayerProps","overridingProps","props","type","getSubLayerRow","row","sourceObject","sourceObjectIndex","getSubLayerAccessor","accessor","objectInfo","target","x","i","getSubLayerProps","sublayerProps","opacity","pickable","visible","parameters","getPolygonOffset","highlightedObjectIndex","autoHighlight","highlightColor","coordinateSystem","coordinateOrigin","wrapLongitude","positionFormat","modelMatrix","extensions","fetch","newProps","overridingSublayerProps","overridingSublayerTriggers","updateTriggers","sublayerId","propTypes","constructor","_propTypes","subLayerPropTypes","key","propType","Object","assign","all","extension","passThroughProps","call","_updateAutoHighlight","updateAutoHighlight","_getAttributeManager","_renderLayers","shouldUpdate","needsUpdate","flatten","Boolean","debug","layerName","INITIAL_MODULE_OPTIONS","lightSources","convertColor","color","intensity","map","component","lights","name","vs","lightingShader","fs","getUniforms","opts","ambientLight","pointLights","directionalLights","lightSourceUniforms","forEach","pointLight","position","attenuation","lighting_uPointLightCount","directionalLight","direction","lighting_uDirectionalLightCount","getLightSourceUniforms","lighting_uEnabled","light","push","defines","MAX_LIGHTS","material","ambient","diffuse","shininess","specularColor","lighting_uAmbient","lighting_uDiffuse","lighting_uShininess","lighting_uSpecularColor","getMaterialUniforms","gouraudLighting","dependencies","LIGHTING_VERTEX","WINDING","modifyPolygonWindingDirection","points","options","windingDirection","Math","sign","start","end","dim","size","area","j","getPolygonSignedArea","getPolygonWindingDirection","numPoints","numSwaps","floor","b1","b2","tmp","reversePolygon","intersect","a","b","edge","bbox","t","snap","out","bitCode","p","code","source","startIndex","isDuplicate","copy","getPointAtIndex","positions","offset","startI","cutPolylineByGrid","broken","gridResolution","gridOffset","endIndex","part","result","codeB","cell","getGridCell","scratchPoint","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","shift","getBoundingBox","parts","bisectPolygon","polygonLow","polygonHigh","polygon","resultLow","resultHigh","typesLow","typesHigh","side","prev","prevSide","prevType","lowPointCount","highPointCount","left","bottom","minX","Infinity","maxX","minY","maxY","y","DEFAULT_MAX_LATITUDE","findSplitIndex","maxLat","pointIndex","lat","abs","insertPoleVertices","maxLatitude","firstLng","lastLng","round","wrapLongitudesForShortestPath","lng","prevLng","delta","shiftLongitudesIntoRange","refLng","pointCount","OUTER_POLYGON_WINDING","HOLE_POLYGON_WINDING","windingOptions","isClosed","copyNestedRing","targetStartIndex","simplePolygon","targetIndex","len","p0","p1","isNestedRingClosed","copyFlatRing","srcStartIndex","srcEndIndex","srcLength","isFlatRingClosed","normalize","positionSize","isArray","ArrayBuffer","isView","Error","validate","srcPositions","srcHoleIndices","pop","Number","isFinite","isSimple","polygonIndex","entries","Tesselator","attributes","typedArrayManager","defaultTypedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","seal","buffers","getGeometry","geometryBuffer","dataChanged","assert","startIndices","getGeometryFromBuffer","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","normalizeGeometry","geometry","updateGeometryAttributes","getGeometrySize","value","getAccessorFromBuffer","stride","_allocate","release","def","allocate","_forEachGeometry","visitor","iterable","createIterable","normalizedData","dataIndex","buffer","Buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","PolygonTesselator","fp64","IndexType","Uint32Array","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","externalIndices","Polygon","resolution","newPositions","newHoleIndices","ringIndex","splitIndex","cutPolygonByMercatorBounds","subPolygon","_updateIndices","_updatePositions","_updateVertexValid","normalizedPolygon","preproject","positionIndex","n","slice","xy","earcut","polygonPositions","z","set","main","DEFAULT_COLOR","defaultProps","filled","extruded","wireframe","_normalize","_windingOrder","elevationScale","min","getPolygon","f","getElevation","getFillColor","getLineColor","ATTRIBUTE_TRANSITION","enter","chunk","SolidPolygonLayer","getShaders","vsTop","vsSide","RING_WINDING_ORDER_CW","modules","project32","picking","gl","viewport","isGeospatial","COORDINATE_SYSTEM","numInstances","polygonTesselator","projectFlat","use64bitPositions","hasFeatures","FEATURES","Uint16Array","attributeManager","getAttributeManager","noAlloc","remove","add","isIndexed","update","calculateIndices","transition","calculatePositions","shaderAttributes","vertexOffset","divisor","instancePositions","nextPositions","calculateVertexValid","elevations","instanceElevations","fillColors","alias","colorFormat","normalized","defaultValue","instanceFillColors","lineColors","instanceLineColors","pickingColors","encodePickingColor","instancePickingColors","params","find","d","disablePickingIndex","objectIndex","_disablePickingIndex","draw","uniforms","topModel","sideModel","state","renderUniforms","setInstanceCount","setUniforms","setDrawMode","isWireframe","setVertexCount","updateState","updateParams","oldProps","changeFlags","extensionsChanged","models","model","delete","_getModels","invalidateAll","updateTriggersChanged","shaders","NON_INSTANCED_MODEL","Model","drawMode","vertexPositions","isSideVertex","Geometry","isInstanced","userData","excludeAttributes","filter","attribute","normalizePath","path","flatPath","cutPolylineByMercatorBounds","PathTesselator","padding","initialize","segmentTypes","subPath","getPathLength","_updateSegmentTypes","isPathClosed","ptIndex","getPointOnPath","loop","lastPointIndex","widthUnits","widthScale","widthMinPixels","widthMaxPixels","MAX_SAFE_INTEGER","jointRounded","capRounded","miterLimit","billboard","_pathType","getPath","getColor","getWidth","rounded","deprecatedFor","PathLayer","addInstanced","instanceLeftPositions","instanceStartPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","instanceColors","pathTesselator","getDashArray","log","_getModel","jointType","capType","UNIT","defaultLineColor","stroked","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineJointRounded","lineMiterLimit","getLineWidth","PolygonLayer","paths","getLineDashArray","geometryChanged","pathsDiff","getIndex","replace","count","replaceStart","replaceEnd","dataLengthChanged","endChunk","replaceInRange","_getPaths","_dataDiff","transitions","lineDashJustified","FillLayer","StrokeLayer","polygonLayer","dashJustified"],"sourceRoot":""}