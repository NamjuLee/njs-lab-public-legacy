"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[57663],{57663:(e,a,i)=>{i.r(a),i.d(a,{classBreaks:()=>I,heatmapStatistics:()=>z,histogram:()=>x,summaryStatistics:()=>v,uniqueValues:()=>p});i(59486),i(10064);var n=i(92026),t=i(17842),l=i(78952),o=i(58971),s=i(92975),r=(i(80031),i(27811)),u=i(71486),f=i(819),m=i(585);let d=null;async function c(e,a){if(!a)return[];const{field:i,field2:n,field3:t,fieldDelimiter:o}=e,s=e.valueExpression,r=e.normalizationType,m=e.normalizationField,c=e.normalizationTotal,v=[],p=e.viewInfoParams;let I=null,x=null;if(s){if(!d){const{arcadeUtils:e}=await(0,f.LC)();d=e}I=d.createFunction(s),x=p&&d.getViewInfo({viewingMode:p.viewingMode,scale:p.scale,spatialReference:new l.Z(p.spatialReference)})}const z=e.fieldInfos,y=a[0]&&"declaredClass"in a[0]&&"esri.Graphic"===a[0].declaredClass||!z?null:{fields:z};return a.forEach((e=>{const a=e.attributes;let l;if(s){const a=y?{...e,layer:y}:e,i=d.createExecContext(a,x);l=d.executeFunction(I,i)}else a&&(l=a[i],n&&(l="".concat((0,u.wk)(l)).concat(o).concat((0,u.wk)(a[n])),t&&(l="".concat(l).concat(o).concat((0,u.wk)(a[t])))));if(r&&"number"==typeof l&&isFinite(l)){const e=a&&parseFloat(a[m]);l=(0,u.fk)(l,r,e,c)}v.push(l)})),v}async function v(e){const{attribute:a,features:i}=e,{normalizationType:n,normalizationField:t,minValue:l,maxValue:o,fieldType:s}=a,r=await c({field:a.field,valueExpression:a.valueExpression,normalizationType:n,normalizationField:t,normalizationTotal:a.normalizationTotal,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i),f=(0,u.S5)({normalizationType:n,normalizationField:t,minValue:l,maxValue:o}),m={value:.5,fieldType:s},d="esriFieldTypeString"===s?(0,u.H0)({values:r,supportsNullCount:f,percentileParams:m}):(0,u.i5)({values:r,minValue:l,maxValue:o,useSampleStdDev:!n,supportsNullCount:f,percentileParams:m});return(0,u.F_)(d,"esriFieldTypeDate"===s)}async function p(e){const{attribute:a,features:i}=e,n=await c({field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:a.fieldDelimiter,valueExpression:a.valueExpression,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i),t=(0,u.eT)(n);return(0,u.Qm)(t,a.domains,a.returnAllCodedValues,a.fieldDelimiter)}async function I(e){const{attribute:a,features:i}=e,{field:n,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:s}=a,r=await c({field:n,valueExpression:a.valueExpression,normalizationType:t,normalizationField:l,normalizationTotal:o,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i),f=(0,u.G2)(r,{field:n,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:s,standardDeviationInterval:a.standardDeviationInterval,numClasses:a.numClasses,minValue:a.minValue,maxValue:a.maxValue});return(0,u.DL)(f,s)}async function x(e){const{attribute:a,features:i}=e,{field:n,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:s}=a,r=await c({field:n,valueExpression:a.valueExpression,normalizationType:t,normalizationField:l,normalizationTotal:o,viewInfoParams:a.viewInfoParams,fieldInfos:a.fieldInfos},i);return(0,u.oF)(r,{field:n,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:s,standardDeviationInterval:a.standardDeviationInterval,numBins:a.numBins,minValue:a.minValue,maxValue:a.maxValue})}async function z(e){const{attribute:a,features:i}=e,{field:l,radius:u,fieldOffset:f,transform:d,spatialReference:c,size:v}=a,p=function(e,a,i,t){const l=(0,s.MP)(i)?(0,s.C5)(i):null,r=l?Math.round((l.valid[1]-l.valid[0])/a.scale[0]):null;return e.map((e=>{const i=new m.Z((0,n.Wg)(e.geometry));return(0,o.RF)(a,i,i,i.hasZ,i.hasM),e.geometry=l?function(e,a,i){return e.x<0?e.x+=a:e.x>i&&(e.x-=a),e}(i,r,t[0]):i,e}))}(i,d,c,v),{count:I,min:x,max:z,mean:y,stdDev:T}=function(e){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:18,i=arguments.length>2?arguments[2]:void 0,n=arguments.length>3?arguments[3]:void 0,l=arguments.length>4?arguments[4]:void 0,o=arguments.length>5?arguments[5]:void 0;const s=new Float64Array(l*o);a=Math.round((0,t.F2)(a));let u=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY,m=0,d=0,c=0,v=0;const p=(0,r.wx)(n,i);for(const{geometry:t,attributes:x}of e){const{x:e,y:i}=t,n=Math.max(0,e-a),I=Math.max(0,i-a),z=Math.min(o,i+a),y=Math.min(l,e+a),T=+p(x);for(let t=I;t<z;t++)for(let o=n;o<y;o++){const n=t*l+o,p=(0,r.If)(o-e,t-i,a),I=s[n];m=s[n]+=p*T;const x=m-I;d+=x,c+=x*x,m<u&&(u=m),m>f&&(f=m),v++}}if(!v)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const I=(f-u)/2;return{mean:d/v,stdDev:Math.sqrt((c-d*d/v)/v),min:u,max:f,mid:I,count:v}}(p,u,f,l,v[0],v[1]);return{count:I,min:x,max:z,avg:y,stddev:T}}}}]);
//# sourceMappingURL=57663.e4bf9e92.chunk.js.map