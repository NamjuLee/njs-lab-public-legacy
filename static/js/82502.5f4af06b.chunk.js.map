{"version":3,"file":"static/js/82502.5f4af06b.chunk.js","mappings":"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","sources":["njslab/Workshop/workshop-ml/SmartDrawingApp/Lib/NLine.ts","njslab/Workshop/workshop-ml/SmartDrawingApp/Lib/base/AbstractGeometryBase.ts"],"sourcesContent":["import { GeometryBase } from './base/AbstractGeometryBase';\r\n// import { Point } from './Point';\r\nimport { NVector3 } from './NVector3';\r\n// import { MathUtility } from '../NUtility/Math/MathUtility';\r\n\r\nexport class NLine extends GeometryBase {\r\n\r\n    p0: NVector3;\r\n    p1: NVector3;\r\n\r\n    static GetLineFromVecs(vs: NVector3[]) {\r\n        let lns: NLine[] = [];\r\n        for (let i = 0; i < vs.length; ++i) {\r\n            if (i === vs.length - 1) {\r\n                lns.push(new NLine(vs[i], vs[0]));\r\n            } else { lns.push(new NLine(vs[i], vs[i + 1])); }\r\n        }\r\n        return lns;\r\n    }\r\n    static GetUnOverlapWithLines(ln: NLine[], others: NLine[]) {\r\n        let index = [];\r\n        let newLns = [];\r\n        for (let i = 0; i < ln.length; ++i) {\r\n            index.push(false);\r\n            for (let j = 0; j < others.length; ++j) {\r\n                if (NLine.IsOverlap(ln[i], others[j])) {\r\n                    index[i] = true;\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < index.length; ++i) {\r\n            if (!index[i]) { newLns.push(ln[i]); }\r\n        }\r\n        return newLns;\r\n    }\r\n    static IsOverlap(ln: NLine, other: NLine): boolean {\r\n        if (ln.p0.IsOverlap(other.p0) && ln.p1.IsOverlap(other.p1)) {\r\n            return true;\r\n        } else if (ln.p0.IsOverlap(other.p1) && ln.p1.IsOverlap(other.p0)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    static RemoveOverlapWithLines(lns: NLine[]) {\r\n        let index = [];\r\n        let nLns = [];\r\n        for (let i = 0; i < lns.length; ++i) {\r\n            let over = false;\r\n            index.push(0);\r\n            for (let j = i + 1; j < lns.length; ++j) {\r\n                over = NLine.IsOverlap(lns[i], lns[j]);\r\n                if (over) { index[i]++; }\r\n            }\r\n        }\r\n        for (let i = 0; i < index.length; ++i) {\r\n            if (index[i] === 0) { { nLns.push(lns[i]); } }\r\n        }\r\n        return nLns;\r\n    }\r\n    constructor(p0: NVector3, p1: NVector3) {\r\n        super();\r\n        this.p0 = p0; this.p1 = p1;\r\n    }\r\n    Render(ctx: CanvasRenderingContext2D): void {\r\n        ctx.lineWidth = 0.5;\r\n        ctx.strokeStyle = 'red';\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.p0.x, this.p0.y);\r\n        ctx.lineTo(this.p1.x, this.p1.y);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n    }\r\n    DistanceToPoint(p: NVector3) {\r\n        // slope\r\n        let m = (this.p1.y - this.p0.y) / (this.p1.x - this.p0.x),\r\n            // y offset\r\n            b = this.p0.y - (m * this.p0.x),\r\n            d = [];\r\n        // distance to the linear equation\r\n        d.push(Math.abs(p.y - (m * p.x) - b) / Math.sqrt(Math.pow(m, 2) + 1));\r\n        // distance to p0\r\n        d.push(Math.sqrt(Math.pow((p.x - this.p0.x), 2) + Math.pow((p.y - this.p0.y), 2)));\r\n        // distance to p1\r\n        d.push(Math.sqrt(Math.pow((p.x - this.p1.x), 2) + Math.pow((p.y - this.p1.y), 2)));\r\n        // return the smallest distance\r\n        return d.sort((aa, bb) => { return (aa - bb); })[0]; // causes an array to be sorted numerically and ascending;\r\n    }\r\n    // PointCloseToLine(p: NVector3) {\r\n    //     let dx = this.p1.x - this.p0.x,\r\n    //         dy = this.p1.y - this.p0.y,\r\n    //         t = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / (dx * dx + dy * dy),\r\n    //         // x = MathUtility.Lerp(this.p0.x, this.p1.x, t),\r\n    //         // y = MathUtility.Lerp(this.p0.y, this.p1.y, t);\r\n    //     return [x, y];\r\n    // }\r\n    GetLog(): string {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    RenderPost(ctx: CanvasRenderingContext2D): void {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    IsMouseInside(x: number, y: number): boolean {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    Translate(x: number, y: number): void {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    Move(x: number, y: number): void {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    Remove(): void {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    Hide(): void {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n\r\n}","// import { MouseEventData } from '../../Core/AppCore/EventInteraction/MouseInteraction';\r\nimport { NVector3 } from '../NVector3';\r\nexport abstract class GeometryBase {\r\n    vec: NVector3 = new NVector3(0, 0, 0);\r\n    constructor() { /* */ }\r\n    abstract GetLog(): string;\r\n    abstract IsMouseInside(x: number, y: number): boolean;\r\n    abstract Translate(x: number, y: number): void;\r\n    abstract Move(x: number, y: number): void;\r\n    abstract Remove(): void;\r\n    // abstract RenderPost(ctx: CanvasRenderingContext2D): void;\r\n    // abstract Render(ctx: CanvasRenderingContext2D): void;\r\n}"],"names":["NLine","GeometryBase","static","vs","lns","i","length","push","ln","others","index","newLns","j","IsOverlap","other","p0","p1","nLns","over","constructor","super","this","Render","ctx","lineWidth","strokeStyle","beginPath","moveTo","x","y","lineTo","closePath","stroke","DistanceToPoint","p","m","b","d","Math","abs","sqrt","pow","sort","aa","bb","GetLog","Error","RenderPost","IsMouseInside","Translate","Move","Remove","Hide","vec","NVector3"],"sourceRoot":""}