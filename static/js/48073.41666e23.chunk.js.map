{"version":3,"file":"static/js/48073.41666e23.chunk.js","mappings":"mIAKO,MAAMA,EAQTC,YAAYC,GAAa,KAPzBC,aAAO,OACPC,YAAM,OACNC,SAAG,OACHC,YAAM,OACNC,YAAM,OACNC,UAAI,OACJC,iBAAW,EAEPC,KAAKP,QAAUQ,SAASC,eAAeV,GACvCQ,KAAKN,OAASO,SAASE,cAAc,UACrCH,KAAKP,QAAQW,YAAYJ,KAAKN,QAE9BM,KAAKK,YACT,CACAC,mBACI,IAAKC,UAAUC,IAAO,MAAM,IAAIC,MAAM,sBAEtC,MAAMC,QAAgBH,UAAUC,IAAIG,eAAe,CAC/CC,gBAAiB,qBAIrB,IAAKF,EAAW,MAAM,IAAID,MAAM,oBAEhC,MAAMb,QAAec,EAAQG,gBAC7Bb,KAAKL,IAAMK,KAAKN,OAAOoB,WAAW,UAElC,MAAMjB,EAASU,UAAUC,IAAIO,yBAA2BR,UAAUC,IAAIO,2BAA6Bf,KAAKL,IAAIqB,mBAAmBN,GACtGO,OAAOC,iBAChClB,KAAKN,OAAOyB,MAAQnB,KAAKP,QAAQ2B,YACjCpB,KAAKN,OAAO2B,OAASrB,KAAKP,QAAQ6B,aAClCtB,KAAKL,IAAI4B,UAAU,CAEf3B,SAAQC,SAER2B,UAAW,WAGfxB,KAAKF,KAAO,CAAEqB,MAAOnB,KAAKN,OAAOyB,MAAOE,OAAQrB,KAAKN,OAAO2B,QAC5DrB,KAAKJ,OAASA,EACdI,KAAKH,OAASA,EAEdG,KAAKyB,aAAazB,KAAKJ,OAAQI,KAAKH,OACxC,CACAS,mBAAmBV,EAAmBC,GAAwD,IAEtF6B,EAFwDC,EAAa,uDAAG,YAGtD,eAAlBA,IACAD,EAAc,UAGlB,MACME,ECzDUC,KAEpB,IAAIC,EAAK,GACT,IAAI,IAAIC,EAAI,EAAIA,EAAIF,EAAOE,IAAK,CAC5B,IAAIC,EAAsB,EAAhBC,KAAKC,SAAgB,EAC3BC,EAAsB,EAAhBF,KAAKC,SAAgB,EAC/BJ,GAAE,oBAAiBE,EAAE,aAAKG,EAAE,KAChC,CAwBA,OAtBAC,QAAQC,IAAIP,GAsBL,CAACQ,OApBI,gKAGyBT,EAAK,+BAC5BC,EAAE,sWAgBAS,SALF,oIAKW,ED0BNC,CADD,IAERC,EAAW7C,EAAO8C,qBAAqB,CACzCC,OAAQ,OACRL,OAAQ,CACJM,OAAQhD,EAAOiD,mBAAmB,CAC9BC,KAAMlB,EAAOU,SAEjBS,WAAY,QAEhBR,SAAU,CACNK,OAAQhD,EAAOiD,mBAAmB,CAC9BC,KAAMlB,EAAOW,WAEjBQ,WAAY,OACZC,QAAS,CAAC,CACNnD,OAAQA,KAGhBoD,UAAW,CACPC,SAAUvB,EACVwB,iBAAkBzB,KAIpB0B,EAAiBxD,EAAOyD,uBACxBC,EAActD,KAAKL,IAAI4D,oBAAoBC,aAE3CC,EAAaL,EAAeM,gBAAgB,CAE9CC,iBAAkB,CAAC,CACfC,KAAMN,EACNO,WAAY,CAAC,EAAK,EAAK,EAAK,GAC5BC,OAAQ,QACRC,QAAS,YAGjBN,EAAWO,YAAYvB,GACvBgB,EAAWQ,KAtCG,IAwCdR,EAAWS,MAEXtE,EAAOuE,MAAMC,OAAO,CAAChB,EAAeiB,UAExC,CACOC,UAEH,IADAtE,KAAKJ,OAAO0E,UACLtE,KAAKP,QAAQ8E,kBAChBvE,KAAKP,QAAQ+E,YAAYxE,KAAKP,QAAQ8E,iBAE9C,E","sources":["njslab/Infrastructure/WebGPU/WebGPU_03_PointLinePolyline/index.ts","njslab/Infrastructure/WebGPU/WebGPU_03_PointLinePolyline/shaders/shaders.ts"],"sourcesContent":["// import positionVert from './shaders/position.vert.wgsl?raw';\r\n// import colorFrag from './shaders/color.frag.wgsl';\r\n\r\nimport { Shaders } from './shaders/shaders';\r\n\r\nexport class Solution {\r\n    divHost: HTMLElement;\r\n    canvas: HTMLCanvasElement;\r\n    ctx: GPUCanvasContext;\r\n    device: GPUDevice;\r\n    format: GPUTextureFormat;\r\n    size: any;\r\n    pipelineObj: any;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n        this.canvas = document.createElement('canvas');\r\n        this.divHost.appendChild(this.canvas);\r\n\r\n        this.initWebGPU();\r\n    }\r\n    async initWebGPU() {\r\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\r\n\r\n        const adapter = await navigator.gpu.requestAdapter({\r\n            powerPreference: 'high-performance'\r\n            // powerPreference: 'low-power'\r\n        })\r\n\r\n        if (!adapter) { throw new Error('No Adapter Found'); }\r\n\r\n        const device = await adapter.requestDevice()\r\n        this.ctx = this.canvas.getContext('webgpu') as GPUCanvasContext\r\n        // @ts-ignore\r\n        const format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\r\n        const devicePixelRatio = window.devicePixelRatio || 1\r\n        this.canvas.width = this.divHost.clientWidth;\r\n        this.canvas.height = this.divHost.clientHeight;\r\n        this.ctx.configure({\r\n            // json specific format when key and value are the same\r\n            device, format,\r\n            // prevent chrome warning\r\n            alphaMode: 'opaque'\r\n        })\r\n\r\n        this.size = { width: this.canvas.width, height: this.canvas.height }\r\n        this.device = device;\r\n        this.format = format;\r\n\r\n        this.initPipeline(this.device, this.format);\r\n    }\r\n    async initPipeline(device: GPUDevice, format: GPUTextureFormat, primitiveType = 'line-list') { // point-list , line-list , line-strip\r\n\r\n        let indexFormat = undefined;\r\n        if (primitiveType === 'line-strip') {\r\n            indexFormat = 'uint32';\r\n        }\r\n\r\n        const count = 10\r\n        const shader = Shaders(count);\r\n        const pipeline = device.createRenderPipeline({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: device.createShaderModule({\r\n                    code: shader.vertex\r\n                }),\r\n                entryPoint: \"main\"\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({\r\n                    code: shader.fragment\r\n                }),\r\n                entryPoint: \"main\",\r\n                targets: [{\r\n                    format: format as GPUTextureFormat\r\n                }]\r\n            },\r\n            primitive: {\r\n                topology: primitiveType as GPUPrimitiveTopology,\r\n                stripIndexFormat: indexFormat as GPUIndexFormat\r\n            }\r\n        });\r\n\r\n        const commandEncoder = device.createCommandEncoder();\r\n        const textureView = this.ctx.getCurrentTexture().createView();\r\n\r\n        const renderPass = commandEncoder.beginRenderPass({\r\n            //@ts-ignore\r\n            colorAttachments: [{\r\n                view: textureView as GPUTextureView,\r\n                clearValue: [0.0, 0.0, 0.0, 1], //background color\r\n                loadOp: 'clear',\r\n                storeOp: 'store'\r\n            }]\r\n        });\r\n        renderPass.setPipeline(pipeline);\r\n        renderPass.draw(count);\r\n        // renderPass.draw(9, 1, 0, 0);\r\n        renderPass.end();\r\n\r\n        device.queue.submit([commandEncoder.finish()]);\r\n\r\n    }\r\n    public destroy() {\r\n        this.device.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}","\nexport const Shaders = (count) => {\n\n    let vs = ''\n    for(let i = 0 ; i < count; i++) {\n        let v0 = (Math.random() * 2) - 1\n        let v1 = (Math.random() * 2) - 1\n        vs += `vec2<f32>(${v0}, ${v1}),`\n    }\n\n    console.log(vs)\n\n    const vertex = `\n        @vertex\n        fn main(@builtin(vertex_index) VertexIndex: u32) -> @builtin(position) vec4<f32> {\n            var pos = array<vec2<f32>, ${count}>(\n                ${vs}           \n                // vec2<f32>(-0.5,  0.7),\n                // vec2<f32>( 0.3,  0.6),\n                // vec2<f32>( 0.5,  0.3),\n                // vec2<f32>( 0.4, -0.5),\n                // vec2<f32>(-0.4, -0.4),\n                // vec2<f32>(-0.3,  0.2)\n            );\n            return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        }`;\n\n    const fragment = `\n        @fragment\n        fn main() ->  @location(0) vec4<f32> {\n            return vec4<f32>(1.0, 1.0, 1.0, 1.0);\n        }`;\n    return {vertex, fragment};\n}\n\nexport const ShadersOld1 = () => {\n    const vertex = `\n    let pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(             \n        vec2<f32>(-0.5,  0.7),\n        vec2<f32>( 0.3,  0.6),\n        vec2<f32>( 0.5,  0.3),\n        vec2<f32>( 0.4, -0.5),\n        vec2<f32>(-0.4, -0.4),\n        vec2<f32>(-0.3,  0.2)\n    );\n\n    [[stage(vertex)]]\n    fn main([[builtin(vertex_index)]] VertexIndex: u32) -> [[builtin(position)]] vec4<f32> {\n      return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n    }`\n\n    const fragment = `\n        [[stage(fragment)]]\n        fn main() ->  [[location(0)]] vec4<f32> {\n            return vec4<f32>(1.0, 1.0, 0.0, 1.0);\n        }\n    `;\n    return {vertex, fragment};\n}\n\nexport const ShadersOld = () => {\n    const vertex = `\n    const pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(             \n        vec2<f32>(-0.5,  0.7),\n        vec2<f32>( 0.3,  0.6),\n        vec2<f32>( 0.5,  0.3),\n        vec2<f32>( 0.4, -0.5),\n        vec2<f32>(-0.4, -0.4),\n        vec2<f32>(-0.3,  0.2)\n    );\n\n    [[builtin(position)]] var<out> Position : vec4<f32>;\n    [[builtin(vertex_idx)]] var<in> VertexIndex : i32;\n\n    [[stage(vertex)]]\n    fn main() -> void {\n      Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n      return;\n    }`\n\n    const fragment = `\n        [[location(0)]] var<out> outColor : vec4<f32>;\n        \n        [[stage(fragment)]]\n        fn main() -> void {\n            outColor = vec4<f32>(1.0, 1.0, 0.0, 1.0);\n            return;\n        }\n    `;\n    return {vertex, fragment};\n}\n"],"names":["Solution","constructor","id","divHost","canvas","ctx","device","format","size","pipelineObj","this","document","getElementById","createElement","appendChild","initWebGPU","async","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","getPreferredCanvasFormat","getPreferredFormat","window","devicePixelRatio","width","clientWidth","height","clientHeight","configure","alphaMode","initPipeline","indexFormat","primitiveType","shader","count","vs","i","v0","Math","random","v1","console","log","vertex","fragment","Shaders","pipeline","createRenderPipeline","layout","module","createShaderModule","code","entryPoint","targets","primitive","topology","stripIndexFormat","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","draw","end","queue","submit","finish","destroy","lastElementChild","removeChild"],"sourceRoot":""}