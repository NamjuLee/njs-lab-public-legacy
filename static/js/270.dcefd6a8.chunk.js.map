{"version":3,"file":"static/js/270.dcefd6a8.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/WebGPU_03_Triangle/shaders/shaders.ts","njslab/Infrastructure/WebGPU/WebGPU_03_Triangle/index.ts"],"sourcesContent":["export const Shaders = () => {\n    const vertex = `  \n    struct Output {\n        @builtin(position) Position : vec4<f32>,\n        @location(0) vColor : vec4<f32>,\n    };\n\n    @vertex\n    fn main(@builtin(vertex_index) VertexIndex: u32) -> Output {\n        var pos : array<vec2<f32>, 9> = array<vec2<f32>, 9>(             \n            vec2<f32>(-0.63,  0.80),\n            vec2<f32>(-0.65,  0.20),\n            vec2<f32>(-0.20,  0.60),\n            vec2<f32>(-0.37, -0.07),\n            vec2<f32>( 0.05,  0.18),\n            vec2<f32>(-0.13, -0.40),\n            vec2<f32>( 0.30, -0.13),\n            vec2<f32>( 0.13, -0.64),\n            vec2<f32>( 0.70, -0.30)     \n        );\n    \n        var color : array<vec3<f32>, 9> = array<vec3<f32>, 9>(             \n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),  \n        );\n\n        var output: Output;\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n        return output;\n    }`\n\n    const fragment = `\n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }\n    `;\n    return {vertex, fragment};\n}\n\nexport const ShadersOld1 = () => {\n    const vertex = `\n    let pos : array<vec2<f32>, 9> = array<vec2<f32>, 9>(             \n        vec2<f32>(-0.63,  0.80),\n        vec2<f32>(-0.65,  0.20),\n        vec2<f32>(-0.20,  0.60),\n        vec2<f32>(-0.37, -0.07),\n        vec2<f32>( 0.05,  0.18),\n        vec2<f32>(-0.13, -0.40),\n        vec2<f32>( 0.30, -0.13),\n        vec2<f32>( 0.13, -0.64),\n        vec2<f32>( 0.70, -0.30)     \n    );\n\n    let color : array<vec3<f32>, 9> = array<vec3<f32>, 9>(             \n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0),\n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0),\n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0),  \n    );\n\n    struct Output {\n        [[builtin(position)]] Position : vec4<f32>;\n        [[location(0)]] vColor : vec4<f32>;\n    };\n\n    [[stage(vertex)]]\n    fn main([[builtin(vertex_index)]] VertexIndex: u32) -> Output {\n        var output: Output;\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n        return output;\n    }`\n\n    const fragment = `\n        [[stage(fragment)]]\n        fn main([[location(0)]] vColor: vec4<f32>) -> [[location(0)]] vec4<f32> {\n            return vColor;\n        }\n    `;\n    return {vertex, fragment};\n}\n\nexport const ShadersOld = () => {\n    const vertex = `\n    const pos : array<vec2<f32>, 9> = array<vec2<f32>, 9>(             \n        vec2<f32>(-0.63,  0.80),\n        vec2<f32>(-0.65,  0.20),\n        vec2<f32>(-0.20,  0.60),\n        vec2<f32>(-0.37, -0.07),\n        vec2<f32>( 0.05,  0.18),\n        vec2<f32>(-0.13, -0.40),\n        vec2<f32>( 0.30, -0.13),\n        vec2<f32>( 0.13, -0.64),\n        vec2<f32>( 0.70, -0.30)     \n    );\n\n    const color : array<vec3<f32>, 9> = array<vec3<f32>, 9>(             \n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0),\n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0),\n        vec3<f32>(1.0, 0.0, 0.0),\n        vec3<f32>(0.0, 1.0, 0.0),\n        vec3<f32>(0.0, 0.0, 1.0),  \n    );\n\n    [[builtin(position)]] var<out> Position : vec4<f32>;\n    [[builtin(vertex_idx)]] var<in> VertexIndex : i32;\n    [[location(0)]] var<out> vColor : vec4<f32>;\n\n    [[stage(vertex)]]\n    fn main() -> void {\n      Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n      vColor = vec4<f32>(color[VertexIndex], 1.0);\n      return;\n    }`\n\n    const fragment = `\n        [[location(0)]] var<in> vColor : vec4<f32>;\n        [[location(0)]] var<out> outColor : vec4<f32>;\n        [[stage(fragment)]]\n        fn main() -> void {\n            outColor = vColor;\n            return;\n        }\n    `;\n    return {vertex, fragment};\n}\n","// import positionVert from './shaders/position.vert.wgsl?raw';\r\n// import colorFrag from './shaders/color.frag.wgsl';\r\n\r\nimport { Shaders } from './shaders/shaders';\r\n\r\nconst vertex = new Float32Array([\r\n    0.0, 0.5, 0.0,\r\n    -0.5, -0.5, 0.0,\r\n    0.5, -0.5, 0.0\r\n])\r\nconst vertexCount = 3\r\n\r\nexport { vertex, vertexCount }\r\n\r\nconst positionVert = `\r\n@vertex\r\nfn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\r\n    return vec4<f32>(position, 1.0);\r\n}\r\n`\r\nconst colorFrag = `\r\n@group(0) @binding(0) var<uniform> color : vec4<f32>;\r\n\r\n@fragment\r\nfn main() -> @location(0) vec4<f32> {\r\n    return color;\r\n}\r\n`\r\n\r\nexport class Solution {\r\n    divHost: HTMLElement;\r\n    canvas: HTMLCanvasElement;\r\n    ctx: GPUCanvasContext;\r\n    device: GPUDevice;\r\n    format: GPUTextureFormat;\r\n    size: any;\r\n    pipelineObj: any;\r\n    mouse = new Float32Array([\r\n        0,0\r\n     ]);\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        //     console.log(id, 'webGPU', navigator.gpu);\r\n        this.canvas = document.createElement('canvas');\r\n        this.divHost.appendChild(this.canvas);\r\n\r\n        this.canvas.addEventListener('mousemove', (e: MouseEvent) => {\r\n            // console.log('move dragging')\r\n            const xOff = this.mouse[0] - e.offsetX;\r\n            const yOff = this.mouse[1] - e.offsetY;\r\n\r\n            this.mouse[0] = e.offsetX;\r\n            this.mouse[1] = e.offsetY;\r\n\r\n            console.log('mousemove', e);\r\n        }, false);\r\n\r\n        this.initWebGPU();\r\n    }\r\n    async initWebGPU() {\r\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\r\n\r\n        const adapter = await navigator.gpu.requestAdapter({\r\n            powerPreference: 'high-performance'\r\n            // powerPreference: 'low-power'\r\n        })\r\n\r\n        if (!adapter) { throw new Error('No Adapter Found'); }\r\n\r\n        const device = await adapter.requestDevice()\r\n        this.ctx = this.canvas.getContext('webgpu') as GPUCanvasContext\r\n        // @ts-ignore\r\n        const format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\r\n        const devicePixelRatio = window.devicePixelRatio || 1\r\n        this.canvas.width = this.divHost.clientWidth;\r\n        this.canvas.height = this.divHost.clientHeight;\r\n        this.ctx.configure({\r\n            // json specific format when key and value are the same\r\n            device, format,\r\n            // prevent chrome warning\r\n            alphaMode: 'opaque'\r\n        })\r\n\r\n        this.size = { width: this.canvas.width, height: this.canvas.height }\r\n        this.device = device;\r\n        this.format = format;\r\n\r\n        this.initPipeline(this.device, this.format);\r\n    }\r\n    async initPipeline(device: GPUDevice, format: GPUTextureFormat, primitiveType = 'triangle-list') { // triangle-list , triangle-strip\r\n        let indexFormat = undefined;\r\n        if (primitiveType === 'line-strip') {\r\n            indexFormat = 'uint32'\r\n        }\r\n\r\n        const shader = Shaders();\r\n        const pipeline = device.createRenderPipeline({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: device.createShaderModule({\r\n                    code: shader.vertex\r\n                }),\r\n                entryPoint: \"main\"\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({\r\n                    code: shader.fragment\r\n                }),\r\n                entryPoint: \"main\",\r\n                targets: [{\r\n                    format: format as GPUTextureFormat\r\n                }]\r\n            },\r\n            primitive: {\r\n                topology: primitiveType as GPUPrimitiveTopology,\r\n                stripIndexFormat: indexFormat as GPUIndexFormat\r\n            }\r\n        });\r\n\r\n        const commandEncoder = device.createCommandEncoder();\r\n        const textureView = this.ctx.getCurrentTexture().createView();\r\n\r\n        const renderPass = commandEncoder.beginRenderPass({\r\n            //@ts-ignore\r\n            colorAttachments: [{\r\n                view: textureView as GPUTextureView,\r\n                clearValue: [0.0, 0.0, 0.0, 1], //background color\r\n                loadOp: 'clear',\r\n                storeOp: 'store'\r\n            }]\r\n        });\r\n        renderPass.setPipeline(pipeline);\r\n        renderPass.draw(9, 1, 0, 0);\r\n        // renderPass.draw(6);\r\n        renderPass.end();\r\n\r\n        device.queue.submit([commandEncoder.finish()]);\r\n\r\n    }\r\n    public destroy() {\r\n        this.device.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nexport const CreateGPUBuffer = (device: GPUDevice, data: Float32Array,\r\n    usageFlag: GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\r\n    const buffer = device.createBuffer({\r\n        size: data.byteLength,\r\n        usage: usageFlag,\r\n        mappedAtCreation: true\r\n    });\r\n    new Float32Array(buffer.getMappedRange()).set(data);\r\n    buffer.unmap();\r\n    return buffer;\r\n}\r\n\r\n\r\n// export const InitGPU = async () => {\r\n//     const checkgpu = CheckWebGPU();\r\n//     if(checkgpu.includes('Your current browser does not support WebGPU!')){\r\n//         console.log(checkgpu);\r\n//         throw('Your current browser does not support WebGPU!');\r\n//     }\r\n//     const canvas = document.getElementById('canvas-webgpu') as HTMLCanvasElement;\r\n//     const adapter = await navigator.gpu?.requestAdapter();\r\n//     const device = await adapter?.requestDevice() as GPUDevice;\r\n//     const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\r\n\r\n//     const devicePixelRatio = window.devicePixelRatio || 1;\r\n//     /*const size = [\r\n//         canvas.clientWidth * devicePixelRatio,\r\n//         canvas.clientHeight * devicePixelRatio,\r\n//     ];*/\r\n//     //const format = context.getPreferredFormat(adapter!);\r\n//     const format = navigator.gpu.getPreferredCanvasFormat();\r\n\r\n//     context.configure({\r\n//         device: device,\r\n//         format: format,\r\n//         //size: size\r\n//         alphaMode:'opaque'\r\n//     });\r\n//     return{ device, canvas, format, context };\r\n// };\r\n// export const CheckWebGPU = () => {\r\n//     let result = 'Great, your current browser supports WebGPU!';\r\n//     if (!navigator.gpu) {\r\n//         result = `Your current browser does not support WebGPU! Make sure you are on a system\r\n//         with WebGPU enabled. Currently, WebGPU is supported in\r\n//         <a href=\"https://www.google.com/chrome/canary/\">Chrome canary</a>\r\n//         with the flag \"enable-unsafe-webgpu\" enabled. See the\r\n//         <a href=\"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status\">\r\n//         Implementation Status</a> page for more details.\r\n//         You can also use your regular Chrome to try a pre-release version of WebGPU via\r\n//         <a href=\"https://developer.chrome.com/origintrials/#/view_trial/118219490218475521\">Origin Trial</a>.\r\n//         `;\r\n//     }\r\n//     return result;\r\n// }\r\n"],"names":["vertex","Float32Array","vertexCount","Solution","constructor","id","divHost","canvas","ctx","device","format","size","pipelineObj","mouse","this","document","getElementById","createElement","appendChild","addEventListener","e","offsetX","offsetY","console","log","initWebGPU","async","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","getPreferredCanvasFormat","getPreferredFormat","window","devicePixelRatio","width","clientWidth","height","clientHeight","configure","alphaMode","initPipeline","indexFormat","primitiveType","shader","fragment","pipeline","createRenderPipeline","layout","module","createShaderModule","code","entryPoint","targets","primitive","topology","stripIndexFormat","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","draw","end","queue","submit","finish","destroy","lastElementChild","removeChild","CreateGPUBuffer","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap"],"sourceRoot":""}