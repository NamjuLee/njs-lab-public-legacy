{"version":3,"file":"static/js/79650.d5382a6a.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Renderer/Camera/Cameras.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Renderer/Camera/CameraController.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Renderer/index.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/lib/index.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/lib/matrixUtil.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Object/NGeojsonLine/Geometry.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Object/Base/ObjectBase.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Object/NGeojsonLine/index.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Object/NGeojsonPoint/Geometry.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Object/NGeojsonPoint/index.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/Scene/index.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/Core/index.ts","njslab/Infrastructure/WebGL/Starter-WebGLSandbox/index.ts"],"sourcesContent":["import { vec2, vec3, mat4 } from 'gl-matrix';\n// import { } from '../../lib';\n\nexport class Camera {\n    public viewMatrix = mat4.create();\n    public projectionMatrix = mat4.create(); \n    public viewProjectionMatrix = mat4.create();\n\n    public zoomMax = 100;\n    public zoomSpeed = 2;\n\n    public near = 0.01;\n    public far = 10000;\n\n    public mvpMatrix = mat4.create();\n\n    public eye = vec3.fromValues(0,0,0);\n    // public eye = vec3.fromValues(0, 1, 0);\n    public center = vec3.fromValues(0, 0, 0);\n    public up = vec3.fromValues(0, 1, 0);\n\n    public type ='camera';\n\n    public respectRatio: number;\n    public width: number;\n    public height: number;\n\n    public angleXY = Math.PI; \n    public angleZ = Math.PI * 0.25;\n    public distance = 1;\n\n    constructor(width: number = 100, height: number = 100, cameraPosition: vec3 = [2, 2, 4], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance: number = 5) {\n        this.distance = distance; this.width = width; this.height = height; this.respectRatio = width / height\n        this.eye = cameraPosition;\n        this.center = center;\n        this.up = up;\n    }\n    public zoom(v: number) { \n        //\n    }\n    public update() {\n        mat4.lookAt(this.viewMatrix, this.eye, this.center, this.up);\n        mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);\n\n        // createTransforms(this.modelMatrix, this.translation, this.rotation);\n        // mat4.multiply(this.mvpMatrix, this.viewProjectionMatrix, this.viewMatrix);\n        // console.log(this.type);\n    }\n    \n}\n\nexport class CameraPerspective extends Camera {\n    constructor(width = 100, height = 100, cameraPosition: vec3 = [2, 2, 4], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance = 3){\n        super(width, height, cameraPosition, center, up, distance);\n        this.type = 'CameraPerspective';\n        this.init();\n    }\n    public init() {\n        mat4.perspective(this.projectionMatrix, 2 * Math.PI / 5, this.respectRatio, this.near, this.far);\n        this.update();\n    }\n    public zoom (v: number ) {\n        this.distance += v * 0.01;\n    }\n\n}\nexport class CameraOrth extends Camera {\n    constructor(width = 100, height = 100, cameraPosition: vec3 = [0 ,0, 1], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance = 300.1){\n        super(width, height, cameraPosition, center, up, distance);\n        this.type = 'CameraOrth';\n        this.init()\n    }\n    public init() {\n        projection(this.projectionMatrix, this.width, this.height, this.near , this.far, this.distance);\n\n        // const aspectRatio = width / height;\n        // const zoomFactor = 0.1; //this.distance;\n        // const projectionMatrix = mat4.ortho(\n        //   -aspectRatio * zoomFactor,\n        //   aspectRatio * zoomFactor,\n        //   -1 * zoomFactor,\n        //   1 * zoomFactor,\n        //   0.1,\n        //   100.0\n        // );\n\n        // mat4.ortho(this.projectionMatrix, -aspectRatio * zoomFactor, aspectRatio * zoomFactor,  -1 * zoomFactor, 1 * zoomFactor, this.near, this.far);\n        // mat4.ortho(this.projectionMatrix, 0, 500, 800, 0, 0.1, 5000);\n        // mat4.ortho(this.projectionMatrix, 0, 0, 800, 800, -400 , 400);\n        // mat4.frustum(this.projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n\n        this.angleXY = 0;\n        this.angleZ = 0;\n        this.update();\n    }\n    public zoom(v: number) {\n        this.width  += this.width * 0.001 * v;\n        this.height += this.height * 0.001 * v;\n        if (this.distance < 0.000001) { this.distance = 0.000001; }\n        if (this.distance > 100000) { this.distance = 100000; }\n        projection(this.projectionMatrix, this.width, this.height, this.near, this.far, this.distance);\n    }\n}\n\nconst projection = (dst, width, height, near , far, scale) => {\n    // Note: This matrix flips the Y axis so that 0 is at the top.\n    // dst = dst || new Float32Array(16);\n    dst[ 0] = 2 / width * scale;    dst[ 1] = 0;                    dst[ 2] = 0;                        dst[ 3] = 0;\n    dst[ 4] = 0;                    dst[ 5] = 2 / height * scale;   dst[ 6] = 0;                        dst[ 7] = 0;\n    dst[ 8] = 0;                    dst[ 9] = 0;                    dst[10] = -2 / (far - near);       dst[11] = 0;\n    dst[12] = 0;                    dst[13] = 0;                    dst[14] = 0.1;                      dst[15] = 1;\n    // dst[12] = -1;                dst[13] = 1;                    dst[14] = 0.5;                      dst[15] = 1;\n    return dst;\n};\n\n// const createOrthographicMatrix = (left, right, bottom, top, near, far) => {\n//     const tx = -(right + left) / (right - left);\n//     const ty = -(top + bottom) / (top - bottom);\n//     const tz = -(far + near) / (far - near);\n  \n//     return [\n//       2 / (right - left), 0, 0, 0,\n//       0, 2 / (top - bottom), 0, 0,\n//       0, 0, -2 / (far - near), 0,\n//       tx, ty, tz, 1,\n//     ];\n//   }","import { vec2, vec3, mat4 } from 'gl-matrix';\nimport { Camera, CameraPerspective, CameraOrth } from './Cameras';\nimport { Renderer } from '../';\n\nexport class CameraController {\n    public renderer: Renderer;\n    public canvas: HTMLCanvasElement\n\n    public cameraOrth: Camera;\n    public cameraPerspective: Camera;\n\n    public camera: Camera;\n\n    private modelMatrix: mat4 = mat4.create();\n    private mvpMatrix: mat4 = mat4.create();\n\n    // public vMatrix: mat4;\n    // public vpMatrix: mat4;\n    public rotation =vec3.fromValues(0, 0, 0); \n    public translation =vec3.fromValues(0, 0, 0);\n    public screen2 = vec2.fromValues(0, 0);\n\n    public pos = [0, 0];\n    public isDown: boolean = false;\n    public isShift: boolean = false;\n\n    constructor(renderer: Renderer) {\n        this.renderer = renderer;\n        this.canvas = renderer.canvas;\n\n        const eye = vec3.fromValues(2.6451475620269775, 3.130298137664795, 2.864337205886841); // 1.6399056911468506, 1.1976807117462158, 1.162699580192566\n        // const eye = vec3.fromValues(10, -10, 2);\n        const center = vec3.fromValues(0, 0, 0);\n        const up = vec3.fromValues(0, 0, 1);\n\n        this.cameraPerspective = new CameraPerspective(this.canvas.width, this.canvas.height, eye, center, up);\n        this.camera = this.cameraPerspective; \n        this.arcRotation(0, 0);\n\n        this.cameraOrth = new CameraOrth(this.canvas.width, this.canvas.height);\n        this.camera = this.cameraOrth; // this.cameraPerspective // this.cameraOrth;\n\n        this.appendEvent(this.canvas);\n        this.update();\n    }\n    public update() {\n        // mat4.lookAt(this.vMatrix, this.eye, this.center, this.up);\n        this.camera.update();\n\n        // mat4.multiply(this.camera.viewProjectionMatrix, this.camera.projectionMatrix, this.camera.viewMatrix);\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n        mat4.multiply(this.mvpMatrix, this.camera.viewProjectionMatrix, this.modelMatrix);\n        // console.log('camera updated...');\n    }\n    public rotateZ(val = 0.1) {\n        this.rotation[2] += val;\n        this.update();\n    }\n    public translateX(val = 0.1) {\n        this.translation[0] += val;\n        this.update();\n    }\n    public get getMatrix() {\n        return this.mvpMatrix;\n    }\n    public shiftCamera() {\n        // console.log('shiftCamera');\n        if (this.camera === this.cameraPerspective){\n            this.camera = this.cameraOrth;\n        } else {\n            this.camera = this.cameraPerspective;\n        }\n        this.update();\n    }\n    public moveCamera(x: number, y: number) {\n        if (this.camera === this.cameraPerspective){\n            this.arcRotation(x, y);\n        } else {\n            this.pan(x, y);\n        }\n    }\n    public arcRotation(x: number, y: number) {\n        x = x * -0.01;\n        y = y * -0.01;\n\n        if (this.isShift) {\n            this.panPerspective(x, y)\n        } else {\n            this.camera.angleXY += x;\n            this.camera.angleZ += y;\n            this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.camera.angleXY) * Math.cos(this.camera.angleZ)) * this.camera.distance;\n            this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.camera.angleXY) * Math.cos(this.camera.angleZ)) * this.camera.distance;\n            this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.camera.angleZ) * this.camera.distance);\n\n            // console.log('angleXY', this.camera.angleXY, 'angleZ', this.camera.angleZ, this.camera.distance, 'distance' )\n            // console.log('camera.eye', this.camera.eye )\n        }\n\n        this.update();\n    }\n    public zoomWheel(v: number) {\n\n        if (this.camera === this.cameraPerspective){\n            this.camera.zoom(v)\n            this.arcRotation(0, 0);\n        } else {\n            this.camera.zoom(v)\n        }\n        \n        // \n\n        // console.log(this.scale);\n\n        this.update();\n    }\n    public panPerspective(x: number, y: number) {\n        const scale = 0.01\n        this.camera.center[0] += x / this.camera.distance;\n        this.camera.center[2] += y / this.camera.distance;\n        this.camera.eye[0] += x / this.camera.distance;\n        this.camera.eye[2] += y / this.camera.distance;\n        this.update();\n\n    }\n    public pan(x: number, y: number) {\n        const scale = 0.01\n        this.camera.center[0] += x / this.camera.distance;\n        this.camera.center[1] -= y / this.camera.distance;\n        this.camera.eye[0] += x / this.camera.distance;\n        this.camera.eye[1] -= y / this.camera.distance;\n        this.update();\n\n    }\n    // public arcRotation(x: number, y: number) {\n    //     x = x * 0.01;\n    //     y = y * 0.01;\n    //     this.angleXY += x;\n    //     this.angleZ += y;\n    //     this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n    //     this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n    //     this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.angleZ) * this.distance);\n\n    //     console.log('angleXY', this.angleXY, 'angleZ', this.angleZ, this.distance, 'distance' )\n    //     console.log('camera.eye', this.camera.eye )\n    //     this.update();\n    // }\n\n    public appendEvent(canvas: HTMLCanvasElement) {\n        canvas.addEventListener('ondrag', (e: MouseEvent) => {\n            // console.log('click', e);\n        }, false);\n        canvas.addEventListener('click', (e: MouseEvent) => {\n            // console.log('click', e);\n        }, false);\n        canvas.addEventListener('dblclick', (e: MouseEvent) => {\n            // console.log('d-click', e);\n        }, false);\n        canvas.addEventListener('drag', (e: MouseEvent) => {\n            // console.log('drag', e);\n        }, true);\n        canvas.addEventListener('mouseup', (e: MouseEvent) => {\n            // console.log('mouse up', e);\n        }, false);\n        canvas.addEventListener('mousedown', (e: MouseEvent) => {\n            this.isDown = true;\n            this.pos[0] = e.offsetX;\n            this.pos[1] = e.offsetY;\n\n        }, false);\n        canvas.addEventListener('mouseup', (e: MouseEvent) => {\n            // console.log('pointer up', e);\n            this.isDown = false;\n        }, false);\n        canvas.addEventListener('mousemove', (e: MouseEvent) => {\n            if (this.isDown) {\n                // console.log('move dragging')\n                const xOff = this.pos[0] - e.offsetX;\n                const yOff = this.pos[1] - e.offsetY;\n\n                this.moveCamera(xOff, yOff)\n                this.pos[0] = e.offsetX;\n                this.pos[1] = e.offsetY;\n            } else {\n                // console.log('move')\n                const rect = canvas.getBoundingClientRect();\n                // this.mNormalized[0] = (e.clientX - rect.left) / canvas.width;\n                // this.mNormalized[1] = (e.clientY - rect.top) / canvas.height;\n                // console.log(this.mNormalized)\n            \n\n            }\n            \n            this.pos[0] = e.offsetX;\n            this.pos[1] = e.offsetY;\n\n            // console.log('mousemove', e);\n        }, false);\n        canvas.addEventListener('wheel', (e:  WheelEvent) => {\n            // console.log('wheel', e.deltaY);\n            this.zoomWheel(e.deltaY)\n        }, false);\n\n        window.addEventListener('keydown', (k:  KeyboardEvent) => {\n            if(k.key === 'p') {\n                this.shiftCamera();\n            }\n\n            if (k.shiftKey) {\n                this.isShift = true;\n            }\n\n        }, false);\n        \n        window.addEventListener('keyup', (k:  KeyboardEvent) => {\n\n            this.isShift = false;\n        }, false);\n    }\n}\n\nconst createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};","import { Core } from '../'\nimport { CameraController } from './Camera/CameraController';\n\nexport class Renderer {\n    public core: Core;\n    public gl: WebGL2RenderingContext;\n    public cameraController: CameraController;\n    public divHost: HTMLElement;\n    public canvas: HTMLCanvasElement;\n    private isActive = true;\n    constructor(core: Core) {\n        this.core = core;\n        this.divHost = document.getElementById(this.core.id);\n        \n        // tslint:disable: no-console\n        this.canvas = document.createElement('canvas');\n        this.divHost.appendChild(this.canvas);\n        this.canvas.width = this.divHost.clientWidth;\n        this.canvas.height = this.divHost.clientHeight;\n\n        this.init();\n    }\n    public init() {\n        this.gl = this.canvas.getContext('webgl2');\n        this.cameraController = new CameraController(this);\n    }\n    public draw() {\n        if (!this.isActive) { return; }\n        requestAnimationFrame( () => this.draw());\n\n        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n        this.gl.enable(this.gl.CULL_FACE);\n        this.gl.enable(this.gl.DEPTH_TEST);\n    \n        // Clear the canvas AND the depth buffer.\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n        \n        this.cameraController.update();\n        this.core.scene.render();\n    }\n    public destroy() {\n        this.isActive = false;\n        this.divHost.removeChild(this.canvas);\n    }\n}","export * from './matrixUtil';\n\nexport const loadWGSL = async (path: string) => {\n    return fetch(`${path}`)\n        .then((response: Response) => {\n            return response.text();\n        }).catch((err: Error) => {\n            console.debug(err);\n        });\n\n}\n\n","import { mat4, vec3 } from 'gl-matrix';\n\nexport const createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};","import { getJSONFromURL, MercatorProjection } from 'njscore';\n\nexport class Geometry {\n    streetOSM: any = [];\n\n    pos: any;\n    colors: any;\n\n    constructor() {\n\n    }\n    async init() {\n        await getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\n            for (let i = 0; i < data['features'].length; ++i) {\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\n            }\n            this.renderLines(this.streetOSM, [0.0, 0.0, 0.0]);\n        });\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    }\n    renderLines = (paths: any, color: number[]) => {\n\n        const positions = [];\n        const colors = [];\n        const indices = [];\n\n        const xOFf =  15478749.591872748 // 48.85635555014451; -15478803.88731685; 15478749.591872748 4766690.415614613 // 15478749.591872748 4766690.415614613\n        const yOFf =  4766690.415614613 // -4766681.448690384;\n        const scale = 0.001;\n\n\n        let xC = 0\n        let yC = 0\n        let Count = 0\n\n        for (let i = 0; i < paths.length; ++i) {\n            const route = paths[i]\n\n            for (let j = 0; j < route.length; ++j) {\n                for (let k = 0; k < route[j].length - 1; ++k) {\n\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\n                    // xC += xPro;\n                    // yC += yPro;\n\n                    const [xPro1, yPro1] = MercatorProjection(route[j][k+1][0], route[j][k+1][1]);\n                    // const xPro = route[j][k][0];\n                    // const yPro = route[j][k][1];\n\n                    // const xPro1 = route[j][k+1][0];\n                    // const yPro1 = route[j][k+1][1];\n\n                    xC += xPro;\n                    yC += yPro;\n\n                    Count += 1;\n\n                    const x = (xPro - xOFf) * scale\n                    const y = (yPro - yOFf) * scale\n\n                    const x1 = (xPro1 - xOFf) * scale\n                    const y1 = (yPro1 - yOFf) * scale\n\n                    // console.log(x, y)\n                    positions.push(x, y, 0)\n\n                    colors.push(color[0], color[1],  color[2]);\n\n                    // if (k !== 0) {\n                        positions.push(x1, y1, 0)\n                        // positions.push(x, y, Math.random() * 0.01)\n                        colors.push(color[0], color[1],  color[2]);\n                    // }\n\n                    if (k < route[j].length - 1) {\n                        indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\n                    }\n                }\n\n                // positions.push(positions[positions.length-3], positions[positions.length-2], positions[positions.length-1])\n                // colors.push(color[0], color[1],  color[2]);\n\n                // positions.push(0, 0, 0)\n                // colors.push(0,0,0);\n            }\n        }\n\n        // console.log(positions)\n        // console.log(xC / Count, yC / Count )\n        // geometry.setIndex(indices);\n        // geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        // geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n        // // generateMorphTargets( geometry );\n\n        // geometry.computeBoundingSphere();\n\n        // const line = new THREE.LineSegments(geometry, material);\n        // scene.add(line);\n\n        this.pos = new Float32Array(positions.flat());\n        this.colors = new Float32Array(colors.flat());\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    };\n}","import { mat4, vec3 } from 'gl-matrix';\nimport { Scene } from '../../Scene';\n\nexport class ObjectBase {\n    public scene: Scene;\n    public gl: WebGL2RenderingContext;\n    \n    public modelMatrix: mat4 = mat4.create();\n    public translation: vec3 = vec3.fromValues(2,0,0);\n    public rotation: vec3 = vec3.fromValues(0,0,0);\n    public scale: vec3 = vec3.fromValues(1,1,1);\n\n    public program: WebGLProgram;\n\n    public modelLoc: WebGLUniformLocation;\n    public cameraLoc: WebGLUniformLocation;\n\n    public isRenderable: boolean = false;\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n        this.gl = scene.core.renderer.gl;\n        this.scene.add(this);\n    }\n    public async init() {\n\n    }\n    public render() {\n\n    }\n}","// import { InitGPU, CreateGPUBuffer, CreateGPUBufferUint, CreateTransforms, CreateViewProjection, CreateAnimation } from './helper';\n// import { Shaders } from './shaders';\n// import { vec3, mat4 } from 'gl-matrix';\n// const createCamera = require('3d-view-controls');\n\n\nimport { vec3, mat4 } from 'gl-matrix';\nimport { createTransforms, loadWGSL } from '../../../lib';\n\nimport { Geometry } from './Geometry';\n\nimport { Scene } from '../../Scene';\nimport { ObjectBase } from '../Base/ObjectBase';\n\nconst vertPath = require('./shaders/vert.glsl');\nconst fragPath = require('./shaders/frag.glsl');\n\nexport class NGeojsonLine extends ObjectBase {\n\n    numberOfVertices: number = 0;\n    vertexBuffer;\n    colorBuffer;\n    normalBuffer;\n    uvBuffer;\n    uniformBindGroup;\n    uniformBindGroup1;\n    uniformBindGroup2;\n    uniformBuffer;\n\n    commandEncoder;\n\n    textureView;\n    renderPassDescription;\n    pipeline: GPURenderPipeline;\n\n    isAnimation = false;\n\n    mouseBuffer;\n    frameBuffer;\n\n    t: number = 0;\n\n    resultBuffer;\n\n    geometry: Geometry;\n\n    posLoc;\n    buf;\n    buf2;\n    colorLoc;\n\n    frameLoc;\n    mouseLoc;\n\n\n    constructor(scene: Scene) {\n        super(scene)\n\n\n        this.init();\n    }\n    async init () {\n        this.geometry = new Geometry();\n        await this.geometry.init();\n        console.log(this.geometry)\n\n        \n        const vertShader = await loadWGSL(vertPath);\n        const fragShader = await loadWGSL(fragPath);\n        \n        const gl = this.gl;\n\n        this.vertexBuffer = gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.geometry.pos, gl.STATIC_DRAW);\n\n        this.colorBuffer = gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.geometry.colors, gl.STATIC_DRAW);\n\n\n        this.program = gl.createProgram();\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertShader as string);\n        gl.compileShader(vertexShader);\n        gl.attachShader(this.program, vertexShader);\n\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragShader as string);\n        gl.compileShader(fragmentShader);\n        gl.attachShader(this.program, fragmentShader);\n\n        gl.linkProgram(this.program);\n\n\n        // this.posLoc = gl.getAttribLocation(this.program, 'position');\n        // this.colorLoc = gl.getAttribLocation(this.program, 'color');\n\n        // this.buf = gl.createBuffer();\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.geometry.pos), gl.STATIC_DRAW);\n        // normally these would happen at render time\n\n\n        // this.buf2 = gl.createBuffer();\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.buf2);\n        // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.geometry.colors), gl.STATIC_DRAW);\n\n        \n        this.modelLoc = gl.getUniformLocation(this.program, 'uModel');\n        this.cameraLoc = gl.getUniformLocation(this.program, 'cameraProjection');\n\n        \n        this.frameLoc = gl.getUniformLocation(this.program, 'uFrame');\n        this.mouseLoc = gl.getUniformLocation(this.program, 'uMouse');\n\n        this.isRenderable = true;\n    }\n    render() {\n        \n        if (!this.isRenderable) { return; }\n        // console.log('dd');\n        // const gl = this.gl;\n        createTransforms(this.modelMatrix, this.translation, this.rotation, this.scale);\n\n        this.gl.useProgram(this.program);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n        this.gl.enableVertexAttribArray(0);\n        this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 0, 0);\n\n        \n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        this.gl.enableVertexAttribArray(1);\n        this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, 0, 0);\n        \n\n        this.gl.uniformMatrix4fv(this.modelLoc, false, this.modelMatrix);\n        this.gl.uniformMatrix4fv(this.cameraLoc, false, this.scene.core.renderer.cameraController.getMatrix);\n\n        this.gl.uniform1f(this.frameLoc, this.t);\n        this.gl.uniform2f(this.mouseLoc, this.scene.core.renderer.cameraController.pos[0] * 0.01, this.scene.core.renderer.cameraController.pos[1] * 0.01);\n\n        // console.log(this.scene.core.renderer.cameraController.pos);\n        \n        this.gl.drawArrays(this.gl.LINES, 0, this.geometry.pos.length / 3);\n\n        this.t += 0.1;\n    }\n}\n","import { getJSONFromURL, MercatorProjection } from 'njscore';\n\nexport class Geometry {\n    streetOSM: any = [];\n\n    pos: any;\n    colors: any;\n\n    constructor() {\n\n    }\n    async init() {\n        await getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\n            for (let i = 0; i < data['features'].length; ++i) {\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\n            }\n            this.renderLines(this.streetOSM, [0.0, 0.0, 0.0]);\n        });\n        // this.pos = new Float32Array([0, 0, 0,   0, 0.5, 0,   0.5, 0.5, 1,    0, 0, 0,  0.5, 0.5, 1,  0.5, 0, 0, ]);\n    }\n    renderLines = (paths: any, color: number[]) => {\n\n        const positions = [];\n        const colors = [];\n        const indices = [];\n\n        const xOFf =  15478749.591872748 // 48.85635555014451; -15478803.88731685; 15478749.591872748 4766690.415614613 // 15478749.591872748 4766690.415614613\n        const yOFf =  4766690.415614613 // -4766681.448690384;\n        const scale = 0.001;\n\n\n        let xC = 0\n        let yC = 0\n        let Count = 0\n\n        for (let i = 0; i < paths.length; ++i) {\n            const route = paths[i]\n\n            for (let j = 0; j < route.length; ++j) {\n                for (let k = 0; k < route[j].length - 1; ++k) {\n\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\n                    // xC += xPro;\n                    // yC += yPro;\n\n                    // const xPro = route[j][k][0];\n                    // const yPro = route[j][k][1];\n\n                    // const xPro1 = route[j][k+1][0];\n                    // const yPro1 = route[j][k+1][1];\n\n                    xC += xPro;\n                    yC += yPro;\n\n                    Count += 1;\n\n                    const x = (xPro - xOFf) * scale\n                    const y = (yPro - yOFf) * scale\n\n                    // console.log(x, y)\n\n\n                    // let cir = getTriFromCenter(x, y, 0, 0.03)\n                    // positions.push(cir)\n\n                    positions.push(x,y, 0)\n\n\n                    colors.push(color[0], color[1],  color[2]);\n\n                }\n\n                // positions.push(positions[positions.length-3], positions[positions.length-2], positions[positions.length-1])\n                // colors.push(color[0], color[1],  color[2]);\n\n                // positions.push(0, 0, 0)\n                // colors.push(0,0,0);\n            }\n        }\n\n        // console.log(positions)\n        // console.log(xC / Count, yC / Count )\n        // geometry.setIndex(indices);\n        // geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        // geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n        // // generateMorphTargets( geometry );\n\n        // geometry.computeBoundingSphere();\n\n        // const line = new THREE.LineSegments(geometry, material);\n        // scene.add(line);\n\n        this.pos = new Float32Array(positions.flat());\n        this.colors = new Float32Array(colors.flat());\n        // this.pos = new Float32Array([ 1, 1, 0,   -1, 1, 0,   -1, -1, 0,   1, 1, 0,    -1, -1, 0,    1, -1, 0]);\n    };\n}\n\nconst getTriFromCenter = (x: number, y: number, z: number = 0.0, size = 1) => {\n    size *= 0.5;\n    return [ \n        x + size,  y + size, z,   \n        x - size,  y + size, z,  \n        x - size,  y - size, z,   \n        x + size,  y + size, z,    \n        x - size,  y - size, z,    \n        x + size,  y - size, z\n    ];\n};","// import { InitGPU, CreateGPUBuffer, CreateGPUBufferUint, CreateTransforms, CreateViewProjection, CreateAnimation } from './helper';\n// import { Shaders } from './shaders';\n// import { vec3, mat4 } from 'gl-matrix';\n// const createCamera = require('3d-view-controls');\n\n\nimport { vec3, mat4 } from 'gl-matrix';\nimport { createTransforms, loadWGSL } from '../../../lib';\n\nimport { Geometry } from './Geometry';\n\nimport { Scene } from '../../Scene';\nimport { ObjectBase } from '../Base/ObjectBase';\n\nconst vertPath = require('./shaders/vert.glsl');\nconst fragPath = require('./shaders/frag.glsl');\n\nexport class NGeojsonPoint extends ObjectBase {\n\n    numberOfVertices: number = 0;\n    vertexBuffer;\n    colorBuffer;\n    normalBuffer;\n    uvBuffer;\n    uniformBindGroup;\n    uniformBindGroup1;\n    uniformBindGroup2;\n    uniformBuffer;\n\n    commandEncoder;\n\n    textureView;\n    renderPassDescription;\n    pipeline: GPURenderPipeline;\n\n    isAnimation = false;\n\n    mouseBuffer;\n    frameBuffer;\n\n    t: number = 0;\n\n    resultBuffer;\n\n    geometry: Geometry;\n\n    posLoc;\n    buf;\n    buf2;\n    colorLoc;\n\n    frameLoc;\n    mouseLoc;\n\n\n    constructor(scene: Scene) {\n        super(scene)\n\n\n        this.init();\n    }\n    async init () {\n        this.geometry = new Geometry();\n        await this.geometry.init();\n        console.log(this.geometry)\n\n        \n        const vertShader = await loadWGSL(vertPath);\n        const fragShader = await loadWGSL(fragPath);\n        \n        const gl = this.gl;\n\n        this.vertexBuffer = gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.geometry.pos, gl.STATIC_DRAW);\n\n        this.colorBuffer = gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.geometry.colors, gl.STATIC_DRAW);\n\n\n        this.program = gl.createProgram();\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertShader as string);\n        gl.compileShader(vertexShader);\n        gl.attachShader(this.program, vertexShader);\n\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragShader as string);\n        gl.compileShader(fragmentShader);\n        gl.attachShader(this.program, fragmentShader);\n\n        gl.linkProgram(this.program);\n\n\n        // this.posLoc = gl.getAttribLocation(this.program, 'position');\n        // this.colorLoc = gl.getAttribLocation(this.program, 'color');\n\n        // this.buf = gl.createBuffer();\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.buf);\n        // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.geometry.pos), gl.STATIC_DRAW);\n        // normally these would happen at render time\n\n\n        // this.buf2 = gl.createBuffer();\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.buf2);\n        // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.geometry.colors), gl.STATIC_DRAW);\n\n        \n        this.modelLoc = gl.getUniformLocation(this.program, 'uModel');\n        this.cameraLoc = gl.getUniformLocation(this.program, 'cameraProjection');\n\n        \n        this.frameLoc = gl.getUniformLocation(this.program, 'uFrame');\n        this.mouseLoc = gl.getUniformLocation(this.program, 'uMouse');\n\n        this.isRenderable = true;\n    }\n    render() {\n        \n        if (!this.isRenderable) { return; }\n        // console.log('dd');\n        // const gl = this.gl;\n        createTransforms(this.modelMatrix, this.translation, this.rotation, this.scale);\n\n        this.gl.useProgram(this.program);\n\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n        this.gl.enableVertexAttribArray(0);\n        this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, false, 0, 0);\n\n        \n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n        this.gl.enableVertexAttribArray(1);\n        this.gl.vertexAttribPointer(1, 3, this.gl.FLOAT, false, 0, 0);\n        \n\n        this.gl.uniformMatrix4fv(this.modelLoc, false, this.modelMatrix);\n        this.gl.uniformMatrix4fv(this.cameraLoc, false, this.scene.core.renderer.cameraController.getMatrix);\n\n        this.gl.uniform1f(this.frameLoc, this.t);\n        this.gl.uniform2f(this.mouseLoc, this.scene.core.renderer.cameraController.pos[0] * 0.01, this.scene.core.renderer.cameraController.pos[1] * 0.01);\n\n        // console.log(this.scene.core.renderer.cameraController.pos);\n        \n        // this.gl.drawArrays(this.gl.POINTS, 0, this.geometry.pos.length / 3);\n        this.gl.drawArrays(this.gl.POINTS, 0, this.geometry.pos.length / 3);\n\n        this.t += 0.1;\n    }\n}\n","import { Core } from '../'\nimport { ObjectBase } from '../Object/Base/ObjectBase';\n\nimport { Cube } from '../Object/Cube';\nimport { CubeColor } from '../Object/CubeColor';\nimport { Triangle } from '../Object/Triangle';\n\nimport { NGeojsonLine } from '../Object/NGeojsonLine';\nimport { NGeojsonPoint } from '../Object/NGeojsonPoint';\n\nexport class Scene {\n    public core: Core;\n    public objectList: ObjectBase[] = [];\n\n    constructor(core: Core) {\n        this.core = core;\n    }\n    public async init() {\n\n       \n        // for(let i = -5 ; i < 5; ++i) {\n        //     new Cube(this, i * 2, -1);\n        //     new Triangle(this, i * 2, 1);\n        // }\n        \n        // new Triangle(this, -1, -1, -1);\n        // new Cube(this);\n        // new CubeColor(this);\n\n        new NGeojsonLine(this);\n\n        new NGeojsonPoint(this);\n    }\n    public render() {\n        for(let i = 0 ; i < this.objectList.length; ++i) {\n            this.objectList[i].render();\n        }\n    }\n    public add(object: ObjectBase) {\n        this.objectList.push(object)\n    }\n}","import { Solution } from '../';\r\n\r\nimport { Renderer } from './Renderer';\r\nimport { Scene } from './Scene';\r\n\r\n// import * as triangle from './Object/Tri/triangle';\r\n\r\n\r\nexport class Core {\r\n    public id: string;\r\n    public renderer: Renderer;\r\n    public scene: Scene;\r\n\r\n    constructor(id: string) {\r\n        this.id = id;\r\n\r\n        this.init();\r\n    }\r\n    async init() {\r\n        this.renderer = new Renderer(this);\r\n        this.scene = new Scene(this)\r\n        this.scene.init();\r\n\r\n        this.renderer.draw();\r\n        \r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        // console.log('destroy!!');\r\n        // this.divHost.removeChild(this.canvas);\r\n    }\r\n}\r\n\r\n\r\n","\r\nimport { Core } from './Core';\r\n\r\nexport class Solution {\r\n    public core: Core;\r\n    constructor(id: string) {\r\n\r\n        this.core = new Core(id)\r\n    }\r\n    public destroy() {\r\n       this.core.destroy();\r\n    }\r\n}\r\n\r\n\r\n"],"names":["Camera","constructor","width","height","cameraPosition","center","up","distance","viewMatrix","mat4","projectionMatrix","viewProjectionMatrix","zoomMax","zoomSpeed","near","far","mvpMatrix","eye","vec3","type","respectRatio","angleXY","Math","PI","angleZ","this","zoom","v","update","CameraPerspective","super","init","CameraOrth","projection","dst","scale","CameraController","renderer","canvas","cameraOrth","cameraPerspective","camera","modelMatrix","rotation","translation","screen2","vec2","pos","isDown","isShift","arcRotation","appendEvent","createTransforms","rotateZ","val","translateX","getMatrix","shiftCamera","moveCamera","x","y","pan","panPerspective","sin","cos","zoomWheel","addEventListener","e","offsetX","offsetY","xOff","yOff","getBoundingClientRect","deltaY","window","k","key","shiftKey","modelMat","scaling","rotateXMat","rotateYMat","rotateZMat","translateMat","scaleMat","Renderer","core","gl","cameraController","divHost","isActive","document","getElementById","id","createElement","appendChild","clientWidth","clientHeight","getContext","draw","requestAnimationFrame","viewport","enable","CULL_FACE","DEPTH_TEST","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","scene","render","destroy","removeChild","loadWGSL","async","fetch","path","then","response","text","catch","err","console","debug","Geometry","streetOSM","colors","renderLines","paths","color","positions","indices","xOFf","yOFf","xC","yC","Count","i","length","route","j","xPro","yPro","MercatorProjection","xPro1","yPro1","x1","y1","push","floor","Float32Array","flat","getJSONFromURL","data","ObjectBase","program","modelLoc","cameraLoc","isRenderable","add","vertPath","require","fragPath","NGeojsonLine","numberOfVertices","vertexBuffer","colorBuffer","normalBuffer","uvBuffer","uniformBindGroup","uniformBindGroup1","uniformBindGroup2","uniformBuffer","commandEncoder","textureView","renderPassDescription","pipeline","isAnimation","mouseBuffer","frameBuffer","t","resultBuffer","geometry","posLoc","buf","buf2","colorLoc","frameLoc","mouseLoc","log","vertShader","fragShader","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createProgram","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","attachShader","fragmentShader","FRAGMENT_SHADER","linkProgram","getUniformLocation","useProgram","enableVertexAttribArray","vertexAttribPointer","FLOAT","uniformMatrix4fv","uniform1f","uniform2f","drawArrays","LINES","NGeojsonPoint","POINTS","Scene","objectList","object","Core","Solution"],"sourceRoot":""}