{"version":3,"file":"static/js/13134.fe838679.chunk.js","mappings":"yIAMO,MAAMA,EAGTC,oBAAoBC,EAAgBC,GAChC,IAAIC,EAAkBC,KAAKC,sBAAsBJ,EAAIC,GAGrD,OADAC,EAAIG,KAAKL,EAAGA,EAAGM,OAAS,IACjBJ,CAEX,CACA,6BAAqCF,EAAgBC,GACjD,GAAID,EAAGM,QAAU,EACb,MAAO,CAACN,EAAG,IAEf,IAMIO,EANAC,EAA2B,GAE3BC,EAAK,IAAIC,EAAKV,EAAG,GAAIA,EAAGA,EAAGM,OAAS,IAEpCK,EAAc,EACdC,EAAmB,EAEvB,IAAK,IAAIC,EAAI,EAAGA,GAAKb,EAAGM,OAAS,EAAGO,IAAK,CACrC,IAAIC,EAAWL,EAAGM,gBAAgBf,EAAGa,IACjCC,EAAWH,IACXA,EAAcG,EACdF,EAAmBC,EAE3B,CAeA,OAbIF,GAAeV,GACfM,EAAIP,EAAGY,GACPH,EAAGM,gBAAgBR,GAEnBC,EAAeA,EAAaQ,OAAOb,KAAKC,sBAAsBJ,EAAGiB,MAAM,EAAGL,EAAmB,GAAIX,IAEjGO,EAAeA,EAAaQ,OAAOb,KAAKC,sBAAsBJ,EAAGiB,MAAML,EAAkBZ,EAAGM,QAASL,MAGrGM,EAAIP,EAAGY,GACPH,EAAGM,gBAAgBR,GACnBC,EAAe,CAACR,EAAG,KAEhBQ,CACX,CACAU,cAAe,KA3CflB,QAAE,OACFmB,QAAE,CA4CF,CACAC,aAAapB,EAAgBC,GACzB,IAAIC,EAAkBC,KAAKC,sBAAsBJ,EAAIC,GAGrD,OADAC,EAAIG,KAAKL,EAAGA,EAAGM,OAAS,IACjBJ,CAEX,CACAE,sBAAsBJ,EAAgBC,GAClC,GAAID,EAAGM,QAAU,EACb,MAAO,CAACN,EAAG,IAEf,IAMIO,EANAC,EAA2B,GAE3BC,EAAK,IAAIC,EAAKV,EAAG,GAAIA,EAAGA,EAAGM,OAAS,IAEpCK,EAAc,EACdC,EAAmB,EAEvB,IAAK,IAAIC,EAAI,EAAGA,GAAKb,EAAGM,OAAS,EAAGO,IAAK,CACrC,IAAIC,EAAWL,EAAGM,gBAAgBf,EAAGa,IACjCC,EAAWH,IACXA,EAAcG,EACdF,EAAmBC,EAE3B,CAeA,OAbIF,GAAeV,GACfM,EAAIP,EAAGY,GACPH,EAAGM,gBAAgBR,GAEnBC,EAAeA,EAAaQ,OAAOb,KAAKC,sBAAsBJ,EAAGiB,MAAM,EAAGL,EAAmB,GAAIX,IAEjGO,EAAeA,EAAaQ,OAAOb,KAAKC,sBAAsBJ,EAAGiB,MAAML,EAAkBZ,EAAGM,QAASL,MAGrGM,EAAIP,EAAGY,GACPH,EAAGM,gBAAgBR,GACnBC,EAAe,CAACR,EAAG,KAEhBQ,CACX,EAGJ,MAAME,EAGFQ,YAAYG,EAAcC,GAAe,KAFzCD,QAAE,OACFC,QAAE,EAEEnB,KAAKkB,GAAKA,EACVlB,KAAKmB,GAAKA,CACd,CACAP,gBAAgBR,GAEZ,IAAIgB,GAAKpB,KAAKmB,GAAGE,EAAIrB,KAAKkB,GAAGG,IAAMrB,KAAKmB,GAAGG,EAAItB,KAAKkB,GAAGI,GAEnDC,EAAIvB,KAAKkB,GAAGG,EAAKD,EAAIpB,KAAKkB,GAAGI,EAC7BE,EAAI,GAQR,OANAA,EAAEtB,KAAKuB,KAAKC,IAAItB,EAAEiB,EAAKD,EAAIhB,EAAEkB,EAAKC,GAAKE,KAAKE,KAAKF,KAAKG,IAAIR,EAAG,GAAK,IAElEI,EAAEtB,KAAKuB,KAAKE,KAAKF,KAAKG,IAAKxB,EAAEkB,EAAItB,KAAKkB,GAAGI,EAAI,GAAKG,KAAKG,IAAKxB,EAAEiB,EAAIrB,KAAKkB,GAAGG,EAAI,KAE9EG,EAAEtB,KAAKuB,KAAKE,KAAKF,KAAKG,IAAKxB,EAAEkB,EAAItB,KAAKmB,GAAGG,EAAI,GAAKG,KAAKG,IAAKxB,EAAEiB,EAAIrB,KAAKmB,GAAGE,EAAI,KAEvEG,EAAEK,MAAK,CAACC,EAAIC,IAAiBD,EAAKC,IAAQ,EACrD,E","sources":["njslab/Workshop/workshop-ml/SmartDrawingApp/Lib/DouglasPeucker.ts"],"sourcesContent":["import { NVector3 } from './NVector3';\r\nimport { NLine } from './NLine';\r\n\r\n// // https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\r\n// // reference https://gist.github.com/adammiller/826148 /\r\n\r\nexport class DouglasPeucker {\r\n    vs: NVector3[];\r\n    ls: NLine[];\r\n    static SimplifyPath(vs: NVector3[], tolerance: number) {\r\n        let arr: NVector3[] = this.ComputeDouglasPeucker(vs, tolerance);\r\n        // always have to push the very last point on so it doesn't get left off\r\n        arr.push(vs[vs.length - 1]);\r\n        return arr;\r\n\r\n    }\r\n    private static ComputeDouglasPeucker(vs: NVector3[], tolerance: number) {\r\n        if (vs.length <= 2) {\r\n            return [vs[0]];\r\n        }\r\n        let returnPoints: NVector3[] = [],\r\n            // make line from start to end\r\n            ln = new Line(vs[0], vs[vs.length - 1]),\r\n            // find the largest distance from intermediate poitns to this line\r\n            maxDistance = 0,\r\n            maxDistanceIndex = 0,\r\n            p;\r\n        for (var i = 1; i <= vs.length - 2; i++) {\r\n            var distance = ln.DistanceToPoint(vs[i]);\r\n            if (distance > maxDistance) {\r\n                maxDistance = distance;\r\n                maxDistanceIndex = i;\r\n            }\r\n        }\r\n        // check if the max distance is greater than our tollerance allows\r\n        if (maxDistance >= tolerance) {\r\n            p = vs[maxDistanceIndex];\r\n            ln.DistanceToPoint(p);\r\n            // include this point in the output\r\n            returnPoints = returnPoints.concat(this.ComputeDouglasPeucker(vs.slice(0, maxDistanceIndex + 1), tolerance));\r\n            // returnPoints.push( points[maxDistanceIndex] );\r\n            returnPoints = returnPoints.concat(this.ComputeDouglasPeucker(vs.slice(maxDistanceIndex, vs.length), tolerance));\r\n        } else {\r\n            // ditching this point\r\n            p = vs[maxDistanceIndex];\r\n            ln.DistanceToPoint(p);\r\n            returnPoints = [vs[0]];\r\n        }\r\n        return returnPoints;\r\n    }\r\n    constructor() {\r\n        /* */\r\n    }\r\n    SimplifyPath(vs: NVector3[], tolerance: number) {\r\n        let arr: NVector3[] = this.ComputeDouglasPeucker(vs, tolerance);\r\n        // always have to push the very last point on so it doesn't get left off\r\n        arr.push(vs[vs.length - 1]);\r\n        return arr;\r\n\r\n    }\r\n    ComputeDouglasPeucker(vs: NVector3[], tolerance: number) {\r\n        if (vs.length <= 2) {\r\n            return [vs[0]];\r\n        }\r\n        let returnPoints: NVector3[] = [],\r\n            // make line from start to end\r\n            ln = new Line(vs[0], vs[vs.length - 1]),\r\n            // find the largest distance from intermediate poitns to this line\r\n            maxDistance = 0,\r\n            maxDistanceIndex = 0,\r\n            p;\r\n        for (var i = 1; i <= vs.length - 2; i++) {\r\n            var distance = ln.DistanceToPoint(vs[i]);\r\n            if (distance > maxDistance) {\r\n                maxDistance = distance;\r\n                maxDistanceIndex = i;\r\n            }\r\n        }\r\n        // check if the max distance is greater than our tollerance allows\r\n        if (maxDistance >= tolerance) {\r\n            p = vs[maxDistanceIndex];\r\n            ln.DistanceToPoint(p);\r\n            // include this point in the output\r\n            returnPoints = returnPoints.concat(this.ComputeDouglasPeucker(vs.slice(0, maxDistanceIndex + 1), tolerance));\r\n            // returnPoints.push( points[maxDistanceIndex] );\r\n            returnPoints = returnPoints.concat(this.ComputeDouglasPeucker(vs.slice(maxDistanceIndex, vs.length), tolerance));\r\n        } else {\r\n            // ditching this point\r\n            p = vs[maxDistanceIndex];\r\n            ln.DistanceToPoint(p);\r\n            returnPoints = [vs[0]];\r\n        }\r\n        return returnPoints;\r\n    }\r\n\r\n}\r\nclass Line {\r\n    p0: NVector3;\r\n    p1: NVector3;\r\n    constructor(p0: NVector3, p1: NVector3) {\r\n        this.p0 = p0;\r\n        this.p1 = p1;\r\n    }\r\n    DistanceToPoint(p: NVector3) {\r\n        // slope\r\n        let m = (this.p1.y - this.p0.y) / (this.p1.x - this.p0.x),\r\n            // y offset\r\n            b = this.p0.y - (m * this.p0.x),\r\n            d = [];\r\n        // distance to the linear equation\r\n        d.push(Math.abs(p.y - (m * p.x) - b) / Math.sqrt(Math.pow(m, 2) + 1));\r\n        // distance to p0\r\n        d.push(Math.sqrt(Math.pow((p.x - this.p0.x), 2) + Math.pow((p.y - this.p0.y), 2)));\r\n        // distance to p1\r\n        d.push(Math.sqrt(Math.pow((p.x - this.p1.x), 2) + Math.pow((p.y - this.p1.y), 2)));\r\n        // return the smallest distance\r\n        return d.sort((aa, bb) => { return (aa - bb); })[0]; // causes an array to be sorted numerically and ascending;\r\n    }\r\n}"],"names":["DouglasPeucker","static","vs","tolerance","arr","this","ComputeDouglasPeucker","push","length","p","returnPoints","ln","Line","maxDistance","maxDistanceIndex","i","distance","DistanceToPoint","concat","slice","constructor","ls","SimplifyPath","p0","p1","m","y","x","b","d","Math","abs","sqrt","pow","sort","aa","bb"],"sourceRoot":""}