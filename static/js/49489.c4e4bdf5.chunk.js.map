{"version":3,"file":"static/js/49489.c4e4bdf5.chunk.js","mappings":"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","sources":["lib/NJSCore/Core/DataStructure/DiscreteSpatial/MQuadTree.ts","njslab/Tools/QuadTree/index.ts"],"sourcesContent":["// import { NVector3 } from '../../Geometry/NVector3';\r\n\r\n// // http://blog.sklambert.com/html5-canvas-game-2d-collision-detection\r\n// https://gamedevelopment.tutsplus.com/tutorials/quick-tip-use-quadtrees-to-detect-likely-collisions-in-2d-space--gamedev-374\r\n// https://gamedevelopment.tutsplus.com/tutorials/make-your-game-pop-with-particle-effects-and-quadtrees--gamedev-2138\r\nexport class Shape {\r\n    constructor() {\r\n        /* */\r\n    }\r\n}\r\nexport class Rectangle {\r\n    _x: number;\r\n    _y: number;\r\n    _width: number;\r\n    _height: number;\r\n    constructor(x: number, y: number, width: number, height: number) {\r\n        this._x = x; this._y = y;\r\n        this._width = width; this._height = height;\r\n    }\r\n    public get x() { return this._x; }\r\n    public set x(v: number) { this._x = v; }\r\n    public get y() { return this._y; }\r\n    public set y(v: number) { this._y = v; }\r\n    public get width() { return this._width; }\r\n    public set width(v: number) { this._width = v; }\r\n    public get height() { return this._height; }\r\n    public set height(v: number) { this._height = v; }\r\n}\r\n\r\nexport class MQuadTree {\r\n    MAX_OBJECTS: number = 100;\r\n    MAX_LEVELS: number = 5;\r\n\r\n    level: number;\r\n    objects: Rectangle[];\r\n\r\n    bounds: Rectangle;\r\n    nodes: MQuadTree[] | undefined[];\r\n\r\n    public static exe() {\r\n\r\n        let allObjects: Rectangle[] = [];\r\n\r\n        let quad = new MQuadTree(0, new Rectangle(0, 0, 600, 600));\r\n        quad.clear();\r\n        for (let i = 0; i < allObjects.length; i++) {\r\n            quad.insert(allObjects[i]);\r\n        }\r\n\r\n        let returnObjects: Rectangle[] = [];\r\n        for (let i = 0; i < allObjects.length; i++) {\r\n            quad.retrieve(returnObjects, allObjects[i]);\r\n\r\n            for (let x = 0; x < returnObjects.length; ++x) {\r\n                // Run collision detection algorithm between objects\r\n            }\r\n        }\r\n    }\r\n    constructor(pLevel: number, pBounds: Rectangle) {\r\n        this.level = pLevel;\r\n        this.objects = [];\r\n        this.bounds = pBounds;\r\n        this.nodes = [];\r\n    }\r\n    public clear() {\r\n        this.objects = []; // .clear();\r\n\r\n        for (let i = 0; i < this.nodes.length; i++) {\r\n            if (!!this.nodes[i]) {\r\n                this.nodes[i] = undefined;\r\n            }\r\n        }\r\n    }\r\n    public split() {\r\n        let subWidth = (this.bounds.width / 2);\r\n        let subHeight = (this.bounds.height / 2);\r\n        let x = this.bounds.x;\r\n        let y = this.bounds.y;\r\n\r\n        this.nodes[0] = new MQuadTree(this.level + 1, new Rectangle(x + subWidth, y, subWidth, subHeight));\r\n        this.nodes[1] = new MQuadTree(this.level + 1, new Rectangle(x, y, subWidth, subHeight));\r\n        this.nodes[2] = new MQuadTree(this.level + 1, new Rectangle(x, y + subHeight, subWidth, subHeight));\r\n        this.nodes[3] = new MQuadTree(this.level + 1, new Rectangle(x + subWidth, y + subHeight, subWidth, subHeight));\r\n    }\r\n    public getIndex(pRect: Rectangle): number {\r\n        let index = -1;\r\n        let verticalMidpoint = this.bounds.x + (this.bounds.width / 2);\r\n        let horizontalMidpoint = this.bounds.y + (this.bounds.height / 2);\r\n\r\n        // Object can completely fit within the top quadrants\r\n        let topQuadrant = (pRect.y < horizontalMidpoint && pRect.y + pRect.height < horizontalMidpoint);\r\n        // Object can completely fit within the bottom quadrants\r\n        let bottomQuadrant = (pRect.y > horizontalMidpoint);\r\n\r\n        // Object can completely fit within the left quadrants\r\n        if (pRect.x < verticalMidpoint && pRect.x + pRect.width < verticalMidpoint) {\r\n            if (topQuadrant) { index = 1; } else if (bottomQuadrant) { index = 2; }\r\n        } else if (pRect.x > verticalMidpoint) { // Object can completely fit within the right quadrants\r\n            if (topQuadrant) { index = 0; } else if (bottomQuadrant) { index = 3; }\r\n        }\r\n        return index;\r\n    }\r\n    public insert(pRect: Rectangle) {\r\n        if (this.nodes[0] !== undefined) {\r\n            let index = this.getIndex(pRect);\r\n            if (index !== -1) {\r\n                let n = this.nodes[index];\r\n                if (n) { n.insert(pRect); }\r\n                return;\r\n            }\r\n        }\r\n        this.objects.push(pRect);\r\n\r\n        if (this.objects.length > this.MAX_OBJECTS && this.level < this.MAX_LEVELS) {\r\n            if (this.nodes[0] === undefined) {\r\n                this.split();\r\n            }\r\n            let i = 0;\r\n            while (i < this.objects.length) {\r\n                let index = this.getIndex(this.objects[i]);\r\n                if (index !== -1) {\r\n                    let n = this.nodes[index];\r\n                    if (n) { n.insert((this.objects.splice(i, 1))[0]); }\r\n                } else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    public retrieve(returnObjects: Rectangle[], pRect: Rectangle) {\r\n        let index = this.getIndex(pRect);\r\n        if (index !== -1 && this.nodes[0] !== undefined) {\r\n            let n = this.nodes[index];\r\n            if (n) { n.retrieve(returnObjects, pRect); }\r\n        }\r\n\r\n        for (let i = 0, len = this.objects.length; i < len; i++) {\r\n            returnObjects.push(this.objects[i]);\r\n        }\r\n        return returnObjects;\r\n    }\r\n}\r\n// ...................................................................\r\nexport class Geo {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    speed = 0;\r\n    canvasWidth = 0;\r\n    canvasHeight = 0;\r\n    collidableWith = '';\r\n    isColliding = false;\r\n    type = '';\r\n\r\n    constructor(x: number, y: number, width: number, height: number) {\r\n        this.x = x; this.y = y;\r\n        this.width = width; this.height = height;\r\n    }\r\n    public Draw() {\r\n        /* */\r\n    }\r\n    public Move() {\r\n        /* */\r\n    }\r\n    public IsCollidableWith(object: Geo) {\r\n        return (this.collidableWith === object.type);\r\n    }\r\n}\r\nexport class BoundBox {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n    constructor(x: number, y: number, width: number, height: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n}\r\nexport class QuadTree {\r\n    bounds: BoundBox;\r\n    nodes: QuadTree[];\r\n    objects: Geo[];\r\n\r\n    maxObjects: number;\r\n    level: number;\r\n    maxLevels: number;\r\n\r\n    constructor(boundBox: BoundBox = new BoundBox(0, 0, 0, 0), lvl: number = 0) {\r\n        this.maxObjects = 10;\r\n        this.bounds = boundBox;\r\n        this.nodes = [];\r\n        this.level = lvl;\r\n        this.maxLevels = 5;\r\n\r\n        this.objects = [];\r\n    }\r\n    public Clear() {\r\n        this.objects = [];\r\n        for (let i = 0; i < this.nodes.length; i++) {\r\n            this.nodes[i].Clear();\r\n        }\r\n        this.nodes = [];\r\n    }\r\n    /*\r\n     * Get all objects in the quadTree\r\n     */\r\n    public GetAllObjects(returnedObjects: Geo[]) {\r\n        for (let i = 0; i < this.nodes.length; i++) {\r\n            this.nodes[i].GetAllObjects(returnedObjects);\r\n        }\r\n        for (let i = 0, len = this.objects.length; i < len; i++) {\r\n            returnedObjects.push(this.objects[i]);\r\n        }\r\n        return returnedObjects;\r\n    }\r\n    /*\r\n     * Return all objects that the object could collide with\r\n     */\r\n    public FindObjects(returnedObjects: Geo[], obj: Geo) {\r\n        if (typeof obj === 'undefined') {\r\n        //     console.log('UNDEFINED OBJECT');\r\n            return undefined;\r\n        }\r\n        let index = this.GetIndex(obj);\r\n        if (index !== -1 && this.nodes.length) {\r\n            this.nodes[index].FindObjects(returnedObjects, obj);\r\n        }\r\n        for (let i = 0, len = this.objects.length; i < len; i++) {\r\n            returnedObjects.push(this.objects[i]);\r\n        }\r\n        return returnedObjects;\r\n    }\r\n    // \t/*\r\n    // \t * Insert the object into the quadTree. If the tree\r\n    // \t * excedes the capacity, it will split and add all\r\n    // \t * objects to their corresponding nodes.\r\n    // \t */\r\n    public Insert(obj: Geo) {\r\n        if (typeof obj === 'undefined') {\r\n            return;\r\n        }\r\n        if (obj instanceof Array) {\r\n            for (let i = 0, len = obj.length; i < len; i++) {\r\n                this.Insert(obj[i]);\r\n            }\r\n            return;\r\n        }\r\n        if (this.nodes.length) {\r\n            let index = this.GetIndex(obj);\r\n            // Only add the object to a subnode if it can fit completely\r\n            // within one\r\n            if (index !== -1) {\r\n                this.nodes[index].Insert(obj);\r\n                return;\r\n            }\r\n        }\r\n        this.objects.push(obj);\r\n        // Prevent infinite splitting\r\n        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\r\n            if (this.nodes[0] === null) {\r\n                this.Split();\r\n            }\r\n            let i = 0;\r\n            while (i < this.objects.length) {\r\n                let index = this.GetIndex(this.objects[i]);\r\n                if (index !== -1) {\r\n                    this.nodes[index].Insert((this.objects.splice(i, 1))[0]);\r\n                } else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // \t/*\r\n    // \t * Determine which node the object belongs to. -1 means\r\n    // \t * object cannot completely fit within a node and is part\r\n    // \t * of the current node\r\n    // \t */\r\n    public GetIndex(obj: Geo) {\r\n        let index = -1;\r\n        let verticalMidpoint = this.bounds.x + this.bounds.width / 2;\r\n        let horizontalMidpoint = this.bounds.y + this.bounds.height / 2;\r\n        // Object can fit completely within the top quadrant\r\n        let topQuadrant = (obj.y < horizontalMidpoint && obj.y + obj.height < horizontalMidpoint);\r\n        // Object can fit completely within the bottom quandrant\r\n        let bottomQuadrant = (obj.y > horizontalMidpoint);\r\n        // Object can fit completely within the left quadrants\r\n        if (obj.x < verticalMidpoint &&\r\n            obj.x + obj.width < verticalMidpoint) {\r\n            if (topQuadrant) {\r\n                index = 1;\r\n            } else if (bottomQuadrant) {\r\n                index = 2;\r\n            }\r\n        } else if (obj.x > verticalMidpoint) { // Object can fix completely within the right quandrants\r\n            if (topQuadrant) {\r\n                index = 0;\r\n            } else if (bottomQuadrant) {\r\n                index = 3;\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n    // \t/*\r\n    // \t * Splits the node into 4 subnodes\r\n    // \t */\r\n    public Split() {\r\n        // Bitwise or [html5rocks]\r\n        let subWidth = (this.bounds.width / 2) | 0;\r\n        let subHeight = (this.bounds.height / 2) | 0;\r\n        this.nodes[0] = new QuadTree({\r\n            x: this.bounds.x + subWidth,\r\n            y: this.bounds.y,\r\n            width: subWidth,\r\n            height: subHeight\r\n        }, this.level + 1);\r\n        this.nodes[1] = new QuadTree({\r\n            x: this.bounds.x,\r\n            y: this.bounds.y,\r\n            width: subWidth,\r\n            height: subHeight\r\n        }, this.level + 1);\r\n        this.nodes[2] = new QuadTree({\r\n            x: this.bounds.x,\r\n            y: this.bounds.y + subHeight,\r\n            width: subWidth,\r\n            height: subHeight\r\n        }, this.level + 1);\r\n        this.nodes[3] = new QuadTree({\r\n            x: this.bounds.x + subWidth,\r\n            y: this.bounds.y + subHeight,\r\n            width: subWidth,\r\n            height: subHeight\r\n        }, this.level + 1);\r\n    }\r\n}\r\nexport class Execute {\r\n    quadTree: QuadTree;\r\n    constructor() {\r\n        let bound = new BoundBox(0, 0, 1500, 600);\r\n        this.quadTree = new QuadTree(bound);\r\n    }\r\n    public loop() {\r\n        this.quadTree.Clear();\r\n\r\n        // this.quadTree.Insert()\r\n\r\n        this.DetectCollision();\r\n    }\r\n    public DetectCollision() {\r\n        let objects: Geo[] = [];\r\n        let obj: Geo[] = [];\r\n        this.quadTree.GetAllObjects(objects);\r\n\r\n        for (let x = 0, len = objects.length; x < len; x++) {\r\n            this.quadTree.FindObjects(obj = [], objects[x]);\r\n\r\n            for (let y = 0, length = obj.length; y < length; y++) {\r\n\r\n                // DETECT COLLISION ALGORITHM\r\n                if (objects[x].collidableWith === obj[y].type &&\r\n                    (objects[x].x < obj[y].x + obj[y].width &&\r\n                        objects[x].x + objects[x].width > obj[y].x &&\r\n                        objects[x].y < obj[y].y + obj[y].height &&\r\n                        objects[x].y + objects[x].height > obj[y].y)) {\r\n                    objects[x].isColliding = true;\r\n                    obj[y].isColliding = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","import { RendererCanvas } from '../../../lib'\r\n\r\nimport { MQuadTree, Rectangle } from '../../../lib/NJSCore/Core/DataStructure/DiscreteSpatial/MQuadTree';\r\n\r\nexport class Solution {\r\n    public divHost: HTMLElement;\r\n    public renderer: Renderer;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id)\r\n\r\n        // Center align\r\n        this.divHost.style.display = 'flex';\r\n        this.divHost.style.alignItems = 'center';\r\n\r\n        const div = document.createElement('div');\r\n        div.style.marginLeft = 'auto';\r\n        div.style.marginRight = 'auto';\r\n        div.style.backgroundColor = '#555';\r\n        div.style.width = '1000px';\r\n        div.style.height = '600px';\r\n\r\n        this.divHost.appendChild(div);\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n\r\n        this.renderer = new Renderer(div);\r\n\r\n        // console.log(this.renderer);\r\n        // !! you should execute it for rendering\r\n        // this.start();\r\n    }\r\n    public destroy() {\r\n        this.renderer.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}\r\n\r\nexport class Renderer extends RendererCanvas {\r\n    quad: MQuadTree;\r\n    allObjects: Rectangle[] = [];\r\n    constructor(div: any) {\r\n        super(div);\r\n        this.canvas.style.position = 'relative';\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n\r\n        // TODO\r\n        // You code goes here for one time operation\r\n        // \r\n\r\n        this.allObjects = [];\r\n        for (let i = 0; i < 100; ++i) {\r\n\r\n            const x = Math.random() * this.canvas.width;\r\n            const y = Math.random() * this.canvas.height;\r\n\r\n            const rect = new Rectangle(x, y, 5, 5)\r\n            this.allObjects.push(rect);\r\n        }\r\n\r\n        // console.log(this.allObjects.length)\r\n\r\n\r\n        this.quad = new MQuadTree(0, new Rectangle(0, 0, this.canvas.width, this.canvas.height));\r\n        this.quad.clear();\r\n        for (let i = 0; i < this.allObjects.length; i++) {\r\n            this.quad.insert(this.allObjects[i]);\r\n        }\r\n\r\n        let returnObjects: Rectangle[] = [];\r\n        for (let i = 0; i < this.allObjects.length; i++) {\r\n            this.quad.retrieve(returnObjects, this.allObjects[i]);\r\n\r\n            for (let x = 0; x < returnObjects.length; ++x) {\r\n                // Run collision detection algorithm between objects\r\n            }\r\n        }\r\n\r\n\r\n        this.start();\r\n    }\r\n    public render(ctx: CanvasRenderingContext2D): void {\r\n        // TODO\r\n        // You code goes here for the rending loop\r\n\r\n        for (let i = 0; i < this.quad.objects.length; ++i) {\r\n            const rect = this.quad.objects[i];\r\n\r\n            ctx.beginPath();\r\n            ctx.rect(rect.x, rect.y, rect.width, rect.height);\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        }\r\n        \r\n        // console.log(this.quad);\r\n\r\n        // console.log(this.quad.objects.length);\r\n        // console.log(this.quad.objects);\r\n\r\n\r\n        // let allObjects: Rectangle[] = [];\r\n        // for (let i = 0; i < 100; ++i) {\r\n\r\n        //     const x = Math.random() * this.canvas.width;\r\n        //     const y = Math.random() * this.canvas.height;\r\n\r\n        //     const rect = new Rectangle(x, y, 5, 5)\r\n        //     allObjects.push(rect);\r\n        // }\r\n\r\n        let returnObjects: Rectangle[] = [];\r\n        for (let i = 0; i < this.allObjects.length; i++) {\r\n            this.quad.retrieve(returnObjects, this.allObjects[i]);\r\n\r\n            for (let x = 0; x < returnObjects.length; ++x) {\r\n                // Run collision detection algorithm between objects\r\n\r\n            }\r\n            // console.log(returnObjects.length)\r\n        }\r\n\r\n\r\n        // !! can stop render after this frame.\r\n        // this.isStatic = true;\r\n    }\r\n\r\n}"],"names":["Rectangle","constructor","x","y","width","height","_x","_y","_width","_height","this","v","MQuadTree","allObjects","quad","clear","i","length","insert","returnObjects","retrieve","pLevel","pBounds","MAX_OBJECTS","MAX_LEVELS","level","objects","bounds","nodes","undefined","split","subWidth","subHeight","getIndex","pRect","index","verticalMidpoint","horizontalMidpoint","topQuadrant","bottomQuadrant","n","push","splice","len","Solution","id","divHost","renderer","document","getElementById","style","display","alignItems","div","createElement","marginLeft","marginRight","backgroundColor","appendChild","Renderer","destroy","lastElementChild","removeChild","RendererCanvas","super","canvas","position","Math","random","rect","start","render","ctx","beginPath","closePath","stroke"],"sourceRoot":""}