{"version":3,"file":"static/js/9413.ef97ecd8.chunk.js","mappings":"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","sources":["njslab/Project/Project_03_SlowZone/01_JSAPI/Tint/FilterGLViewDarkForDarken.ts","njslab/Project/Project_03_SlowZone/PointInteraction/index.ts"],"sourcesContent":["import { NVector3, GLShaderCommon } from '../../../../../lib/NJSCore';\n\n// import { Mat3 } from '../../AppCore/GLUtility/Mat3';\n\nexport class FilterGLViewDarkForDarken {\n\n    gl: WebGLRenderingContext;\n    program: WebGLProgram;\n    fragmentShader: WebGLShader;\n    vertexShader: WebGLShader;\n    matrixLocation: WebGLProgram;\n    posBuffer: WebGLBuffer;\n    colBuffer: WebGLBuffer;\n    vertexs: Float32Array;\n\n    posLocAtt: number;\n    colLocAtt: number;\n    matLoc: WebGLUniformLocation;\n    colLoc: WebGLUniformLocation;\n    cVecLoc: WebGLUniformLocation;\n    mouseLoc: WebGLUniformLocation;\n    timeGL: WebGLUniformLocation;\n    // startTime: number;\n    // randomSeed: number;\n\n    vShader: WebGLShader;\n    fShader: WebGLShader;\n\n    v = `\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    \n    varying vec4 f_color;\n\n    void main() {\n\n        vec2 mouse_distance = vec2(0,0) - (a_position.xy /vec2(2,2));\n        float red = 1.0 - length(mouse_distance);\n        f_color = vec4(a_position, 0, 1.0);\n    \n        // float dis = distance(vec2(a_position.xy), vec2(0,0));\n\n        // f_color = vec4(dis * 0.6, 0,0,1);\n        gl_Position = vec4( a_position, 0, 1);\n    }\n    `;\n\n    f = `\n    precision highp float;\n\n    varying vec4 f_color;\n    \n    void main() {\n        vec2 mouse_distance = vec2(0,0) - (f_color.xy /vec2(5,5));\n\n        float col =  length(mouse_distance*5.);\n        float val = 1.0 - length(mouse_distance*8.);\n        \n        gl_FragColor = vec4(0.19,0.19,0.19, col);\n\n    }\n    `;\n\n    positionAttribLocation: WebGLProgram;\n    colorAttribLocation: WebGLProgram;\n    translation: NVector3;\n    color: number[];\n    colArray: Float32Array;\n\n    constructor(gl: WebGLRenderingContext, xt: number = 100, yt: number = 100, zt: number = 0, xs: number = 1, ys: number = 1, zs: number = 1) {\n        this.gl = gl;\n        // this.translation = new NVector3(xt, yt, zt);\n        // this.angleInRadians = 0;\n        // this.scale = new NVector3(xs, ys, zs);\n        this.color = [Math.random(), Math.random(), Math.random(), 1];\n        this.InitShader();\n    }\n    InitShader() {\n        // let vShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.VERTEX_SHADER,'/shader/vsCanvas.glsl');\n        // let fShader = GLUtility.CreateShaderFromPath(this.gl, this.gl.FRAGMENT_SHADER, '/shader/fsColor.glsl');\n\n        let vShader = GLShaderCommon.CreateShader(this.gl, this.gl.VERTEX_SHADER, this.v); // '/shader/vsCanvas.glsl');\n        let fShader = GLShaderCommon.CreateShader(this.gl, this.gl.FRAGMENT_SHADER, this.f); // '/shader/fsColor.glsl');\n\n        if (vShader && fShader) {\n            this.vShader = vShader;\n            this.fShader = fShader;\n            let program = GLShaderCommon.CreateProgram(this.gl, vShader, fShader);\n            if (program) { this.program = program; }\n        }\n\n        // this.InitVerext();\n    }\n    Render(gl: WebGLRenderingContext) {\n\n        let col = [0.1, 0, 0, 1];\n\n        this.vertexs = new Float32Array([\n            // left column\n            -1, -1, 1, 1, 1, 1,\n            - 1, 1, col[0], col[1], col[2], col[3],\n            1, -1, col[0], col[1], col[2], col[3],\n\n            -1, 1, 1, 1, 1, 1,\n            1, -1, col[0], col[1], col[2], col[3],\n            1, 1, col[0], col[1], col[2], col[3],\n\n        ]);\n\n        this.posBuffer = this.gl.createBuffer() as WebGLBuffer;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.posBuffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(this.vertexs), gl.STATIC_DRAW);\n\n        this.posLocAtt = this.gl.getAttribLocation(this.program, 'a_position');\n        // Tell the attribute how to get data out of posBuffer (ARRAY_BUFFER)\n        let size = 2;          // 2 components per iteration\n        let type = gl.FLOAT;   // the data is 32bit floats\n        let normalize = false; // don't normalize the data\n        let stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        let offset = 0;        // start at the beginning of the buffer\n        gl.vertexAttribPointer(this.posLocAtt, size, type, normalize, stride, offset);\n        gl.enableVertexAttribArray(this.posLocAtt);\n\n        // this.colLocAtt = this.gl.getAttribLocation(this.program, 'a_color');\n        // size = 4;          // 2 components per iteration\n        // type = gl.FLOAT;   // the data is 32bit floats\n        // normalize = false; // don't normalize the data\n        // stride = 6 * Float32Array.BYTES_PER_ELEMENT; // 0 = move forward size * sizeof(type) each iteration to get the next position\n        // offset = 2 * Float32Array.BYTES_PER_ELEMENT;        // start at the beginning of the buffer\n        // gl.vertexAttribPointer(this.colLocAtt, size, type, normalize, stride, offset);\n        // gl.enableVertexAttribArray(this.colLocAtt);\n\n        gl.useProgram(this.program);\n        let primitiveType = gl.TRIANGLES; // LINE_LOOP; // gl.TRIANGLE_STRIP;\n        offset = 0;\n        let count = 6; // this.vertexs.length * 0.5;\n        gl.drawArrays(primitiveType, offset, count);\n\n    }\n}","import * as THREE from 'three';\r\nimport { RendererThree, MercatorProjection, } from '../../../../lib';\r\nimport { getJSONFromURL, distanceTo } from 'njscore';\r\n\r\nimport { FilterGLViewDarkForDarken } from '../01_JSAPI/Tint/FilterGLViewDarkForDarken';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    streetOSM: any = [];\r\n    routesTreated: any = [];\r\n    routesControl: any = [];\r\n    zones30: any = [];\r\n\r\n    positions;\r\n    geometry;\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    pointer = new THREE.Vector2();\r\n\r\n    mesh: THREE.Points;\r\n\r\n    sphere: THREE.Mesh;\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const light = new THREE.PointLight(0xffffff, 0.8);\r\n        this.camera.add(light);\r\n        this.scene.add(light);\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Points.threshold = 0.8;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n\r\n        const canvasGL = document.createElement('canvas');\r\n        canvasGL.style.position = 'absolute';\r\n        canvasGL.style.pointerEvents = 'none';\r\n        canvasGL.style.mixBlendMode = 'darken';\r\n        canvasGL.width = this.hostDiv.clientWidth;\r\n        canvasGL.height = this.hostDiv.clientHeight;\r\n        this.hostDiv.appendChild(canvasGL);\r\n        const glCtx = canvasGL.getContext('webgl');\r\n        const d = new FilterGLViewDarkForDarken(glCtx, 0.5, 5)\r\n        d.Render(glCtx);\r\n\r\n        this.camera.position.set(0, 40, 48);\r\n\r\n        // const path = '/static/research/slow-zone/';\r\n        // getJSONFromURL(process.env.PUBLIC_URL + path + 'street_osm.geojson').then((data) => {\r\n        getJSONFromURL('https://raw.githubusercontent.com/NamjuLee/data/master/Paris/street_osm.geojson').then((data) => {\r\n            for (let i = 0; i < data['features'].length; ++i) {\r\n                this.streetOSM.push(data['features'][i]['geometry']['coordinates']);\r\n            }\r\n            renderLines(this.scene, this.streetOSM, [0, 0.8, 0.7]);\r\n            this.renderPoints(this.scene, this.streetOSM, [0, 1, 1]);\r\n\r\n            this.start();\r\n        });\r\n\r\n\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n\r\n        this.pointer.x = (e.offsetX / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (e.offsetY / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        // console.log(this.pointer)\r\n\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersections = this.raycaster.intersectObjects([this.mesh], false);\r\n        const intersection = (intersections.length) > 0 ? intersections[0] : null;\r\n\r\n        if (intersection !== null) {\r\n            // console.log(intersection.point.x, intersection.point.y, intersection.point.z);\r\n            this.sphere.position.set(intersection.point.x, intersection.point.y, intersection.point.z);\r\n        }\r\n\r\n\r\n\r\n        let numVertices = this.mesh.geometry.attributes.position.count;\r\n        for (let i = 0; i < numVertices; i++) {\r\n            let o = this.mesh.geometry.attributes.position;\r\n\r\n            let x = o.getX(i);\r\n            let y = o.getY(i);\r\n            let z = o.getZ(i)\r\n\r\n            y = Math.sin(5 * x * z + this.t * 5) * 9\r\n\r\n\r\n            y = y < 0 ? 0 : y;\r\n\r\n            let p = new THREE.Vector3(x, y, z);\r\n\r\n            this.mesh.geometry.attributes.position.setXYZ(i, p.x, p.y, p.z);\r\n\r\n            if (intersection !== null) {\r\n                y = distanceTo(x, y, z, intersection.point.x, intersection.point.y, intersection.point.z) / 30\r\n            }\r\n\r\n\r\n            this.mesh.geometry.attributes.color.setXYZ(i, y, 1 - y, 0);\r\n            // console.log(y)\r\n        }\r\n\r\n        // set to true each time you modify the positions:\r\n        this.mesh.geometry.attributes.position.needsUpdate = true;\r\n        this.mesh.geometry.attributes.color.needsUpdate = true;\r\n        this.mesh.geometry.computeVertexNormals();\r\n\r\n    }\r\n\r\n    renderPoints = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n        const geometry = new THREE.BufferGeometry();\r\n        const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.75 });\r\n\r\n        const positions = [];\r\n        const colors = [];\r\n\r\n\r\n        const xOFf = -15478803.88731685;\r\n        const yOFf = -4766681.448690384;\r\n        const scale = 0.01;\r\n\r\n\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const route = paths[i]\r\n\r\n            for (let j = 0; j < route.length; ++j) {\r\n                for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                    const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n\r\n                    const x = (xPro + xOFf) * scale\r\n                    const y = (yPro + yOFf) * scale\r\n\r\n                    positions.push(x, 0, y)\r\n\r\n                    colors.push(color[0], color[1], color[2]);\r\n\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        // generateMorphTargets( geometry );\r\n\r\n        geometry.computeBoundingSphere();\r\n        this.positions = positions;\r\n        this.geometry = geometry;\r\n        this.mesh = new THREE.Points(geometry, material);\r\n        scene.add(this.mesh);\r\n\r\n    }\r\n}\r\nconst renderLines = (scene: THREE.Scene, paths: any, color: number[]) => {\r\n    const geometry = new THREE.BufferGeometry();\r\n    const material = new THREE.LineBasicMaterial(\r\n        { vertexColors: true, linewidth: 0.01 }\r\n    );\r\n\r\n    const positions = [];\r\n    const colors = [];\r\n    const indices = [];\r\n\r\n    const xOFf = -15478803.88731685;\r\n    const yOFf = -4766681.448690384;\r\n    const scale = 0.01;\r\n\r\n\r\n    let xC = 0\r\n    let yC = 0\r\n    let Count = 0\r\n\r\n    for (let i = 0; i < paths.length; ++i) {\r\n        const route = paths[i]\r\n\r\n        for (let j = 0; j < route.length; ++j) {\r\n            for (let k = 0; k < route[j].length; ++k) {\r\n\r\n                const [xPro, yPro] = MercatorProjection(route[j][k][0], route[j][k][1]);\r\n                xC += xPro;\r\n                yC += yPro;\r\n                Count += 1;\r\n\r\n                const x = (xPro + xOFf) * scale\r\n                const y = (yPro + yOFf) * scale\r\n                // console.log(x, y)\r\n                positions.push(x, 0, y)\r\n\r\n                colors.push(color[0], color[1], color[2]);\r\n\r\n                if (k < route[j].length - 1) {\r\n                    indices.push(Math.floor(positions.length / 3) - 1, Math.floor(positions.length / 3));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //     console.log(xC / Count, yC / Count, Count)\r\n\r\n    geometry.setIndex(indices);\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    geometry.computeBoundingSphere();\r\n\r\n    const mesh = new THREE.LineSegments(geometry, material);\r\n    scene.add(mesh);\r\n    return mesh;\r\n};"],"names":["FilterGLViewDarkForDarken","constructor","gl","program","fragmentShader","vertexShader","matrixLocation","posBuffer","colBuffer","vertexs","posLocAtt","colLocAtt","matLoc","colLoc","cVecLoc","mouseLoc","timeGL","vShader","fShader","v","f","positionAttribLocation","colorAttribLocation","translation","color","colArray","this","Math","random","InitShader","GLShaderCommon","VERTEX_SHADER","FRAGMENT_SHADER","Render","col","Float32Array","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","type","FLOAT","stride","BYTES_PER_ELEMENT","offset","vertexAttribPointer","enableVertexAttribArray","useProgram","primitiveType","TRIANGLES","drawArrays","Solution","RendererThree","super","streetOSM","routesTreated","routesControl","zones30","positions","geometry","raycaster","THREE","pointer","mesh","sphere","renderPoints","scene","paths","material","vertexColors","size","colors","i","length","route","j","k","xPro","yPro","MercatorProjection","x","y","push","setAttribute","computeBoundingSphere","add","light","camera","params","Points","threshold","far","sphereGeometry","sphereMaterial","canvasGL","document","createElement","style","position","pointerEvents","mixBlendMode","width","hostDiv","clientWidth","height","clientHeight","appendChild","glCtx","getContext","set","getJSONFromURL","then","data","renderLines","start","mouseMove","e","offsetX","offsetY","update","setFromCamera","intersections","intersectObjects","intersection","point","z","numVertices","attributes","count","o","getX","getY","getZ","sin","t","p","setXYZ","distanceTo","needsUpdate","computeVertexNormals","linewidth","indices","xC","yC","Count","floor","setIndex"],"sourceRoot":""}