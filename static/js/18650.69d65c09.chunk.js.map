{"version":3,"file":"static/js/18650.69d65c09.chunk.js","mappings":"6JAIO,MAAMA,UAAiBC,EAAAA,GAY1BC,cACIC,MADkB,uDAAG,QACZ,KAXbC,gBAAU,OAEVC,QAAU,IAAIC,EAAAA,IAAgB,KAC9BC,UAAY,IAAID,EAAAA,IAAkB,KAClCE,YAAM,OAENC,UAAI,OAEJC,IAAuB,GAInB,MAAMC,EAAQC,KAAKD,MAEnBC,KAAKL,UAAY,IAAID,EAAAA,IACrBM,KAAKL,UAAUM,OAAOC,OAAOC,UAAY,GACzCH,KAAKL,UAAUS,IAAM,IAErB,MAAMC,EAAiB,IAAIX,EAAAA,IAAqB,GAAK,GAAI,IACnDY,EAAiB,IAAIZ,EAAAA,IAAwB,CAAEa,MAAO,WACtDX,EAAS,IAAIF,EAAAA,IAAWW,EAAgBC,GAC9CN,KAAKJ,OAASA,EACdI,KAAKD,MAAMS,IAAIZ,GAGfI,KAAKS,OAAOC,SAASC,IAAI,EAAG,GAAI,IAEhC,MAAMC,EAAe,IAAIlB,EAAAA,IAAmB,SAAU,KACtDM,KAAKD,MAAMS,IAAII,GAEfZ,KAAKR,WAAa,IAAIE,EAAAA,IAAiB,SAAU,KACjDM,KAAKR,WAAWkB,SAASG,EAAI,GAC7Bb,KAAKR,WAAWkB,SAASI,EAAI,GAC7Bd,KAAKR,WAAWuB,YAAa,EAC7Bf,KAAKD,MAAMS,IAAIR,KAAKR,YAEpB,MAAMwB,EAAW,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAC1B,MAAMJ,EAAII,EACJH,EAAI,EACJI,EAAI,EACVF,EAASG,KAAMN,EAAGC,EAAGI,GACrBlB,KAAKF,IAAIqB,KAAK,IAAIzB,EAAAA,IAAcmB,EAAGC,EAAGI,GAC1C,CAEA,MAAME,EAAW,IAAI1B,EAAAA,IACrB0B,EAASC,aAAc,WAAY,IAAI3B,EAAAA,IAA8BsB,EAAU,IAE/E,MAAMM,EAAW,IAAI5B,EAAAA,IAAsB,CAAEa,MAAO,QAC9CgB,EAAS,IAAI7B,EAAAA,IAAc0B,EAAUE,GAC3CvB,EAAMS,IAAKe,GAEXvB,KAAKH,KAAO0B,EAEZvB,KAAKwB,OACT,CACOC,UAAUC,GACb1B,KAAKP,QAAQoB,EAAKa,EAAEC,QAAU3B,KAAK4B,QAAQC,YAAe,EAAI,EAC9D7B,KAAKP,QAAQqB,GAAOY,EAAEI,QAAU9B,KAAK4B,QAAQG,aAAgB,EAAI,CACrE,CACOC,OAAOjC,GACV,IAAIkC,EAAS,IAAIvC,EAAAA,IACjBuC,EAAOC,cAAwB,KAAVC,KAAKC,IAC1BpC,KAAKR,WAAWkB,SAAS2B,aAAaJ,GAEtCjC,KAAKL,UAAU2C,cAActC,KAAKP,QAASO,KAAKS,QAChD,MAAM8B,EAAgBvC,KAAKL,UAAU6C,iBAAiB,CAACxC,KAAKH,OAAO,GAC7D4C,EAAgBF,EAAcG,OAAU,EAAIH,EAAc,GAAK,KAEhD,OAAjBE,GAGAzC,KAAKJ,OAAOc,SAASC,IAAI8B,EAAaE,MAAM9B,EAAG4B,EAAaE,MAAM7B,EAAG2B,EAAaE,MAAMzB,EAIhG,E","sources":["njslab/Workshop/workshop-three/LAB_Web_03_PointIndex/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, getCSVFromURL } from '../../../../lib';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight;\r\n\r\n    pointer = new THREE.Vector2();\r\n    raycaster = new THREE.Raycaster();\r\n    sphere: THREE.Mesh;\r\n\r\n    mesh: THREE.Points;\r\n\r\n    vex: THREE.Vector3[] = [];\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n        const scene = this.scene;\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        this.raycaster.params.Points.threshold = 0.8;\r\n        this.raycaster.far = 1000;\r\n\r\n        const sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\r\n        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\r\n        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\r\n        this.sphere = sphere;\r\n        this.scene.add(sphere);\r\n\r\n\r\n        this.camera.position.set(0, 50, 50);\r\n\r\n        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.25);\r\n        this.scene.add(ambientLight);\r\n\r\n        this.pointLight = new THREE.PointLight(0xffffff, 0.75);\r\n        this.pointLight.position.x = 10;\r\n        this.pointLight.position.y = 10;\r\n        this.pointLight.castShadow = true;\r\n        this.scene.add(this.pointLight);\r\n\r\n        const vertices = [];\r\n        for( let i = 0; i < 2; i ++ ) {\r\n            const x = i;\r\n            const y = 0;\r\n            const z = 0;\r\n            vertices.push( x, y, z );\r\n            this.vex.push(new THREE.Vector3(x, y, z))\r\n        }\r\n        \r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n        // geometry.setAttribute( '', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n        const material = new THREE.PointsMaterial( { color: 0x00fff0 } );\r\n        const points = new THREE.Points( geometry, material );\r\n        scene.add( points );\r\n\r\n        this.mesh = points;\r\n\r\n        this.start();\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        this.pointer.x = (e.offsetX / this.hostDiv.clientWidth) * 2 - 1;\r\n        this.pointer.y = - (e.offsetY / this.hostDiv.clientHeight) * 2 + 1;\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        let matrix = new THREE.Matrix4();\r\n        matrix.makeRotationY(Math.PI * 0.011);\r\n        this.pointLight.position.applyMatrix4(matrix);\r\n\r\n        this.raycaster.setFromCamera(this.pointer, this.camera);\r\n        const intersections = this.raycaster.intersectObjects([this.mesh], false);\r\n        const intersection = (intersections.length) > 0 ? intersections[0] : null;\r\n\r\n        if (intersection !== null) {\r\n            // console.log(intersection);\r\n            // console.log( intersection.index, intersection.object.id);\r\n            this.sphere.position.set(intersection.point.x, intersection.point.y, intersection.point.z);\r\n\r\n            // console.log(this.vex[intersection.index]);\r\n        }\r\n    }\r\n}\r\n"],"names":["Solution","RendererThree","constructor","super","pointLight","pointer","THREE","raycaster","sphere","mesh","vex","scene","this","params","Points","threshold","far","sphereGeometry","sphereMaterial","color","add","camera","position","set","ambientLight","x","y","castShadow","vertices","i","z","push","geometry","setAttribute","material","points","start","mouseMove","e","offsetX","hostDiv","clientWidth","offsetY","clientHeight","update","matrix","makeRotationY","Math","PI","applyMatrix4","setFromCamera","intersections","intersectObjects","intersection","length","point"],"sourceRoot":""}