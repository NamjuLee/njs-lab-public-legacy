"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[90672],{92522:(t,i,e)=>{e.r(i),e.d(i,{Clustering:()=>a,OPTIMIZER:()=>n});var s=e(43891);let n;!function(t){t.NONE="NONE",t.GRID="GRID",t.GRID_SCREEN="GRID_SCREEN",t.COLLISION="COLLISION",t.AGENT="AGENT"}(n||(n={}));class h{constructor(){this.xInterval=0,this.yInterval=0,this.rx=9,this.ry=7,this.cells=[],this.points=[]}update(t,i){this.initGrid(t,i)}initGrid(t,i){this.cells=[],this.xInterval=t/(this.rx-1),this.yInterval=i/(this.ry-1);for(let e=0;e<this.ry;e++){const t=[];for(let i=0;i<this.rx;i++)t.push(new o(this,i,e));this.cells.push(t)}for(let e=0;e<this.points.length;++e){const t=this.points[e];this.getCellAtPoint(t).push(t)}for(let e=0;e<this.ry;++e)for(let t=0;t<this.rx;++t)this.cells[e][t].points.length<2&&(this.cells[e][t].isRenderable=!1)}getCellAtPoint(t){let i=Math.round(t.x/this.xInterval),e=Math.round(t.y/this.yInterval);return i>=this.rx&&(i=this.rx-1),e>=this.ry&&(e=this.ry-1),i<0&&(i=0),e<0&&(e=0),this.cells[e][i]}render(t){for(let i=0;i<this.cells.length;i++)for(let e=0;e<this.cells[i].length;e++)this.cells[i][e].draw(t)}}class o{constructor(t,i,e){this.grid=void 0,this.r0=16,this.r1=24,this.vec=void 0,this.vecRender=void 0,this.xI=void 0,this.yI=void 0,this.isHover=!1,this.points=[],this._isRenderable=!0,this.grid=t,this.xI=i,this.yI=e,this.vec=new s.h9(i*this.grid.xInterval,e*this.grid.yInterval)}push(t){t.isRenderable=!1,this.points.push(t),this.vecRender=new s.h9(0,0,0);for(let i=0;i<this.points.length;++i)this.vecRender.x+=this.points[i].x,this.vecRender.y+=this.points[i].y;this.vecRender.x/=this.points.length,this.vecRender.y/=this.points.length}get isRenderable(){return this._isRenderable}set isRenderable(t){if(!t){for(let t=0;t<this.points.length;++t)this.points[t].isRenderable=!0;this.points=[]}this._isRenderable=t}draw(t){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.beginPath(),t.rect(this.vec.x-.5*this.grid.xInterval,this.vec.y-.5*this.grid.yInterval,this.grid.xInterval,this.grid.yInterval),t.closePath(),t.stroke(),!this.isRenderable)return;if(i){this.vecRender=new s.h9(0,0,0);for(let t=0;t<this.points.length;++t)this.vecRender.x+=this.points[t].x,this.vecRender.y+=this.points[t].y;this.vecRender.x/=this.points.length,this.vecRender.y/=this.points.length}const e=5+.1*this.points.length;t.fillStyle="rgba(".concat(10*e,", 0, 0, 1)"),t.beginPath(),t.arc(this.vecRender.x,this.vecRender.y,e,0,2*Math.PI),t.closePath(),t.fill()}}class r{constructor(){this.xInterval=0,this.yInterval=0,this.width=0,this.height=0,this.rx=9,this.ry=7,this.cells=[],this.points=[],this.minP=new s.h9(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),this.maxP=new s.h9(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)}update(t,i){this.initGrid(t,i)}initGrid(t,i){this.minP=new s.h9(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),this.maxP=new s.h9(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);for(let e=0;e<this.points.length;++e){const t=this.points[e];this.minP.x>t.x&&(this.minP.x=t.x),this.minP.y>t.y&&(this.minP.y=t.y),this.minP.z>t.z&&(this.minP.z=t.z),this.maxP.x<t.x&&(this.maxP.x=t.x),this.maxP.y<t.y&&(this.maxP.y=t.y),this.maxP.z<t.z&&(this.maxP.z=t.z)}this.cells=[],this.width=this.maxP.x-this.minP.x,this.height=this.maxP.y-this.minP.y,this.xInterval=this.width/(this.rx-1),this.yInterval=this.height/(this.ry-1);for(let e=0;e<this.ry;e++){const t=[];for(let i=0;i<this.rx;i++)t.push(new l(this,i,e));this.cells.push(t)}for(let e=0;e<this.points.length;++e){const t=this.points[e];this.getCellAtPoint(t).push(t)}for(let e=0;e<this.ry;++e)for(let t=0;t<this.rx;++t)this.cells[e][t].points.length<1&&(this.cells[e][t].isRenderable=!1)}getCellAtPoint(t){let i=Math.round((t.x-this.minP.x)/this.xInterval),e=Math.round((t.y-this.minP.y)/this.yInterval);return i>=this.rx&&(i=this.rx-1),e>=this.ry&&(e=this.ry-1),i<0&&(i=0),e<0&&(e=0),this.cells[e][i]}render(t){for(let i=0;i<this.cells.length;i++)for(let e=0;e<this.cells[i].length;e++)this.cells[i][e].draw(t);t.beginPath(),t.rect(this.minP.x,this.minP.y,this.maxP.x-this.minP.x,this.maxP.y-this.minP.y),t.stroke()}}class l{constructor(t,i,e){this.grid=void 0,this.r0=16,this.r1=24,this.vec=void 0,this.vecRender=void 0,this.xI=void 0,this.yI=void 0,this.isHover=!1,this.points=[],this._isRenderable=!0,this.grid=t,this.xI=i,this.yI=e,this.vec=new s.h9(t.minP.x+i*this.grid.xInterval,t.minP.y+e*this.grid.yInterval)}push(t){t.isRenderable=!1,this.points.push(t),this.vecRender=new s.h9(0,0,0);for(let i=0;i<this.points.length;++i)this.vecRender.x+=this.points[i].x,this.vecRender.y+=this.points[i].y;this.vecRender.x/=this.points.length,this.vecRender.y/=this.points.length}get isRenderable(){return this._isRenderable}set isRenderable(t){if(!t){for(let t=0;t<this.points.length;++t)this.points[t].isRenderable=!0;this.points=[]}this._isRenderable=t}draw(t){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.isRenderable)return t.beginPath(),t.rect(this.vec.x-.5*this.grid.xInterval,this.vec.y-.5*this.grid.yInterval,this.grid.xInterval,this.grid.yInterval),t.closePath(),void t.stroke();if(i){this.vecRender=new s.h9(0,0,0);for(let t=0;t<this.points.length;++t)this.vecRender.x+=this.points[t].x,this.vecRender.y+=this.points[t].y;this.vecRender.x/=this.points.length,this.vecRender.y/=this.points.length}const e=5+.1*this.points.length;t.fillStyle="rgba(".concat(10*e,", 0, 0, 1)"),t.beginPath(),t.arc(this.vecRender.x,this.vecRender.y,e,0,2*Math.PI),t.closePath(),t.fill(),t.beginPath(),t.rect(this.vec.x-.5*this.grid.xInterval,this.vec.y-.5*this.grid.yInterval,this.grid.xInterval,this.grid.yInterval),t.closePath(),t.stroke()}}class a{constructor(t){switch(this.optimizerType=void 0,this.optimizer=void 0,this.mv=new s.h9(0,0),this.inspection=!0,this.optimizerType=t,t){case n.GRID_SCREEN:this.optimizer=new h;break;case n.GRID:this.optimizer=new r}console.debug("clustering... v 0.1.5")}push(t,i,e){this.optimizer.points=t,this.update(i,e)}mouseInteraction(t,i){this.mv=this.optimizer.getCellAtPoint(new s.h9(t,i)).vec}update(t,i){this.optimizer.update(t,i)}render(t,i,e,s){i&&this.update(e,s),this.optimizer.render(t),this.mv&&(t.fillStyle="#00ff00",t.beginPath(),t.arc(this.mv.x,this.mv.y,9,0,6.28),t.closePath(),t.fill())}}},43891:(t,i,e)=>{e.d(i,{TE:()=>s.TE,h9:()=>s.h9});var s=e(91769)},77798:(t,i,e)=>{e.d(i,{J:()=>I});var s=e(39890);var n=e(44945);class h{constructor(t){this.activeCommandController=void 0,this.type=s.NI.SELECT,this.activeCommandController=t}mouseEvent(t){switch(t.type){case s.zK.LEFT:return void this.MouseLeftClickPre(t);case s.zK.MIDDLE:return void this.MouseMiddleClickPre(t);case s.zK.RIGHT:return void this.MouseRightClickPre(t);case s.zK.DOUBLE:return void this.MouseDoubleClickPre(t);case s.zK.MOVE:return void this.MouseMovePre(t);case s.zK.DRAG:return void this.MouseDragPre(t);case s.zK.DOWN:return void this.MouseDownPre(t);case s.zK.UP:return void this.MouseUpPre(t);case s.zK.WHEEL:return void this.MouseWheelPre(t)}}MouseDown(t){}MouseDownPre(t){this.activeCommandController.drawingEngine.scene.capture=this.activeCommandController.drawingEngine.geometryCommon.find(t.x,t.y),this.MouseDown(t)}MouseLeftClick(t){}MouseLeftClickPre(t){this.activeCommandController.drawingEngine.scene.capture=this.activeCommandController.drawingEngine.geometryCommon.find(t.x,t.y),this.activeCommandController.drawingEngine.scene.capture?this.activeCommandController.drawingEngine.scene.capture.isSelected=!this.activeCommandController.drawingEngine.scene.capture.isSelected:this.activeCommandController.drawingEngine.geometryCommon.resetSelections(),this.MouseLeftClick(t)}MouseMiddleClick(t){}MouseMiddleClickPre(t){this.MouseMiddleClick(t)}MouseRightClick(t){}MouseRightClickPre(t){this.MouseRightClick(t)}MouseUp(t){}MouseUpPre(t){this.activeCommandController.drawingEngine.scene.capture=void 0,this.MouseUp(t)}MouseDoubleClick(t){}MouseDoubleClickPre(t){this.MouseDoubleClick(t)}MouseMove(t){}MouseMovePre(t){this.activeCommandController.drawingEngine.geometryCommon.updateHover(t.x,t.y),this.MouseMove(t)}MouseDrag(t){}MouseDragPre(t){if(this.activeCommandController.drawingEngine.scene.capture){const i=this.activeCommandController.drawingEngine.projection.toMap(t.x,t.y);this.activeCommandController.drawingEngine.scene.capture.translate(t.x,t.y,i[0],i[1])}this.MouseDrag(t)}MouseWheel(t){}MouseWheelPre(t){this.MouseWheel(t)}}class o{constructor(t){this.geometryBase=void 0,this.isCollided=!1,this.neighborShapes=[],this.minVec=void 0,this.maxVec=void 0,this.isVisited=!1,this.numOrder=-1,this.geometryBase=t;this.minVec=new n.h9(this.geometryBase.v.x-5,this.geometryBase.v.y-5,0),this.maxVec=new n.h9(this.geometryBase.v.x+5,this.geometryBase.v.y+5,0)}Reset(){this.neighborShapes=[],this.numOrder=-1,this.geometryBase.numVisit=0,this.geometryBase.isCollapse=!1,this.isCollided=!1,this.isVisited=!1}}class r{constructor(t,i,e){this.scene=void 0,this.v=void 0,this.type=void 0,this.id="",this.numVisit=0,this.isCollapse=!1,this.isHidden=!1,this.isRenderable=!0,this.isSelected=!1,this.isHover=!1,this.collision=void 0,this.scene=t,this.v=new n.h9(i,e,0),this.id=(()=>{let t=(new Date).getTime();return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(i){let e=(t+16*Math.random())%16|0;return t=Math.floor(t/16),("x"===i?e:3&e|8).toString(16)}))})(),this.collision=new o(this)}toJson(){return{}}translate(t,i,e,s){}isInside(t,i){return!1}update(t,i){}render(t,i){}renderPost(t,i){}}class l extends r{constructor(t,i){super(t,i.x,i.y),this.r=5,this.id=void 0,this.t=0,this.color="#00ff00",this.colorHover="#0ffff0",this.collision=void 0,this.type=s.mB.point,this.v=new n.h9(i.x,i.y,i.z)}translate(t,i,e,s){this.v.x=t,this.v.y=i,this.v.long=e,this.v.lat=s}isInside(t,i){return(0,n.tl)(this.v.x,this.v.y,t,i)<this.r+3?(this.isHover=!0,!0):(this.isHover=!1,!1)}update(t,i){if(t&&this.scene.drawingEngine.projection.isCustom){const t=i(this.v.long,this.v.lat);this.v.x=t[0],this.v.y=t[1]}}toJson(){return{x:this.v.x,y:this.v.y}}renderPost(t,i){let e=this.r+Math.sin(this.t);this.isHover?(e+=3,t.fillStyle=this.colorHover):t.fillStyle=this.color,t.beginPath(),t.arc(this.v.x,this.v.y,e,0,2*Math.PI),t.closePath(),t.fill(),this.isSelected&&(t.lineWidth=3,t.strokeStyle="#ffffff",t.stroke()),this.t+=.06}}class a extends h{constructor(t){super(t),this.type=s.NI.SELECT}MouseLeftClick(t){}}class d extends h{constructor(t){super(t),this.type=s.NI.POINT}MouseLeftClick(t){const i=new l(this.activeCommandController.drawingEngine.scene,{x:t.x,y:t.y,z:0}),e=this.activeCommandController.drawingEngine.projection.toMap(t.x,t.y);i.v.long=e[0],i.v.lat=e[1],this.activeCommandController.drawingEngine.scene.addGeometry(i),this.activeCommandController.hasShift||this.activeCommandController.drawingEngine.setCommand()}}class c extends h{constructor(t){super(t),this.type=s.NI.LINE}MouseLeftClick(t){}}var g=e(59475);class u{constructor(t){this.drawingEngine=void 0,this.activeCommand=void 0,this.commands={},this.hasShift=!1,this.inspection=!1,this.drawingEngine=t,this.commands={SELECT:new a(this),POINT:new d(this),LINE:new c(this)},this.activeCommand=this.commands[s.NI.SELECT]}setCommander(t){switch(t){case s.NI.SELECT:case s.NI.POINT:case s.NI.LINE:this.activeCommand=this.commands[t]}}apiCall(t){switch(t){case"getSelectedCPoint":return this.drawingEngine.geometryCommon.getSelCPoint();case"importZipData":return this.popZipData();case"importClustering":return this.drawingEngine.addon.InitClustering();case"importClusteringCollision":return this.drawingEngine.addon.InitClusteringCollision();case"save":return this.drawingEngine.geometryCommon.toJson()}}async popZipData(){const t=await(0,g.rd)("https://raw.githubusercontent.com/NamjuLee/data/master/US/zip.json");let i=0;for(let e of t.pos){if(this.greatePointByGeoPos(e[0],e[1]).t+=10*Math.random(),i++>2e3)return}}greatePointByGeoPos(t,i){const e=this.drawingEngine.projection.toScreen(t,i),s=new l(this.drawingEngine.scene,{x:e[0],y:e[1],z:0});return s.v.long=t,s.v.lat=i,this.drawingEngine.scene.addGeometry(s),s}}class p{constructor(t){this.drawingEngine=void 0,this.isCustom=!1,this.drawingEngine=t}updateProjection(t){this.toMap=t.toMap,this.toScreen=t.toScreen,this.isCustom=!0}toScreen(t,i){return[t,i]}toMap(t,i){return[t,i]}}class m{constructor(t){this.drawingEngine=void 0,this.firebaseConfig={apiKey:"AIzaSyA1yKg85WGZoshbk8xR23cXr3SwpqXVgIc",authDomain:"njs-data.firebaseapp.com",projectId:"njs-data",storageBucket:"njs-data.appspot.com",messagingSenderId:"635991152770",appId:"1:635991152770:web:722f5356e0d14cea50fc9b"},this.getData=t=>{let i=t.val();for(let e in i);},this.getError=t=>{console.error(t)},this.drawingEngine=t}sendData(t){}}class v{constructor(t){this.drawingEngine=void 0,this.drawingEngine=t}find(t,i){for(let e in this.drawingEngine.scene.geoDict)if(this.drawingEngine.scene.geoDict[e].isInside(t,i))return this.drawingEngine.scene.geoDict[e]}resetSelections(){for(let t=0;t<this.drawingEngine.scene.geometryList.length;++t)this.drawingEngine.scene.geometryList[t].isSelected=!1}getAllVecFromCPoint(){const t=[];for(let i=0;i<this.drawingEngine.scene.pointList.length;++i)t.push(this.drawingEngine.scene.pointList[i].v);return t}getAllFromCPoint(){const t=[];for(let i=0;i<this.drawingEngine.scene.pointList.length;++i)t.push(this.drawingEngine.scene.pointList[i]);return t}getSelCPoint(){const t=[];for(let i=0;i<this.drawingEngine.scene.pointList.length;++i)this.drawingEngine.scene.pointList[i].isSelected&&t.push(this.drawingEngine.scene.pointList[i]);return t}updateHover(t,i){for(let e=0;e<this.drawingEngine.scene.geometryList.length;++e)this.drawingEngine.scene.geometryList[e].isInside(t,i)}toJson(){const t=[];for(let i=0;i<this.drawingEngine.scene.geometryList.length;++i)t.push(this.drawingEngine.scene.geometryList[i].toJson());return t}}var x=e(92522),y=e(43891);class E{constructor(t,i){this.renderer=void 0,this.points=void 0,this.r0=16,this.r1=24,this.isHover=!1,this.isVisited=!1,this.boundingBoxMin=new y.h9(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),this.boundingBoxMax=new y.h9(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER),this.minVec=void 0,this.maxVec=void 0,this.vec=new y.h9(0,0,0),this.t=1,this.GridResolution=85,this.tempVecGridList=[],this.tempGeoGridList=[],this.renderer=t,this.points=i;for(let e=0;e<this.points.length;++e)this.vec.x+=this.points[e].v.x,this.vec.y+=this.points[e].v.y,this.UpdateBoundingBox(this.points[e].v);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new y.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new y.h9(this.vec.x+this.r1,this.vec.y+this.r1,0)}IsInside(t){return(0,y.TE)(this.vec,t)<this.r1?(this.isHover=!0,!0):(this.isHover=!1,!1)}AddPost(t){if(!this.points.includes(t)){this.points.push(t),this.vec=new y.h9(0,0,0);for(let t=0;t<this.points.length;++t)this.vec.x+=this.points[t].v.x,this.vec.y+=this.points[t].v.y,this.UpdateBoundingBox(this.points[t].v);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new y.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new y.h9(this.vec.x+this.r1,this.vec.y+this.r1,0)}}NeedDecompose(){return this.boundingBoxMax.x-this.boundingBoxMin.x>this.GridResolution||this.boundingBoxMax.y-this.boundingBoxMin.y>this.GridResolution}Split(){this.DeepRemove();const t=(this.boundingBoxMax.x-this.boundingBoxMin.x)/this.GridResolution<1?1:(this.boundingBoxMax.x-this.boundingBoxMin.x)/this.GridResolution,i=(this.boundingBoxMax.y-this.boundingBoxMin.y)/this.GridResolution<1?1:(this.boundingBoxMax.y-this.boundingBoxMin.y)/this.GridResolution,e=this.buildGrid(t,i);this.BuildSubCluster(e,t,i)}Merge(t){this.points.concat(t.points),this.vec=new y.h9(0,0,0);for(let i=0;i<this.points.length;++i)this.vec.x+=this.points[i].v.x,this.vec.y+=this.points[i].v.y,this.UpdateBoundingBox(this.points[i].v);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new y.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new y.h9(this.vec.x+this.r1,this.vec.y+this.r1,0),t.DeepRemove()}DeepRemove(){this.renderer.RemoveCluster(this)}buildGrid(t,i){this.tempGeoGridList=[];let e=[];for(let s=0;s<i;++s){const i=this.boundingBoxMin.y+s*this.GridResolution,n=[];for(let s=0;s<t;++s){const t=this.boundingBoxMin.x+s*this.GridResolution;e.push(new y.h9(t,i));const h=[];n.push(h)}this.tempGeoGridList.push(n)}return this.tempVecGridList=e,e}BuildSubCluster(t,i,e){for(let s=0;s<this.points.length;++s)this.GetCellAtPoint(this.points[s].v,i,e).push(this.points[s]);for(let s=0;s<this.tempGeoGridList.length;++s)for(let t=0;t<this.tempGeoGridList[s].length;++t)this.tempGeoGridList[s][t]&&(1===this.tempGeoGridList[s][t].length?this.tempGeoGridList[s][t][0].collision.Reset():this.tempGeoGridList[s][t].length>1&&this.renderer.clustersRPoint.push(new E(this.renderer,this.tempGeoGridList[s][t])))}GetCellAtPoint(t,i,e){let s=new y.h9(t.x-this.boundingBoxMin.x,t.y-this.boundingBoxMin.y),n=Math.round(s.x/this.GridResolution),h=Math.round(s.y/this.GridResolution);return n>=i&&(n=i-1),h>=e&&(h=e-1),n<0&&(n=0),h<0&&(h=0),n=Math.round(n),h=Math.round(h),this.tempGeoGridList[h][n]}Draw(t,i,e){if(this.UpdateTimeer(),e){this.vec=new y.h9(0,0,0),this.boundingBoxMin=new y.h9(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER),this.boundingBoxMax=new y.h9(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);for(let t=0;t<this.points.length;++t)this.vec.x+=this.points[t].v.x,this.vec.y+=this.points[t].v.y,this.UpdateBoundingBox(this.points[t].v);this.vec.x/=this.points.length,this.vec.y/=this.points.length,this.minVec=new y.h9(this.vec.x-this.r1,this.vec.y-this.r1,0),this.maxVec=new y.h9(this.vec.x+this.r1,this.vec.y+this.r1,0)}if(i.optimizer.inspection&&(t.beginPath(),t.rect(this.minVec.x,this.minVec.y,this.maxVec.x-this.minVec.x,this.maxVec.y-this.minVec.y),t.closePath(),t.fillStyle="rgba(0, 0, 0, 0.3)",t.fill(),t.lineWidth=.5,t.beginPath(),t.rect(this.boundingBoxMin.x,this.boundingBoxMin.y,this.boundingBoxMax.x-this.boundingBoxMin.x,this.boundingBoxMax.y-this.boundingBoxMin.y),t.closePath(),t.stroke(),this.tempVecGridList.length>0))for(let s=0;s<this.tempVecGridList.length;++s)t.beginPath(),t.rect(this.tempVecGridList[s].x,this.tempVecGridList[s].y,this.GridResolution,this.GridResolution),t.closePath(),t.stroke()}UpdateTimeer(){this.t-=.1,this.t=this.t<.4?.4:this.t}UpdateBoundingBox(t){this.boundingBoxMin.x=t.x<this.boundingBoxMin.x?t.x:this.boundingBoxMin.x,this.boundingBoxMin.y=t.y<this.boundingBoxMin.y?t.y:this.boundingBoxMin.y,this.boundingBoxMax.x=t.x>this.boundingBoxMax.x?t.x:this.boundingBoxMax.x,this.boundingBoxMax.y=t.y>this.boundingBoxMax.y?t.y:this.boundingBoxMax.y}}class C{constructor(t){this.clustersRPoint=[],this.optimizer=void 0,this.optimizer=t}InitGeometry(){this.clustersRPoint=[]}addClusterByGeometries(t){for(let i=0;i<t.length;++i)this.clustersRPoint.push(new E(this,t[i]))}RemoveCluster(t){this.clustersRPoint.splice(this.clustersRPoint.indexOf(t),1)}Render(t,i){if(this.clustersRPoint.length>0)for(let e=0;e<this.clustersRPoint.length;++e)this.clustersRPoint[e].Draw(t,this,i)}}var w=e(84638);class b{constructor(t){this.optimizer=void 0,this.pointList=[],this.optimizer=t}update(){this.updatePoints(),this.pointList=this.BuildConnectivity(this.pointList),this.initGeometry();const t=this.buildGraph(this.pointList);if(void 0!==t){this.addClusterByGeometries(t),this.PostUpdateCollisionBasedonGraph();const i=this.NeedDecompose();i.length>0&&(this.SplitClusters(i),this.PostMergeCluster())}}initGeometry(){this.optimizer.renderer.InitGeometry()}addClusterByGeometries(t){this.optimizer.renderer.addClusterByGeometries(t)}updatePoints(){this.pointList=[];for(let t=0;t<this.optimizer.points.length;++t)if(!this.optimizer.points[t].isHidden&&this.optimizer.points[t].isRenderable){const i=this.optimizer.points[t];i.collision.Reset(),this.pointList.push(i)}}BuildConnectivity(t){for(let i=0;i<t.length;++i){const e=t[i];for(let s=i+1;s<t.length;++s){const i=t[s];!i.isCollapse&&i!==e&&(0,w.Y4)([e.collision.minVec,e.collision.maxVec],[i.collision.minVec,i.collision.maxVec])&&(e.collision.isCollided=!0,e.isCollapse=!0,e.numVisit=0,e.collision.neighborShapes.push(i),i.collision.isCollided=!0,i.isCollapse=!0,i.numVisit=0,i.collision.neighborShapes.push(e))}}return t}buildGraph(t){let i=[];for(let e=0;e<t.length;++e){let s=[],n=[t[e]];n[0].collision.isVisited=!0,s.push(n[0]);let h,o=0;for(;void 0!==(h=n.shift());){for(let t=0;t<h.collision.neighborShapes.length;++t)h.collision.neighborShapes[t].collision.isVisited||(h.collision.neighborShapes[t].collision.isVisited=!0,n.push(h.collision.neighborShapes[t]),s.push(h.collision.neighborShapes[t]));if(o++>1e3)return void console.debug("fail to optimize")}s.length>1&&i.push(s)}return i}PostUpdateCollisionBasedonGraph(){for(let t=0;t<this.optimizer.renderer.clustersRPoint.length;++t)this.UpdateByQueue(this.optimizer.renderer.clustersRPoint[t],this.pointList)}UpdateByQueue(t,i){let e=0;const s=[...i];for(;s.length;){const n=s.shift();if(n){if(n.numVisit>100){n.numVisit=0;break}if(0===s.length&&i.length<e++)break;n.collision.isCollided||((0,w.Y4)([n.collision.minVec,n.collision.maxVec],[t.minVec,t.maxVec])?(n.collision.isCollided=!0,n.isCollapse=!0,n.numVisit=0,t.AddPost(n)):(n.numVisit++,s.push(n)))}}}NeedDecompose(){const t=[];for(let i=0;i<this.optimizer.renderer.clustersRPoint.length;++i)this.optimizer.renderer.clustersRPoint[i].NeedDecompose()&&t.push(this.optimizer.renderer.clustersRPoint[i]);return t}SplitClusters(t){for(let i=0;i<t.length;++i)t[i].Split()}PostMergeCluster(){this.PostMergeClusterCompute(this.optimizer.renderer.clustersRPoint)}PostMergeClusterCompute(t){for(let i=0;i<t.length-1;++i){const e=t[i];for(let s=i+1;s<t.length;++s){const i=t[s];i.isVisited||(0,w.TE)(e.vec,i.vec)<e.r1+20&&(i.isVisited=!0,e.Merge(i))}}}}class P{constructor(){this.graphClustering=void 0,this.renderer=void 0,this.mv=new y.h9(0,0),this.inspection=!0,this.points=[],this.graphClustering=new b(this),this.renderer=new C(this)}push(t){this.points=t,this.update()}mouseInteraction(t,i){}update(){this.graphClustering.update()}getCellAtPoint(t){}render(t,i){this.renderer.Render(t,i)}}class M{constructor(t){this.drawingEngine=void 0,this.clustering=void 0,this.clusteringCollisionBasedGraph=void 0,this.drawingEngine=t}async InitClustering(){return Promise.resolve().then(e.bind(e,92522)).then((t=>{let{Clustering:i}=t;const e=this.drawingEngine.geometryCommon.getAllVecFromCPoint();this.clustering=new i(x.OPTIMIZER.GRID),this.clustering.optimizer.rx=9,this.clustering.optimizer.ry=5,this.clustering.push(e,this.drawingEngine.renderer.ctx.canvas.width,this.drawingEngine.renderer.ctx.canvas.height)})).catch((t=>{}))}async InitClusteringCollision(){return Promise.resolve().then(e.bind(e,92522)).then((t=>{let{Clustering:i}=t;const e=this.drawingEngine.geometryCommon.getAllFromCPoint();this.clusteringCollisionBasedGraph=new P,this.clusteringCollisionBasedGraph.push(e)})).catch((t=>{}))}mouseInteraction(t){var i;switch(t.type){case s.zK.LEFT:case s.zK.MIDDLE:case s.zK.RIGHT:case s.zK.DOUBLE:break;case s.zK.MOVE:null===(i=this.clustering)||void 0===i||i.mouseInteraction(t.x,t.y);case s.zK.DRAG:case s.zK.DOWN:case s.zK.UP:case s.zK.WHEEL:}}render(t,i){var e,s;null===(e=this.clustering)||void 0===e||e.render(t,i,this.drawingEngine.renderer.ctx.canvas.width,this.drawingEngine.renderer.ctx.canvas.height),null===(s=this.clusteringCollisionBasedGraph)||void 0===s||s.render(t,i)}}class f{constructor(t){this.drawingEngine=void 0,this.lastCalledTime=Date.now(),this.delta=1,this.fps=30,this.ctx=void 0,this.drawingEngine=t}render(t,i){this.ctx=t,this.update(i),this.renderPost(t,i)}update(t){for(let i in this.drawingEngine.scene.geoDict)this.drawingEngine.scene.geoDict[i].update(t,this.drawingEngine.projection.toScreen)}renderPost(t,i){for(let e in this.drawingEngine.scene.geoDict)this.drawingEngine.scene.geoDict[e].renderPost(t,i);this.ComputeFPS()}ComputeFPS(){this.delta=(Date.now()-this.lastCalledTime)/1e3,this.lastCalledTime=Date.now(),this.fps=1/this.delta}}class R{constructor(t){this.drawingEngine=void 0,this._capture=void 0,this.geometryList=[],this.pointList=[],this.geoDict={},this.drawingEngine=t}get capture(){return this._capture}set capture(t){this.drawingEngine.ableToPan=!t,this._capture=t}addGeometry(t){this.geoDict[t.id]=t,this.geometryList.push(t),t.type===s.mB.point&&this.pointList.push(t)}}class I{constructor(){this.activeCommand=void 0,this.projection=void 0,this.geometryCommon=void 0,this.scene=void 0,this.addon=void 0,this.renderer=void 0,this.io=void 0,this._ableToPan=!0,this.io=new m(this),this.addon=new M(this),this.projection=new p(this),this.geometryCommon=new v(this),this.activeCommand=new u(this),this.scene=new R(this),this.renderer=new f(this)}apiCall(t){return this.activeCommand.apiCall(t)}updateProjection(t){this.projection.updateProjection(t)}setCommand(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"SELECT";this.activeCommand.setCommander(t)}mouseEvent(t){this.activeCommand.activeCommand.mouseEvent(t),this.addon.mouseInteraction(t)}keyEvent(t){}render(t,i){this.renderer.render(t,i),this.addon.render(t,i)}set ableToPan(t){this._ableToPan=t,this.bindAbleToPan(t)}bindAbleToPan(t){}}},47002:(t,i,e)=>{e.d(i,{V:()=>n});e(39890);var s=e(91769);e(44945);class n{toScreen(t,i){return[t,i]}toMap(t,i){return[t,i]}constructor(){this.view=void 0,this.core=void 0,this.io=void 0,this.controller=void 0,this.data=void 0,this.lastCalledTime=Date.now(),this.fps=30,this.delta=1,console.log("NNAEngineV3 is running...")}importDummyData(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"https://raw.githubusercontent.com/NamjuLee/data/master/NYC/NY_street_lat_long.csv";this.io.importCSV(t).then((t=>{this.data=new s.UO,this.data.ComputeCSV(t),this.data.initLines(((t,i)=>this.toScreen(t,i))),this.core.graphSystem.initGraph(this.data.lineTest)}))}updateProjection(t){this.toScreen=t.toScreen,this.toMap=t.toMap}apiCall(t,i,e){this.controller.execution(t,i,e)}initGraph(t){this.core.initGraph(t)}reset(){this.view.reset()}setUnit(t){this.core.setUnit(t)}computePath(t,i){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.002;this.core.computePath(t,i,e)}mouseEvent(t){this.controller.mouseEvent(t)}keyEvent(t){}render(t,i){this.core.render(t,i),this.ComputeFPS()}ComputeFPS(){this.delta=(Date.now()-this.lastCalledTime)/1e3,this.lastCalledTime=Date.now(),this.fps=1/this.delta}}},84638:(t,i,e)=>{e.d(i,{MO:()=>o,TE:()=>n,Y4:()=>s,h9:()=>h});const s=(t,i)=>{const e=t[0].x,s=t[1].x,n=i[0].x,h=i[1].x,o=t[0].y,r=t[1].y,l=i[0].y,a=i[1].y;return e<=h&&s>=n&&o<=a&&r>=l},n=(t,i)=>Math.sqrt((t.x-i.x)*(t.x-i.x)+(t.y-i.y)*(t.y-i.y)+(t.z-i.z)*(t.z-i.z));class h{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.x=0,this.y=0,this.z=0,this.lon=0,this.lat=0,this.elevation=0,this.d=!0,this.isRenderable=!0,this.x=t,this.y=i,this.z=e}}class o{constructor(t,i){this.vec=void 0,this.id="",this.numVisit=0,this.radius=10,this.isCollapse=!1,this.isHidden=!1,this.isRenderable=!0,this.isSelected=!1,this.isHover=!1,this.collision=void 0,this.vec=new h(t,i,0),this.updateBounding()}updateBounding(){this.collision=new r(this)}render(t){t.beginPath(),t.arc(this.vec.x,this.vec.y,this.radius,0,2*Math.PI),t.closePath(),this.isCollapse?t.fillStyle="#f00":t.fillStyle="#0f0",t.fill(),this.renderBoundingBox(t)}renderBoundingBox(t){t.beginPath(),t.rect(this.collision.minVec.x,this.collision.minVec.y,this.collision.maxVec.x-this.collision.minVec.x,this.collision.maxVec.y-this.collision.minVec.y),t.stroke()}}class r{constructor(t){this.base=void 0,this.isCollided=!1,this.neighborShapes=[],this.minVec=void 0,this.maxVec=void 0,this.isVisited=!1,this.numOrder=-1,this.base=t;const i=this.base.radius;this.minVec=new h(this.base.vec.x-i,this.base.vec.y-i,0),this.maxVec=new h(this.base.vec.x+i,this.base.vec.y+i,0)}Reset(){this.neighborShapes=[],this.numOrder=-1,this.base.numVisit=0,this.base.isCollapse=!1,this.isCollided=!1,this.isVisited=!1}}}}]);
//# sourceMappingURL=90672.4462ae78.chunk.js.map