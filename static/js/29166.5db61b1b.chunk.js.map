{"version":3,"file":"static/js/29166.5db61b1b.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/common/ws.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/common/vertex-data.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/web8/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/Renderer/Camera/Cameras.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/Renderer/Camera/CameraController.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/Renderer/WebGPU.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/Renderer/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox/index.ts","njslab/Infrastructure/WebGPU/WebGPU_NJS_Sandbox_Light/lib/index.ts"],"sourcesContent":["\nimport { vec3, mat4 } from 'gl-matrix';\nconst camera = require('3d-view-controls');\n// import * as Stats from 'stats.js';\n// import { GUI } from 'dat.gui';\n\n// #region WebGPU initialization **************************************************************\n\n/**\n * Interface as input of the `initWebGPU` function.\n */\nexport interface IWebGPUInitInput {\n    /** HTML canvas element */\n    canvas: HTMLCanvasElement;\n    /** The GPU texture format */\n    format?: GPUTextureFormat;\n    /** MSAA count (1 or 4) */\n    msaaCount?: number;\n}\n\n/**\n * Interface as output of the `initWebGPU` function. \n */\nexport interface IWebGPUInit {\n    /** The GPU device */\n    device?: GPUDevice;\n    /** The GPU canvas context */\n    context?: GPUCanvasContext;\n    /** The GPU texture format */\n    format?: GPUTextureFormat;\n    /** The canvas size */\n    size?: {width: number, height: number};\n    /** The background color for the scene */\n    background?: {r: number, g: number, b: number, a: number};\n    /** MSAA count (1 or 4) */\n    msaaCount?: number;\n}\n\n/**\n * This function is used to initialize the WebGPU apps. It returns the IWebGPUInit interface.\n * \n * @param input - The input argument of the `IWebGPUInitInput` interface type with default members:\n * \n * `input.format = navigator.gpu.getPreferredCanvasFormat()` \n * \n * `input.msaa.Count = 1`\n * @param deviceDescriptor - Describes a device request. `{}` means the default setting is used \n */\nexport const initWebGPU = async (input: IWebGPUInitInput, deviceDescriptor:GPUDeviceDescriptor = {}): Promise<IWebGPUInit> => {\n    // set default parameters\n    input.format = input.format === undefined? navigator.gpu.getPreferredCanvasFormat(): input.format;\n    input.msaaCount = input.msaaCount === undefined? 1: input.msaaCount;\n    \n    if(checkWebGPUSupport.includes('does not support WebGPU')){\n        throw(checkWebGPUSupport);\n    }\n\n    const adapter = await navigator.gpu.requestAdapter();\n    const device = await adapter.requestDevice(deviceDescriptor);\n    const context = input.canvas.getContext('webgpu') as GPUCanvasContext;\n    const pixelRatio = window.devicePixelRatio || 1;\n    // input.canvas.width = input.canvas.clientWidth * pixelRatio;\n    // input.canvas.height = input.canvas.clientHeight * pixelRatio;\n    const size = {width: input.canvas.width, height: input.canvas.height};\n    context.configure({\n        device: device,\n        format: input.format,\n        alphaMode: 'opaque',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n    const background = { r: 0.009, g: 0.0125, b: 0.0164, a: 1.0 };\n    return {device, context, format:input.format, size, background, msaaCount:input.msaaCount};    \n}\n\n/** A string variable used to check whether your browser supports WebGPU or not.*/\nexport const checkWebGPUSupport = navigator.gpu? 'Great, your current browser supports WebGPU!' : \n    `Your current browser does not support WebGPU! Make sure you are on a system \n    with WebGPU enabled.`;\n\n// #endregion WebGPU initialization ***********************************************************\n\n\n// #region Pipeline Descriptor ****************************************************************\n\n/**\n * Interface as the output of a render pipeline.\n */\nexport interface IPipeline {\n    /** The render pipeline array */\n    pipelines?: GPURenderPipeline[],\n    /** The compute pipeline array */\n    csPipelines?: GPUComputePipeline[],\n    /** The GPU texture array */\n    gpuTextures?: GPUTexture[],\n    /** The depth texture array */\n    depthTextures?: GPUTexture[],\n    /** The vertex buffer array */\n    vertexBuffers?: GPUBuffer[],\n    /** The uniform buffer array */\n    uniformBuffers?: GPUBuffer[],\n    /** The uniform bind group array */\n    uniformBindGroups?: GPUBindGroup[],\n    /** The number of vertices */\n    numVertices?: number,\n    /** The number of instances */\n    numInstances?: number,\n}\n\n/** Interface as input of the `createRenderPipelineDescriptor` function. */\nexport interface IRenderPipelineInput {\n    /** The IWebGPU interface */\n    init: IWebGPUInit,\n    /** The GPU primative topology with default `'triangle-list'` */\n    primitiveType?: GPUPrimitiveTopology,\n    /** The GPU index format (undefined for `'list'` primitives or `'uint32'` for `'strip'` primitives) */\n    indexFormat?: GPUIndexFormat,\n    /** The GPU cull mode - defines which polygon orientation will be culled */\n    cullMode?: GPUCullMode,\n    /** The boolean variable - indicates whether the render pipeline should include a depth stencial state or not */\n    isDepthStencil?: boolean,\n    /** The `buffers` attribute of the vertex state in a render pipeline descriptor */\n    buffers?: Iterable<GPUVertexBufferLayout>,\n    /** The WGSL shader that contains both vertex and fragment shaders */\n    shader?: string,\n    /** The WGSL vertex shader */\n    vsShader?: string,\n    /** The WGSL fragment shader */\n    fsShader?: string,\n    /** The entry point for the vertex shader. Default `'vs_main'`  */\n    vsEntry?: string,\n    /** The entry point for the fragment shader. Default `'fs_main'`  */\n    fsEntry?: string,\n}\n\n/**\n * This function creates the render pipeline descriptor that will be used to create a render pipeline.\n * \n * @param input - The `input` argument is a type of the `IRenderPipelineInput` interface with the following default values:\n * `input.primitiveType`: `'triangle-list'`, `input.cullMode`: `'none'`, `input.isDepthStencil`: `true`, \n * `input.vsEntry`: `'vs_main'`,  `input.fsEntry`: `'fs_main'`. If `input.shader` is specified, then\n * `input.vsShader = input.shader` and `input.fsShader = input.shader` \n * \n * @param withFragment - Indicates whether the GPU fragment state should be included or not. Default value is `true`. \n * If it is set to `false`, the render pipeline will not produce any color attachment outputs. For example, we do not\n * need any color output when rendering shadows, so we can set this parameter to `false` in this case \n * @returns The render pipeline descriptor.\n */\nexport const createRenderPipelineDescriptor = (input: IRenderPipelineInput, withFragment = true): GPURenderPipelineDescriptor => {\n    input.primitiveType = input.primitiveType === undefined? 'triangle-list': input.primitiveType;\n    input.cullMode = input.cullMode === undefined? 'none': input.cullMode;\n    input.isDepthStencil = input.isDepthStencil === undefined? true: input.isDepthStencil;\n    input.vsEntry = input.vsEntry === undefined? 'vs_main': input.vsEntry;\n    input.fsEntry = input.fsEntry === undefined? 'fs_main': input.fsEntry;\n\n    if(input.shader){\n        input.vsShader = input.shader;\n        input.fsShader = input.shader;\n    }\n\n    input.indexFormat = input.indexFormat === undefined? 'uint32': input.indexFormat;\n    let indexFormat: GPUIndexFormat = undefined;\n    if(input.primitiveType.includes('strip')) {\n        indexFormat = input.indexFormat;\n    }\n\n    let descriptor: GPURenderPipelineDescriptor = {\n        layout:'auto',\n        vertex: {\n            module: input.init.device.createShaderModule({                    \n                code: input.vsShader,\n            }),\n            entryPoint: input.vsEntry,\n            buffers: input.buffers,\n        },\n        fragment: withFragment? {\n            module: input.init.device.createShaderModule({                    \n                code: input.fsShader,\n            }),\n            entryPoint: input.fsEntry,\n            targets: [\n                {\n                    format: input.init.format\n                }\n            ],\n        }: undefined,\n        primitive:{\n            topology: input.primitiveType,\n            stripIndexFormat: indexFormat,\n            cullMode: input.cullMode,\n        },\n        multisample: {\n            count: input.init.msaaCount,\n        }\n    };\n\n    if(input.isDepthStencil) {\n        descriptor.depthStencil = {\n            format: \"depth24plus\",\n            depthWriteEnabled: true,\n            depthCompare: \"less\"\n        };\n    }\n    return descriptor;\n}\n\n\n/**\n * This function create a compute pipeline descriptor that will be used to create a compute pipeline.\n * @param device GPU Device\n * @param csShader the WGSL compute shader \n * @param entry the entry point for teh compute shader\n * @returns the compute pipeline descriptor.\n */\nexport const createComputePipelineDescriptor = (device: GPUDevice, csShader: string, entry = 'cs_main'): GPUComputePipelineDescriptor => {\n    return {\n        layout:'auto',\n        compute: {\n            module: device.createShaderModule({\n                code: csShader,\n            }),\n            entryPoint: 'cs_main',\n        }\n    };\n}\n\n/**\n * This function sets the `buffers` attribute of the vertex state in a render pipeline. In this function, the input argument\n * `formats` is a GPU vertex-format array. It can be specified as `'float32'`, `'float32x2'`,\n * `'float32x3'`, `'float32x4'`, etc., which correspond to the WGSL style in the shader `f32`, `vec2<f32>`, \n * `vec3<f32>`, `vec4<f32>`, etc. If the vertex data is stored in a separate buffer for each attribute such as position,\n * normal, and UV, you can simply provide only this input argument like `['float32x3', 'float32x3', 'float32x2']` and \n * ignore all the other optional arguments. In this case, the `setVertexBuffers` function will automatically \n * calculate the `offset`, `arrayStride`, and `shaderLocation` for each vertex attribute. Note that the `shaderLocation` \n * is set with an array filled with consecutive numbers like [0, 1, 2], which must match the  `@location` attribute specified \n * in the vertex shader. Otherwise, you need to manually specify the `shaderLocations` array argument.\n * \n * On the other hand, if you store the vertex data in a single buffer for all attributes (e.g., position, normal, and uv), you \n * will need to provide not only the vertex `formats` array, but also the `offsets` array. Here is an example\n * of a single buffer that stores the `position` (`vec3<f32>`), `normal` (`vec3<f32>`), and `uv` (`vec2<f32>`) data. \n * The corresponding  `arrayStride` will be 12, 12, and 8, and the `offsets` array will be [0, 12, 24]. \n * In this case, you can set the `buffers` attribute by calling the function like this: \n * \n * `const bufs = setVertexBuffers(['float32x3', 'float32x3', 'float32x2'], [0, 12, 24]);`\n * \n * The above example assumes that all the vertex attributes (position, normal, and uv) stored in a \n * single buffer are used in the pipeline and vertex shader. What happens if not all the attributes in the buffer are needed. \n * For example, the pipeline and shader only need the `position` and `uv` data, but not the `normal` data. In this case,\n * in addition to the `formats` and `offsets` arguments, you will also need to specify the `totalArrayStride`\n * argument. The `arrayStride` for `position`, `normal`, and `uv` is 12, 12, and 8, respectively, so the \n * `totalArrayStride` = 12 + 12 + 8 = 32. Thus, we can create the `buffers` attribute using the following code\n * \n * `const bufs = setVertexBuffers(['float32x3', 'float32x2'], [0, 24], 32);`\n * \n * Note that the `offsets` array is set to [0, 24] rather than [0, 12], because the `uv` data starts after `position` and \n * `normal` data, while the `normal` data is still stored in the buffer even though it is not used in this example.\n * \n * @param formats GPU vertex format array with each element specifying the `GPUVertexFormat` of teh attribute. \n * @param offsets The offset array that is optional. The offset, in bytes, is counted from the beginning of the element to the data \n * for the attribute. Note that the offset must be a multiple of the minimum of 4 and sizeof the `attrib.format`.\n * @param totalArrayStride The stride, in bytes, between elements of the array. This is an optional argument.\n * @param shaderLocations The numeric location associated with the attribute, such as position, normal, or uv, which will \n * correspond with a `@location` attribute declared in the vertex shader. This is an optional argument.\n * @returns An array of GPU vertex buffer layout.\n */\nexport const setVertexBuffers = (formats: GPUVertexFormat[], offsets:number[] = [], totalArrayStride = 0, \nshaderLocations:number[] = []): Iterable<GPUVertexBufferLayout> => {\n    const len = formats.length\n    const len1 = offsets.length;\n    const len2 = shaderLocations.length;\n    let buffers = [];\n    if(len1 === 0){\n        for(let i = 0; i < len; i++){\n            let stride = 4 * parseInt(formats[i].split('x')[1]);\n            let loc = len2 === 0? i: shaderLocations[i];\n            buffers.push({\n                arrayStride: stride,\n                attributes: [{\n                    shaderLocation: loc,\n                    format: formats[i],\n                    offset: 0,\n                }]\n            },);\n        }\n    } else {\n        let attributes = [];\n        let strides = 0;\n        for(let i = 0; i < len1; i++){\n            strides += 4 * parseInt(formats[i].split('x')[1]);\n            let loc = len2 === 0? i: shaderLocations[i];\n            attributes.push({\n                shaderLocation: loc,\n                format: formats[i],\n                offset: offsets[i],\n            });\n        }\n        if(totalArrayStride > 0) {\n            strides = totalArrayStride;\n        }\n        buffers = [{            \n            arrayStride: totalArrayStride,\n            attributes: attributes as Iterable<GPUVertexAttribute>\n        }];\n    }\n    return buffers; \n}\n\n// #endregion Pipeline Descriptor *************************************************************\n\n\n// #region Render pass descriptor *************************************************************\n\n/** Interface as input of the `createRenderPassDescriptor` function. */\nexport interface IRenderPassInput {\n    /** The IWebGPUInit interface */\n    init?: IWebGPUInit,\n    /** The GPU texture view */\n    textureView?: GPUTextureView,\n    /** The depth texture view */\n    depthView?: GPUTextureView,\n}\n\n/**\n * This function creates the render pass descriptor that will be used to create a render pass with various options. \n * The returned desciptor will include a depth-stencil attachment if the depth texture view is provided via the input\n * interface `IRenderPassInput`. Otherwise, the depth stencil attachment will not be defined. The argument \n * `withColorAttachment` indicates whether the descriptor should contain color attachments or not. In addition, you can\n * specify the MSAA count parameter.  \n * @param input The type of interface `IRenderPassInput`\n * @param withColorAttachment Indicates whether the descriptor should contain color attachments or not\n */\nexport const createRenderPassDescriptor = (input: IRenderPassInput, withColorAttachment = true): GPURenderPassDescriptor => {    \n    const colorAttachmentView = input.init.msaaCount > 1? input.textureView: \n        input.init.context.getCurrentTexture().createView();\n    const colorAttachmentResolveTarget = input.init.msaaCount>1?\n        input.init.context.getCurrentTexture().createView(): undefined;\n\n    const descriptor: GPURenderPassDescriptor = {\n        colorAttachments: withColorAttachment? [{\n            view: colorAttachmentView,\n            resolveTarget: colorAttachmentResolveTarget,\n            clearValue: input.init.background,\n            loadOp:'clear',\n            storeOp: 'store'\n        }] as Iterable<GPURenderPassColorAttachment>: [],\n        depthStencilAttachment: input.depthView? {\n            view: input.depthView,\n            depthClearValue: 1.0,\n            depthLoadOp:\"clear\",\n            depthStoreOp: \"store\",\n        } as GPURenderPassDepthStencilAttachment: undefined,\n    }\n    \n    return descriptor;\n}\n// #endregion Render pass descriptor **********************************************************\n\n\n// #region Create, Update GPU Buffers and Bind Group ******************************************\n\n/** The enumeration for specifying the type of a GPU buffer. */\nexport enum BufferType {\n    /** Uniform buffer */\n    Uniform,\n    /** Vertex buffer */\n    Vertex,\n    /** Index buffer */\n    Index,\n    /** Storage buffer */\n    Storage,\n    /** vertex-Storage buffer */\n    VertexStorage,\n    /** Index-Storage buffer */\n    IndexStorage,\n    /** Indirect buffer */\n    Indirect,\n    /** Indirect-Storage buffer */\n    IndirectStorage,\n    /** Read buffer */\n    Read,\n    /** Write buffer */\n    Write,\n}\n\n/**\n * This function updates the vertex buffers when the vertex data is changed by varying some parameters by the user. \n * Let's take the UV sphere as an example. A UV sphere can have three parameters: radius, u-segments, and v-segments. \n * Varying the radius parameter only changes the data values but not the buffer size, while warying the u- (or v-) \n * segments parameter will change both the data values and buffer size. In the former case, we can write the \n * new data directly into the original buffers; while in the latter case, we have to destroy the original buffers and recreate \n * the new buffers with new buffer size, and then write the new data into the newly created buffers. Here, we check whether the buffer\n * size is changed or not by comparing the length of the original data (called `origNumVertices`) with that of the new data.    \n * @param device GPU device\n * @param p Interface of `IPipeline`\n * @param data An array of vertex data. Note that this array should include the `index` data. For example, if a render pipeline \n * has `position`, `normal`, and `uv`, then this `data` array should defined by \n * \n * `const data = [dat.positions, dat.normals, dat.uvs, dat.indices];`\n * \n * Of course, for this data array, you also need to define corresponding vertex buffer array in the render pipeline:\n * \n * `p.vertexBuffers = [positonBuffer, normalBuffer, uvBuffer, indexBuffer];`\n * \n * If the data is generated in such a way that the vertex data contains all attributes (`position`, `normal`, `uv` ) and  it is \n * stored in a single buffer, we can specify the `data` array using the code:\n * \n * `const data = [dat.vertices, dat.indices];` \n * \n * and corresponding vertex buffer array:\n * \n * `p.vertexBuffers = [vertexBuffer, indexBuffer];`\n * \n * @param origNumVertices The data length of the first element in the original `data` array.\n */\nexport const updateVertexBuffers = (device:GPUDevice, p:IPipeline, data:any[], origNumVertices:number) => {\n    let len = p.vertexBuffers.length;\n    if(data[0].length === origNumVertices){\n        for(let i = 0; i < len; i++){\n            device.queue.writeBuffer(p.vertexBuffers[i], 0, data[i]);  \n        }\n    } else {\n        for(let i = 0; i < len; i++){\n            p.vertexBuffers[i].destroy();\n        }\n        for(let i = 0; i < len; i++){\n            p.vertexBuffers[i] = createBufferWithData(device, data[i]);\n        }\n    }\n}\n\n/**\n * This function can be used to create vertex, uniform, or storage GPU buffer. The default is a uniform buffer.\n * @param device GPU device\n * @param bufferSize Buffer size. \n * @param bufferType Of the `BufferType` enum.\n */\nexport const createBuffer = (device:GPUDevice, bufferSize:number, bufferType = BufferType.Uniform): GPUBuffer =>  {\n    let flag =  GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    if(bufferType === BufferType.Vertex){\n        flag = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    } else if (bufferType === BufferType.Index) {\n        flag = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    } else if (bufferType === BufferType.Storage){\n        flag =  GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    }  else if (bufferType === BufferType.VertexStorage) {\n        flag = GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.IndexStorage) {\n        flag = GPUBufferUsage.INDEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.Indirect) {\n        flag = GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.IndirectStorage) {\n        flag = GPUBufferUsage.INDIRECT | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.Read){\n        flag = GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.Write){\n        flag = GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    }\n    return device.createBuffer({\n        size: bufferSize,\n        usage: flag,\n    });\n}\n\n/**\n * This function returns the data type of the input data.\n * @param data Can be any data type, such as Float32Array, Float64Array, Uint16Array, Uint32Array, etc.\n */\nconst getDataType = (data:any) => Object.prototype.toString.call(data).split(/\\W/)[2]; \n\n/**\n * This function creats a GPU buffer with data to initialize it. If the input data is a type of `Float32Array` \n * or `Float64Array`, it returns a vertex, uniform, or storage buffer specified by the enum `bufferType`. Otherwise,\n * if the input data has a `Uint16Array` or `Uint32Array`, this function will return an index buffer.\n * @param device GPU device\n * @param data Input data that should be one of four data types: `Float32Array`, `Float64Array`, `Uint16Array`, and \n * `Uint32Array`\n * @param bufferType Type of enum `BufferType`. It is used to specify the type of the returned buffer. The default is\n * vertex buffer\n */\nexport const createBufferWithData = (device:GPUDevice, data:any, bufferType = BufferType.Vertex): GPUBuffer => {\n    let flag = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    if(bufferType === BufferType.Uniform){\n        flag =  GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    } else if (bufferType === BufferType.Storage){\n        flag =  GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    } else if (bufferType === BufferType.Index) {\n        flag = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    }  else if (bufferType === BufferType.VertexStorage) {\n        flag = GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.IndexStorage) {\n        flag = GPUBufferUsage.INDEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.Indirect) {\n        flag = GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.IndirectStorage) {\n        flag = GPUBufferUsage.INDIRECT | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.Read){\n        flag = GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST;\n    } else if (bufferType === BufferType.Write){\n        flag = GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n    }\n\n    let dtype = getDataType(data);\n    if(bufferType === BufferType.Vertex && dtype.includes('Uint')){\n        flag = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;\n    }    \n    const buffer = device.createBuffer({\n        size: data.byteLength,\n        usage: flag,\n        mappedAtCreation: true\n    });\n\n    if(dtype.includes('Uint32')){\n        new Uint32Array(buffer.getMappedRange()).set(data);\n    } else if(dtype.includes('Uint16')){\n        new Uint16Array(buffer.getMappedRange()).set(data);\n    } else if (dtype.includes('Float64')) {\n        new Float64Array(buffer.getMappedRange()).set(data);\n    } else {\n        new Float32Array(buffer.getMappedRange()).set(data);\n    }\n    buffer.unmap();\n    return buffer;\n}\n\n/**\n * This function is used to create a GPU bind group that defines a set of resources to be bound together in a \n * group and how the resources are used in shader stages. It accepts GPU device, GPU bind group layout, uniform\n * buffer array, and the other GPU binding resource array as its input arguments. If both the buffer and other \n * resource arrays have none zero elements, you need to place the buffer array ahead of the other resource array.\n * Make sure that the order of buffers and other resources is consistent with the `@group @binding` attributes \n * defined in the shader code.\n * @param device GPU device\n * @param layout GPU bind group layout that defines the interface between a set of resources bound in a GPU bind\n * group and their accessibility in shader stages.\n * @param buffers The uniform buffer array\n * @param otherResources The other resource array, which can include `GPUSampler`, `GPUTextureView`, \n * `GPUExternalTexture`, etc.\n */\nexport const createBindGroup = (device:GPUDevice, layout: GPUBindGroupLayout, buffers:GPUBuffer[] = [], \notherResources:GPUBindingResource[] = []): GPUBindGroup => {\n    let entries = [];\n    let bufLen = buffers.length;\n    let resLen = otherResources.length;\n    let len = bufLen + resLen;\n    for(let i = 0; i < len; i++){\n        if(i < bufLen && bufLen > 0){\n            entries.push(\n                { \n                    binding: i,\n                    resource: {\n                        buffer: buffers[i],\n                    }\n                },\n            );\n        } else if (i >= bufLen && resLen > 0){\n            entries.push(\n                { \n                    binding: i,\n                    resource: otherResources[i-bufLen],\n                },\n            );\n        }\n    }\n    \n    return device.createBindGroup({\n        layout: layout,\n        entries: entries,\n    });\n}\n\n/**\n * This function is used to read data from a GPU buffer. It can be used for debugging code.\n * @param device GPU device\n * @param buffer GPU buffer\n * @param byteLength the size of the GPU buffer\n * @returns data from the GPU buffer\n */\nexport const readBufferData = async (device: GPUDevice, buffer: GPUBuffer, byteLength:number) => {\n    const readBuffer = device.createBuffer({\n        size: byteLength,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const encoder = device.createCommandEncoder();\n    encoder.copyBufferToBuffer(buffer, 0, readBuffer, 0, byteLength);\n    device.queue.submit([encoder.finish()]);\n    await readBuffer.mapAsync(GPUMapMode.READ);     \n    return readBuffer.getMappedRange();\n}\n\n// #endregion Create, Update GPU Buffers and Bind Group ***************************************\n\n\n// #region Depth and MultiSample Texture ******************************************************\n\n/**\n * This function create a GPU texture for MSAA (or sample) count = 4.\n * @param init The `IWebGPUInit` interface\n */\nexport const createMultiSampleTexture = (init: IWebGPUInit): GPUTexture => {\n    const texture = init.device.createTexture({\n        size: init.size,\n        format: init.format,\n        sampleCount: init.msaaCount,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    return texture;\n}\n    \n/**\n * This function creates a GPU texture used in the depth stencil attachment in the render pass descriptor.\n * @param init The `IWebGPUInit` interface\n * @param depthFormat GPU texture format, defaulting to `'depth24plus'`\n */\nexport const createDepthTexture = (init: IWebGPUInit, depthFormat: GPUTextureFormat = 'depth24plus'): GPUTexture => {\n    const depthTexture = init.device.createTexture({\n        size: init.size,\n        format : depthFormat,\n        sampleCount: init.msaaCount,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n    return depthTexture;\n}\n// #endregion Depth and MultiSample Texture Views ********************************************\n\n\n// #region Transformations ********************************************************************\n\n/** Interface as output of the `createViewTransform`. */\nexport interface IViewOutput {\n    /** View matrix */\n    viewMat?: mat4\n    /** Camera options used to create a camera */\n    cameraOptions: ICameraOptions,\n}\n\n/** Interface used to create a camera. */\nexport interface ICameraOptions {\n    /** Eye or view position */\n    eye?: vec3,\n    /** Look at direction */\n    center?: vec3,\n    /** Maximum zooming range */\n    zoomMax?: number,\n    /** Zooming speed */\n    zoomSpeed?: number,\n}\n\n/**\n * This function creates a model matrix of the `mat4` type.\n * @param translation Translation along `x` (`tx`), `y` (`ty`), and `z` (`tz`) directions, which can be specified\n * by `[tx, ty, tz]`, defaulting to [0, 0, 0]\n * @param rotation Rotation along `x` (`rx`), `y` (`ry`), and `z` (`rz`) axes, which can be specified by\n * `[rx, ry, rz]`, defaulting to [0, 0, 0]\n * @param scale Scaling along `x` (`sx`), `y` (`sy`), and `z` (`sz`) directions, which can be specified by\n * `[sx, sy, sz]`, defaulting to [1, 1, 1]\n */\nexport const createModelMat = (translation:vec3=[0,0,0], rotation:vec3=[0,0,0], scale:vec3=[1,1,1]): mat4 => {\n    const modelMat = mat4.create();\n    mat4.translate(modelMat, modelMat, translation);\n    mat4.rotateX(modelMat, modelMat, rotation[0]);\n    mat4.rotateY(modelMat, modelMat, rotation[1]);\n    mat4.rotateZ(modelMat, modelMat, rotation[2]);\n    mat4.scale(modelMat, modelMat, scale);\n    return modelMat;\n}\n\n/**\n * This functions creates a view matrix of the `mat4` type and the camera options. It returns the interface\n * `IViewOutput`.\n * @param cameraPos Camera position, defaulting to [2, 2, 4]\n * @param lookDir Look at direction, defaulting to [0, 0, 0]\n * @param upDir Look up direction, defaulting to [0, 1, 0], i.e., the y direction is the look up direction\n */\nexport const createViewTransform = (cameraPos:vec3=[2,2,4], lookDir:vec3=[0,0,0], upDir:vec3=[0,1,0]): IViewOutput => {\n    const viewMat = mat4.create();\n    mat4.lookAt(viewMat, cameraPos, lookDir, upDir);\n    return {\n        viewMat,\n        cameraOptions: {\n            eye: cameraPos,\n            center: lookDir,\n            zoomMax: 1000,\n            zoomSpeed: 2\n        }\n    }\n};\n\n/**\n * This function creates a projection matrix of the `mat4` type.\n * @param aspectRatio Aspect ratio, defaulting to 1\n */\nexport const createProjectionMat = (aspectRatio:number = 1): mat4 => {\n    const projectionMat = mat4.create();       \n    mat4.perspective(projectionMat, 2*Math.PI/5, aspectRatio, 0.1, 1000.0);    \n    return projectionMat;\n};\n\n/**\n * This function creates a model-view-projection matrix of the `mat4` type by combining the model\n * matrix, view matrix, and projection matrix together.\n * @param modelMat Model matrix\n * @param viewMat View matrix\n * @param projectMat Projection matrix\n */\nexport const combineMvpMat = (modelMat:mat4, viewMat:mat4, projectionMat:mat4): mat4 => {\n    const mvpMat = mat4.create();\n    mat4.multiply(mvpMat, viewMat, modelMat);\n    mat4.multiply(mvpMat, projectionMat, mvpMat);\n    return mvpMat;\n} \n\n/**\n* This function creates a view-projection matrix of the `mat4` type by combining the \n * view matrix and projection matrix together.\n * @param viewMat View matrix\n * @param projectMat Projection matrix\n */\nexport const combineVpMat = (viewMat:mat4, projectionMat:mat4): mat4 => {\n    const vpMat = mat4.create();\n    mat4.multiply(vpMat, projectionMat, viewMat);\n    return vpMat;\n} \n\n/**\n * This function create a normal matrix of the `mat4` type by inverting and transposing a model matrix.\n * @param modelMat Model matrix\n */\nexport const createNormalMat = (modelMat:mat4): mat4 => {\n    const normalMat = mat4.create();\n    mat4.invert(normalMat, modelMat);\n    mat4.transpose(normalMat, normalMat);\n    return normalMat;\n}\n\n/**\n * This function creates a camera using a `npm` package `3d-view-controls`. The returned easy to use camera\n * allows you to interact with graphics objects in the scene using mouse, such as pan, rotate, and zoom in/out \n * the objects.\n * @param canvas HTML `canvas` element\n * @param options Camera options, type of the `ICameraOptions`\n */\nexport const getCamera = (canvas: HTMLCanvasElement, options: ICameraOptions) => {\n    return camera(canvas, options);\n}\n// #endregion Transformations *****************************************************************\n\n\n// #region texture ****************************************************************************\n\n/**\n * This function creates a texture and a sampler from an image file, and returns an object that contains \n * attributes `texture` and `sampler`.\n * @param device GPU device\n * @param imageFile the path of the image file to load\n * @param addressModeU (optional) the addressing model for the `u` texture coordinate, defaulting to `'repeat'`\n * @param addressModeV (optional) the addressing model for the `v` texture coordinate, defaulting to `'repeat'`\n */\nexport const createImageTexture = async(device:GPUDevice, imageFile:string, \n    addressModeU = 'repeat', addressModeV = 'repeat') => {\n\n    // get image file\n    const response = await fetch(imageFile);\n    const img = await response.blob();\n    const imageBitmap = await createImageBitmap(img);\n\n    // create sampler with linear filtering for smooth interpolation \n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: addressModeU as GPUAddressMode,\n        addressModeV: addressModeV as GPUAddressMode\n    });       \n\n    // create texture\n    const texture = device.createTexture({\n        size: [imageBitmap.width, imageBitmap.height, 1],\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.TEXTURE_BINDING | \n               GPUTextureUsage.COPY_DST | \n               GPUTextureUsage.RENDER_ATTACHMENT\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: imageBitmap },\n        { texture: texture },\n        [imageBitmap.width, imageBitmap.height]\n    );\n\n    return {\n        texture,\n        sampler\n    }\n}\n\n/**\n * This function creates a texture and a sampler from a 2D canvas, and returns an object that contains \n * attributes `texture` and `sampler`.\n * @param device GPU device\n * @param canvas the HTML canvas element\n * @param addressModeU (optional) the addressing model for the `u` texture coordinate, defaulting to `'repeat'`\n * @param addressModeV (optional) the addressing model for the `v` texture coordinate, defaulting to `'repeat'`\n */\nexport const createCanvasTexture = async(device:GPUDevice, canvas:HTMLCanvasElement, \n    addressModeU = 'repeat', addressModeV = 'repeat') => {\n\n    // create sampler with linear filtering for smooth interpolation \n    const sampler = device.createSampler({\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: addressModeU as GPUAddressMode,\n        addressModeV: addressModeV as GPUAddressMode\n    });       \n\n    // create texture\n    const texture = device.createTexture({\n        size: { width: canvas.width, height: canvas.height },\n        format: 'rgba8unorm',\n        usage: GPUTextureUsage.TEXTURE_BINDING | \n               GPUTextureUsage.COPY_DST | \n               GPUTextureUsage.RENDER_ATTACHMENT\n    });\n\n    device.queue.copyExternalImageToTexture(\n        { source: canvas, flipY: true },\n        { texture: texture },\n        [canvas.width, canvas.height]\n    );\n\n    return {\n        texture,\n        sampler\n    }\n}\n\n// #endregion texture *************************************************************************\n\n// #region utility ****************************************************************************\n\n/**\n * This utility function convert `hex` color string to `rgba` color array of the `Float32Array` type.\n * @param hex Hex color string\n */\nexport const hex2rgb = (hex:string) => {\n    const [r, g, b] = hex.match(/\\w\\w/g).map(x => parseInt(x, 16)/255.0);\n    return new Float32Array([r, g, b, 1]);\n}\n\n/**\n * This utility function creates a new `dat-gui` with a specified dom element id. This function is based on the `npm`\n * package called `dat.gui`. the `dat.gui` library is a lightweight graphical user interface for changing parameters\n * by the user.\n * @param guiDomId HTML dom element id, defaulting to `'gui'`\n */\n// export const getDatGui = (guiDomId = 'gui') => {\n//     var gui = new GUI();\n//     document.querySelector('#'+guiDomId).append(gui.domElement);\n//     return gui;\n// }\n\n/**\n * This utility function creates a new `stats` panel on the scene with a specified dom element id. This function is based on\n * the `npm` package called `stats.js`. It can be used to monitor the performance of your apps, such as framerate, rendering \n * time, and memory usage.\n * @param statsDomId \n */\nexport const getStats= (statsDomId = 'stats') => {\n    var stats = new Stats();\n    stats.dom.style.cssText = 'position:relative;top:0;left:0';\n    stats.showPanel(1);\n    document.querySelector('#'+statsDomId).appendChild(stats.dom);\n    return stats;\n}\n// #endregion utility *************************************************************************","import { vec3 } from 'gl-matrix';\nconst pi = 3.1415926;\n\nconst sin = (x:number) => Math.sin(x);\nconst cos = (x:number) => Math.cos(x);\n\nconst getTorusPosition = (R:number, r:number, u:number, v:number) => {\n    let x = (R + r*cos(v)) * cos(u);\n    let y = r * sin(v);\n    let z = -(R + r*cos(v)) * sin(u);\n    return vec3.fromValues(x, y, z);       \n}\n\nexport const getTorusData = (rlarge:number, rsmall:number, u:number, v:number) => {\n    if(u < 2 || v < 2) return;\n    let pts = [];\n    let normals = [];\n    let eps = 0.01 * 2*pi/v;\n    let p0:vec3, p1:vec3, p2:vec3, p3:vec3;\n    for(let i = 0; i <= u; i++){\n        let du = i*2*pi/u;\n        for(let j = 0; j <= v; j++){\n            let dv = j*2*pi/v;\n            p0 = getTorusPosition(rlarge, rsmall, du, dv);\n            pts.push(p0[0], p0[1], p0[2]);\n\n            // calculate normals\n            if(du-eps >= 0) {\n                p1 = getTorusPosition(rlarge, rsmall, du-eps, dv);\n                p2 = vec3.subtract(vec3.create(), p0, p1);\n            } else {\n                p1 = getTorusPosition(rlarge, rsmall, du+eps, dv);\n                p2 = vec3.subtract(vec3.create(), p1, p0);\n            }\n            if(dv-eps >= 0) {\n                p1 = getTorusPosition(rlarge, rsmall, du, dv-eps);\n                p3 = vec3.subtract(vec3.create(), p0, p1);\n            } else {\n                p1 = getTorusPosition(rlarge, rsmall, du, dv+eps);\n                p3 = vec3.subtract(vec3.create(), p1, p0);\n            }\n            let normal = vec3.cross(vec3.create(), p3, p2);\n            vec3.normalize(normal, normal);\n            normals.push(normal[0], normal[1], normal[2]);\n        }\n    }\n\n    let n_vertices_per_row = v + 1;\n    let indices = [];\n    let indices2 = [];\n\n    for(let i = 0; i < u; i++){\n        for(let j = 0; j < v; j++) {\n            let idx0 = j + i * n_vertices_per_row;\n            let idx1 = j + 1 + i * n_vertices_per_row;\n            let idx2 = j + 1 + (i + 1) * n_vertices_per_row;\n            let idx3 = j + (i + 1) * n_vertices_per_row; \n\n            indices.push(idx0, idx1, idx2, idx2, idx3, idx0);          \n            indices2.push(idx0, idx1, idx0, idx3);      \n        }\n    }\n    return {\n        positions: new Float32Array(pts),\n        normals: new Float32Array(normals),\n        indices: new Uint32Array(indices),\n        indices2: new Uint32Array(indices2),\n    };\n}\n\nconst getSpherePosition = (radius:number, theta:number, phi:number): vec3 => {\n    let x = radius * sin(theta) * cos(phi);\n    let y = radius * cos(theta);\n    let z = -radius * sin(theta) * sin(phi);    \n    return vec3.fromValues(x, y, z);     \n}\n\nexport const getSphereData = (radius:number, u:number, v:number) => {\n    if(u < 2 || v < 2) return;\n    let pts = [], normals = [], uvs = [];\n    for(let i = 0; i <= u; i++){\n        for(let j = 0; j <= v; j++){\n            let pt = getSpherePosition(radius, i*pi/u, j*2*pi/v);\n            pts.push(pt[0], pt[1], pt[2]);\n            normals.push(pt[0]/radius, pt[1]/radius, pt[2]/radius);\n            uvs.push(i/u, j/v);\n        }\n    }\n\n    let vertices_per_row = v + 1;\n    let indices = [];\n    let indices2 = [];\n\n    for(let i = 0; i < u; i++){\n        for(let j = 0; j < v; j++) {\n            let idx0 = j + i * vertices_per_row;\n            let idx1 = j + 1 + i * vertices_per_row;\n            let idx2 = j + 1 + (i + 1) * vertices_per_row;\n            let idx3 = j + (i + 1) * vertices_per_row; \n\n            indices.push(idx0, idx1, idx2, idx2, idx3, idx0);          \n            indices2.push(idx0, idx1, idx0, idx3);      \n        }\n    }\n    return {\n        positions: new Float32Array(pts),\n        normals: new Float32Array(normals),\n        uvs: new Float32Array(uvs),\n        indices: new Uint32Array(indices),\n        indices2: new Uint32Array(indices2),\n    };\n}\n\nexport const getCubeData = (side = 2, uLength = 1, vLength = 1) => {\n    let s2 = side / 2;\n    let positions = new Float32Array([\n        s2,  s2,  s2,   // index 0\n        s2,  s2, -s2,   // index 1\n        s2, -s2,  s2,   // index 2\n        s2, -s2, -s2,   // index 3\n       -s2,  s2, -s2,   // index 4\n       -s2,  s2,  s2,   // index 5\n       -s2, -s2, -s2,   // index 6\n       -s2, -s2,  s2,   // index 7\n       -s2,  s2, -s2,   // index 8\n        s2,  s2, -s2,   // index 9\n       -s2,  s2,  s2,   // index 10\n        s2,  s2,  s2,   // index 11\n       -s2, -s2,  s2,   // index 12\n        s2, -s2,  s2,   // index 13\n       -s2, -s2, -s2,   // index 14\n        s2, -s2, -s2,   // index 15\n       -s2,  s2,  s2,   // index 16\n        s2,  s2,  s2,   // index 17\n       -s2, -s2,  s2,   // index 18\n        s2, -s2,  s2,   // index 19\n        s2,  s2, -s2,   // index 20\n       -s2,  s2, -s2,   // index 21\n        s2, -s2, -s2,   // index 22\n       -s2, -s2, -s2,   // index 23\n    ]); \n\n    let colors = new Float32Array([\n        1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0,\n        0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,\n        0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1,\n        0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0,\n        0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1,\n        1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0\n    ]);\n\n    let normals = new Float32Array([\n        1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,\n       -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0,\n        0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,\n        0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,  0,\n        0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,\n        0,  0, -1,  0,  0, -1,  0,  0, -1,  0,  0, -1,\n    ]);\n\n    let u = uLength;\n    let v = vLength;\n    let uvs = new Float32Array([\n        0, v, u, v, 0, 0, u, 0, 0, v, u, v, 0, 0, u, 0, \n        0, v, u, v, 0, 0, u, 0, 0, v, u, v, 0, 0, u, 0, \n        0, v, u, v, 0, 0, u, 0, 0, v, u, v, 0, 0, u, 0, \n    ]);\n\n    let indices = new Uint32Array([     // triangle indices\n         0,  2,  1,\n         2,  3,  1,\n         4,  6,  5,\n         6,  7,  5,\n         8, 10,  9,\n        10, 11,  9,\n        12, 14, 13,\n        14, 15, 13,\n        16, 18, 17,\n        18, 19, 17,\n        20, 22, 21,\n        22, 23, 21,\n    ]);\n\n    let indices2 = new Uint32Array([    // wireframe indices\n        8, 9, 9, 11, 11, 10, 10, 8,     // top\n        14, 15, 15, 13, 13, 12, 12, 14, // bottom\n        11, 13, 9, 15, 8, 14, 10, 12,   // side\n    ])\n    \n    return {positions, colors, normals, uvs, indices, indices2};\n}","import vert_shaderPath from './shader/shadow-vert.wgsl';\nimport frag_shaderPath from './shader/shadow-frag.wgsl';\nimport depth_shaderPath from './shader/shadow-depth.wgsl';\n\nimport * as ws from '../common/ws';\nimport { getCubeData, getTorusData } from '../common/vertex-data';\nimport { vec3, mat4 } from 'gl-matrix';\n\nimport { createTransforms, createGPUBuffer, loadWGSL } from '../../WebGPU_NJS_Sandbox_Light/lib';\n\nexport class WW {\n    constructor(div: HTMLElement) {\n        run(div);\n    }\n}\n\n\nconst createPipeline = async (init:ws.IWebGPUInit, data: any, numObjects: number): Promise<ws.IPipeline> => {   \n\n    const vert_shader = await loadWGSL(vert_shaderPath);\n    const frag_shader = await loadWGSL(frag_shaderPath);\n    const depth_shader = await loadWGSL(depth_shaderPath);\n\n\n    // pipeline for shape\n    const descriptor = ws.createRenderPipelineDescriptor({\n        init,\n        vsShader: vert_shader as string,\n        fsShader:frag_shader as string,\n        buffers: ws.setVertexBuffers(['float32x3', 'float32x3']),\n    });\n    const pipeline = await init.device.createRenderPipelineAsync(descriptor);\n   \n    // pipeline for shadow\n    const descriptor2 = ws.createRenderPipelineDescriptor({\n        init,\n        vsShader: depth_shader as string,\n        buffers: ws.setVertexBuffers(['float32x3', 'float32x3']),\n    }, false);\n    const shadowPipeline = await init.device.createRenderPipelineAsync(descriptor2);\n    \n    // create depth view\n    const depthTexture = ws.createDepthTexture(init);\n    \n    // create depth texture for shadow\n    const shadowDepthTexture = init.device.createTexture({\n        size: [2048, 2048],\n        format: 'depth24plus',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n      \n    // create vertex and index buffers for cube\n    const cubeData = data.cubeData;\n    const vertexBuffer = ws.createBufferWithData(init.device, cubeData.positions);\n    const normalBuffer = ws.createBufferWithData(init.device, cubeData.normals);\n    const indexBuffer = ws.createBufferWithData(init.device, cubeData.indices);\n\n    // create vertex and index buffers for torus\n    const torusData = data.torusData;\n    const vertexBuffer1 = ws.createBufferWithData(init.device, torusData.positions);\n    const normalBuffer1 = ws.createBufferWithData(init.device, torusData.normals);\n    const indexBuffer1 = ws.createBufferWithData(init.device, torusData.indices);\n\n    const torusData2 = data.torusData2;\n    const vertexBuffer2 = ws.createBufferWithData(init.device, torusData2.positions);\n    const normalBuffer2 = ws.createBufferWithData(init.device, torusData2.normals);\n    const indexBuffer2 = ws.createBufferWithData(init.device, torusData2.indices);\n\n    // uniform buffer for transform matrix\n    const vpUniformBuffer = ws.createBuffer(init.device, 64);\n    const modelUniformBuffer = ws.createBuffer(init.device, 64 * numObjects, ws.BufferType.Storage);\n    const normalUniformBuffer = ws.createBuffer(init.device, 64 * numObjects, ws.BufferType.Storage);\n    const colorUniformBuffer = ws.createBuffer(init.device, 16 * numObjects, ws.BufferType.Storage);\n\n    // uniform buffer for light projection\n    const lightProjectUniformBuffer = ws.createBuffer(init.device, 64);\n\n    // uniform buffer for light \n    const lightUniformBuffer = ws.createBuffer(init.device, 48);\n   \n    // uniform buffer for material\n    const materialUniformBuffer = ws.createBuffer(init.device, 16); \n   \n    // uniform bind group for vertex shader\n    const vertBindGroup = ws.createBindGroup(\n        init.device, \n        pipeline.getBindGroupLayout(0), \n        [vpUniformBuffer, modelUniformBuffer, normalUniformBuffer, \n        lightProjectUniformBuffer, colorUniformBuffer]);\n\n    // uniform bind group for fragment shader\n    const fragBindGroup = ws.createBindGroup(\n        init.device, \n        pipeline.getBindGroupLayout(1), \n        [lightUniformBuffer, materialUniformBuffer], \n        [shadowDepthTexture.createView(), init.device.createSampler({\n            compare: 'less',\n        })]);\n    \n    // uniform bind group for shadow\n    const shadowBindGroup = ws.createBindGroup(\n        init.device, \n        shadowPipeline.getBindGroupLayout(0), \n        [modelUniformBuffer, lightProjectUniformBuffer]\n        );\n    \n    return {\n        pipelines: [pipeline, shadowPipeline],\n        vertexBuffers: [\n            vertexBuffer, normalBuffer, indexBuffer,    // for cube\n            vertexBuffer1, normalBuffer1, indexBuffer1, // for sphere \n            vertexBuffer2, normalBuffer2, indexBuffer2, // for sphere \n        ],\n        uniformBuffers: [\n            vpUniformBuffer,\n            modelUniformBuffer,\n            normalUniformBuffer,\n            lightProjectUniformBuffer,\n            colorUniformBuffer,\n            lightUniformBuffer,\n            materialUniformBuffer      \n        ],\n        uniformBindGroups: [vertBindGroup, fragBindGroup, shadowBindGroup],\n        depthTextures: [depthTexture, shadowDepthTexture], \n    };\n}\n\n\n\nconst run = async (divHost) => {\n    const canvas = document.createElement('canvas');\n    // this.canvas.style.width = '100px';\n    // this.canvas.style.height = '100px';\n    canvas.width = divHost.clientWidth;\n    canvas.height = divHost.clientHeight;\n    divHost.appendChild(canvas);\n\n    const init = await ws.initWebGPU({canvas});\n\n    let numObjects = 3;\n    const cubeData = getCubeData();\n    const torusData = getTorusData(1.5, 0.1, 60, 20);\n    const torusData2 = getTorusData(0.8, 0.3, 20, 10);\n    const data = { cubeData, torusData, torusData2 };\n\n\n    const p = await createPipeline(init, data, numObjects);\n  \n    let vt = ws.createViewTransform([0,10,20]);\n    let viewMat = vt.viewMat;\n\n    let aspect = init.size.width / init.size.height;      \n    let projectMat = ws.createProjectionMat(aspect);\n    let vpMat = ws.combineVpMat(viewMat, projectMat);\n\n    init.device.queue.writeBuffer(p.uniformBuffers[0], 0, vpMat as ArrayBuffer);\n    let eyePosition = new Float32Array(vt.cameraOptions.eye);\n    init.device.queue.writeBuffer(p.uniformBuffers[5], 16, eyePosition as Float32Array);\n\n    // var gui = ws.getDatGui();\n    // document.querySelector('#gui').append(gui.domElement);\n    const params = {\n        animateSpeed: 1,\n        specularColor: '#ffffff',\n        ambient: 0.4,\n        diffuse: 0.04,\n        specular: 0.4,\n        shininess: 30,\n    };\n     \n    // gui.add(params, 'animateSpeed', 0, 5, 0.01);  \n    // gui.addColor(params, 'specularColor');\n\n    // var folder = gui.addFolder('Set lighting parameters');\n    // folder.open();\n    // folder.add(params, 'ambient', 0, 1, 0.02);  \n    // folder.add(params, 'diffuse', 0, 1, 0.02);  \n    // folder.add(params, 'specular', 0, 1, 0.02);  \n    // folder.add(params, 'shininess', 0, 300, 1);  \n\n    const scene: any[] = [];  \n    const mMat = new Float32Array(16* numObjects);\n    const nMat = new Float32Array(16* numObjects);\n    const cVec = new Float32Array(4 * numObjects);\n   \n    // add a cube as floor\n    {\n        let translation = vec3.fromValues(0, -13, -20);\n        const rotation = vec3.fromValues(0, 0, 0);\n        const scale = vec3.fromValues(30, 0.1, 20);\n        let m = ws.createModelMat(translation, rotation, scale);\n        let n = ws.createNormalMat(m);\n        mMat.set(m, 0);\n        nMat.set(n, 0);\n        cVec.set([0.5, 0.5, 0.7, 1], 0);\n        scene.push( {translation, rotation, scale} );\n    }   \n\n    // add a torus \n    {\n        let translation = vec3.fromValues(0, -5, -20);\n        let rotation = vec3.fromValues(Math.PI/2, 0, 0);\n        let scale = vec3.fromValues(4, 4, 4);\n        let m = ws.createModelMat(translation, rotation, scale);\n        let n = ws.createNormalMat(m);\n        mMat.set(m, 16);\n        nMat.set(n, 16);\n        cVec.set([Math.random(), Math.random(), Math.random()], 4);\n        scene.push({translation, rotation, scale }); \n    }\n\n    {\n        let translation = vec3.fromValues(0, -5, -20);\n        let rotation = vec3.fromValues(Math.PI, 0, 0);\n        let scale = vec3.fromValues(4, 4, 4);\n        let m = ws.createModelMat(translation, rotation, scale);\n        let n = ws.createNormalMat(m);\n        mMat.set(m, 16);\n        nMat.set(n, 16);\n        cVec.set([Math.random(), Math.random(), Math.random()], 4);\n        scene.push({translation, rotation, scale }); \n    }\n\n    init.device.queue.writeBuffer(p.uniformBuffers[4], 0, cVec);\n      \n    const lightMat = mat4.create();\n    const lightProjectMat = mat4.create();\n    const lightPosition = vec3.fromValues(0, 100, 0);\n\n    // let stats = ws.getStats();\n    let start = performance.now();\n    let h0 = 0.1;\n    let v0 = 0.2;\n\n    const frame = () => {     \n        // stats.begin();\n        let dt = params.animateSpeed * (performance.now() - start)/1000;\n        lightPosition[0] = 50 * Math.sin(dt);\n        lightPosition[2] = 50 * Math.cos(dt);\n\n        // update uniform buffers for light position and colors\n        init.device.queue.writeBuffer(p.uniformBuffers[5], 0, lightPosition as Float32Array);\n        init.device.queue.writeBuffer(p.uniformBuffers[5], 32, ws.hex2rgb(params.specularColor));\n\n        // update uniform buffer for material\n        init.device.queue.writeBuffer(p.uniformBuffers[6], 0, new Float32Array([\n            params.ambient, params.diffuse, params.specular, params.shininess\n        ]));\n        \n        mat4.lookAt(lightMat, lightPosition, [0,0,0], [0,1,0]);\n        mat4.ortho(lightProjectMat, -40, 40, -40, 40, -50, 200);\n        mat4.multiply(lightProjectMat, lightProjectMat, lightMat);\n        init.device.queue.writeBuffer(p.uniformBuffers[3], 0, lightProjectMat as Float32Array);\n        \n        // update torus position:\n        const torus = scene[1];\n        // torus.rotation[2] = 2 * dt;\n        // torus.translation[0] += h0;\n        // torus.translation[2] -= h0;\n        // torus.translation[1] += v0;\n        if(torus.translation[0] < -20 || torus.translation[0] > 20) {\n        //     h0 *= -1;\n        }\n        if(torus.translation[1] < -5 || torus.translation[1] > 8) {\n            // v0 *= -1;\n        }\n\n        let m = ws.createModelMat(torus.translation, torus.rotation, torus.scale);\n        let n = ws.createNormalMat(m);\n        mMat.set(m, 16);\n        nMat.set(n, 16);\n\n\n        // update uniform buffers for transformation \n        init.device.queue.writeBuffer(p.uniformBuffers[1], 0, mMat);  \n        init.device.queue.writeBuffer(p.uniformBuffers[2], 0, nMat);     \n        // init.device.queue.writeBuffer(p.uniformBuffers[3], 0, nMat);     \n\n        draw(init, p, data, numObjects);   \n\n        requestAnimationFrame(frame);\n        // stats.end();\n    };\n    frame();\n}\n\nconst draw = (init:ws.IWebGPUInit, p:ws.IPipeline, data:any, numObjects:number) => {  \n    const commandEncoder =  init.device.createCommandEncoder();\n\n    // draw shadow\n    let descriptor = ws.createRenderPassDescriptor({init, depthView: p.depthTextures[1].createView()}, false);\n    let shadowPass = commandEncoder.beginRenderPass(descriptor);\n    \n    shadowPass.setPipeline(p.pipelines[1]);\n    shadowPass.setBindGroup(0, p.uniformBindGroups[2]);\n\n    // draw cubes\n    shadowPass.setVertexBuffer(0, p.vertexBuffers[0]);\n    shadowPass.setVertexBuffer(1, p.vertexBuffers[1]);\n    shadowPass.setIndexBuffer(p.vertexBuffers[2], 'uint32');\n    shadowPass.drawIndexed(data.cubeData.indices.length, 1, 0, 0, 0);\n\n    // draw torus\n    shadowPass.setVertexBuffer(0, p.vertexBuffers[3]);\n    shadowPass.setVertexBuffer(1, p.vertexBuffers[4]);\n    shadowPass.setIndexBuffer(p.vertexBuffers[5], 'uint32');\n    shadowPass.drawIndexed(data.torusData.indices.length, 1, 0, 0, 1);\n\n    shadowPass.setVertexBuffer(0, p.vertexBuffers[6]);\n    shadowPass.setVertexBuffer(1, p.vertexBuffers[7]);\n    shadowPass.setIndexBuffer(p.vertexBuffers[8], 'uint32');\n    shadowPass.drawIndexed(data.torusData2.indices.length, 1, 0, 0, 1);\n    \n    shadowPass.end();\n    \n   \n    // render objects:\n    descriptor = ws.createRenderPassDescriptor({init, depthView: p.depthTextures[0].createView()});\n    let renderPass = commandEncoder.beginRenderPass(descriptor);\n\n    renderPass.setPipeline(p.pipelines[0]);\n    renderPass.setBindGroup(0, p.uniformBindGroups[0]);\n    renderPass.setBindGroup(1, p.uniformBindGroups[1]);\n\n    // draw cubes\n\n    // for(let i = 0 ;i < p.vertexBuffers.length; i+=3 ) {\n\n    let index = 0;\n    let id = 1\n    for(let object in data) {\n        // renderPass.setVertexBuffer(0, p.vertexBuffers[index++]);\n        // renderPass.setVertexBuffer(1, p.vertexBuffers[index++]);\n        // renderPass.setIndexBuffer(p.vertexBuffers[index++], 'uint32');\n        // renderPass.drawIndexed(data[object].indices.length, 1, 0, 0, id);\n    }\n\n        renderPass.setVertexBuffer(0, p.vertexBuffers[0]);\n        renderPass.setVertexBuffer(1, p.vertexBuffers[1]);\n        renderPass.setIndexBuffer(p.vertexBuffers[2], 'uint32');\n        renderPass.drawIndexed(data.cubeData.indices.length, 1, 0, 0, 0);\n    \n        // draw torus\n        renderPass.setVertexBuffer(0, p.vertexBuffers[3]);\n        renderPass.setVertexBuffer(1, p.vertexBuffers[4]);\n        renderPass.setIndexBuffer(p.vertexBuffers[5], 'uint32');\n        renderPass.drawIndexed(data.torusData.indices.length, 1, 0, 0, 1); \n    \n\n        renderPass.setVertexBuffer(0, p.vertexBuffers[6]);\n        renderPass.setVertexBuffer(1, p.vertexBuffers[7]);\n        renderPass.setIndexBuffer(p.vertexBuffers[8], 'uint32');\n        renderPass.drawIndexed(data.torusData2.indices.length, 1, 0, 0, 1); \n    // }\n\n\n\n    renderPass.end();\n    \n    init.device.queue.submit([commandEncoder.finish()]);\n}","import { vec2, vec3, mat4 } from 'gl-matrix';\nimport { } from '../../lib';\n\nexport class Camera {\n    public viewMatrix = mat4.create();\n    public projectionMatrix = mat4.create(); \n    public viewProjectionMatrix = mat4.create();\n\n    public zoomMax = 100;\n    public zoomSpeed = 2;\n\n    public near = 0.01;\n    public far = 10000;\n\n    public mvpMatrix = mat4.create();\n\n    public eye = vec3.fromValues(0,0,0);\n    // public eye = vec3.fromValues(0, 1, 0);\n    public center = vec3.fromValues(0, 0, 0);\n    public up = vec3.fromValues(0, 1, 0);\n\n    public type ='camera';\n\n    public respectRatio: number;\n    public width: number;\n    public height: number;\n\n    public angleXY = Math.PI; \n    public angleZ = Math.PI * 0.25;\n    public distance = 1;\n\n    constructor(width: number = 100, height: number = 100, cameraPosition: vec3 = [2, 2, 4], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance: number = 5) {\n        this.distance = distance; this.width = width; this.height = height; this.respectRatio = width / height\n        this.eye = cameraPosition;\n        this.center = center;\n        this.up = up;\n    }\n    public zoom(v: number) { \n        //\n    }\n    public update() {\n        mat4.lookAt(this.viewMatrix, this.eye, this.center, this.up);\n        mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);\n\n        // createTransforms(this.modelMatrix, this.translation, this.rotation);\n        // mat4.multiply(this.mvpMatrix, this.viewProjectionMatrix, this.viewMatrix);\n        // console.log(this.type);\n    }\n    \n}\n\nexport class CameraPerspective extends Camera {\n    constructor(width = 100, height = 100, cameraPosition: vec3 = [2, 2, 4], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance = 3){\n        super(width, height, cameraPosition, center, up, distance);\n        this.type = 'CameraPerspective';\n        this.init();\n    }\n    public init() {\n        mat4.perspective(this.projectionMatrix, 2 * Math.PI / 5, this.respectRatio, this.near, this.far);\n        this.update();\n    }\n    public zoom (v: number ) {\n        this.distance += v * 0.01;\n    }\n\n}\nexport class CameraOrth extends Camera {\n    constructor(width = 100, height = 100, cameraPosition: vec3 = [0 ,0, 1], center: vec3 = [0, 0, 0],  up: vec3 = [0, 1, 0], distance = 300.1){\n        super(width, height, cameraPosition, center, up, distance);\n        this.type = 'CameraOrth';\n        this.init()\n    }\n    public init() {\n        projection(this.projectionMatrix, this.width, this.height, this.near , this.far, this.distance);\n\n        // const aspectRatio = width / height;\n        // const zoomFactor = 0.1; //this.distance;\n        // const projectionMatrix = mat4.ortho(\n        //   -aspectRatio * zoomFactor,\n        //   aspectRatio * zoomFactor,\n        //   -1 * zoomFactor,\n        //   1 * zoomFactor,\n        //   0.1,\n        //   100.0\n        // );\n\n        // mat4.ortho(this.projectionMatrix, -aspectRatio * zoomFactor, aspectRatio * zoomFactor,  -1 * zoomFactor, 1 * zoomFactor, this.near, this.far);\n        // mat4.ortho(this.projectionMatrix, 0, 500, 800, 0, 0.1, 5000);\n        // mat4.ortho(this.projectionMatrix, 0, 0, 800, 800, -400 , 400);\n        // mat4.frustum(this.projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n\n        this.angleXY = 0;\n        this.angleZ = 0;\n        this.update();\n    }\n    public zoom(v: number) {\n        this.distance += v + 50 / this.distance;\n        if (this.distance < 0.000001) { this.distance = 0.000001; }\n        if (this.distance > 100000) { this.distance = 100000; }\n        projection(this.projectionMatrix, this.width, this.height, this.near, this.far, this.distance);\n    }\n}\n\nconst projection = (dst, width, height, near , far, scale) => {\n    // Note: This matrix flips the Y axis so that 0 is at the top.\n    // dst = dst || new Float32Array(16);\n    dst[ 0] = 2 / width * scale;    dst[ 1] = 0;                    dst[ 2] = 0;                        dst[ 3] = 0;\n    dst[ 4] = 0;                    dst[ 5] = 2 / height * scale;   dst[ 6] = 0;                        dst[ 7] = 0;\n    dst[ 8] = 0;                    dst[ 9] = 0;                    dst[10] = -2 / (far - near);       dst[11] = 0;\n    dst[12] = 0;                    dst[13] = 0;                    dst[14] = 0.1;                      dst[15] = 1;\n    // dst[12] = -1;                dst[13] = 1;                    dst[14] = 0.5;                      dst[15] = 1;\n    return dst;\n};\n\n// const createOrthographicMatrix = (left, right, bottom, top, near, far) => {\n//     const tx = -(right + left) / (right - left);\n//     const ty = -(top + bottom) / (top - bottom);\n//     const tz = -(far + near) / (far - near);\n  \n//     return [\n//       2 / (right - left), 0, 0, 0,\n//       0, 2 / (top - bottom), 0, 0,\n//       0, 0, -2 / (far - near), 0,\n//       tx, ty, tz, 1,\n//     ];\n//   }","import { vec2, vec3, mat4 } from 'gl-matrix';\nimport { Camera, CameraPerspective, CameraOrth } from './Cameras';\nimport { Renderer } from '..';\n\nexport class CameraController {\n    public solution: Renderer;\n    public canvas: HTMLCanvasElement\n\n    public cameraOrth: Camera;\n    public cameraPerspective: Camera;\n\n    public camera: Camera;\n\n    private modelMatrix: mat4 = mat4.create();\n    private mvpMatrix: mat4 = mat4.create();\n\n    // public vMatrix: mat4;\n    // public vpMatrix: mat4;\n    public rotation =vec3.fromValues(0, 0, 0); \n    public translation =vec3.fromValues(0, 0, 0);\n    public screen2 = vec2.fromValues(0, 0);\n\n    // public projectionMatrix = mat4.create();\n\n    // public eye = vec3.fromValues(0,10,0);\n    // angleXY 1.9300000000000026 angleZ -0.47999999999999976 5 distance\n\n    // angleXY 2.6400000000000046 angleZ 0.6799999999999998 3.3800000000000017 distance\n    // src_njslab_Infrastructure_WebGPU_WebGPU_NJS_Sandbox_01_index_ts.chunk.js:1121 camera.eye Float32Array(3) [1.2636959552764893, -2.3044490814208984, 2.1253204345703125,\n\n\n    constructor(solution: Renderer) {\n        this.solution = solution;\n        this.canvas = solution.canvas;\n\n        const eye = vec3.fromValues(2.6451475620269775, 3.130298137664795, 2.864337205886841); // 1.6399056911468506, 1.1976807117462158, 1.162699580192566\n        // const eye = vec3.fromValues(10, -10, 2);\n        const center = vec3.fromValues(0, 0, 0);\n        const up = vec3.fromValues(0, 0, 1);\n\n        this.cameraPerspective = new CameraPerspective(this.canvas.width, this.canvas.height, eye, center, up);\n        this.camera = this.cameraPerspective; \n        this.arcRotation(0, 0);\n\n        this.cameraOrth = new CameraOrth(this.canvas.width, this.canvas.height);\n        this.camera = this.cameraOrth; // this.cameraPerspective // this.cameraOrth;\n\n        this.update();\n    }\n    public update() {\n        // mat4.lookAt(this.vMatrix, this.eye, this.center, this.up);\n        this.camera.update();\n\n        // mat4.multiply(this.camera.viewProjectionMatrix, this.camera.projectionMatrix, this.camera.viewMatrix);\n        createTransforms(this.modelMatrix, this.translation, this.rotation);\n        mat4.multiply(this.mvpMatrix, this.camera.viewProjectionMatrix, this.modelMatrix);\n        // console.log('camera updated...');\n    }\n    public rotateZ(val = 0.1) {\n        this.rotation[2] += val;\n        this.update();\n    }\n    public translateX(val = 0.1) {\n        this.translation[0] += val;\n        this.update();\n    }\n    public get getMatrix() {\n        return this.mvpMatrix;\n    }\n    public shiftCamera() {\n        // console.log('shiftCamera');\n        if (this.camera === this.cameraPerspective){\n            this.camera = this.cameraOrth;\n        } else {\n            this.camera = this.cameraPerspective;\n        }\n        this.update();\n    }\n    public moveCamera(x: number, y: number) {\n        if (this.camera === this.cameraPerspective){\n            this.arcRotation(x, y);\n        } else {\n            this.pan(x, y);\n        }\n    }\n    public arcRotation(x: number, y: number) {\n        x = x * -0.01;\n        y = y * -0.01;\n        this.camera.angleXY += x;\n        this.camera.angleZ += y;\n        this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.camera.angleXY) * Math.cos(this.camera.angleZ)) * this.camera.distance;\n        this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.camera.angleXY) * Math.cos(this.camera.angleZ)) * this.camera.distance;\n        this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.camera.angleZ) * this.camera.distance);\n\n        // console.log('angleXY', this.camera.angleXY, 'angleZ', this.camera.angleZ, this.camera.distance, 'distance' )\n        // console.log('camera.eye', this.camera.eye )\n\n\n        this.update();\n    }\n    public zoomWheel(v: number) {\n\n        if (this.camera === this.cameraPerspective){\n            this.camera.zoom(v)\n            this.arcRotation(0, 0);\n        } else {\n            this.camera.zoom(v)\n        }\n        \n        // \n\n        // console.log(this.scale);\n\n        this.update();\n    }\n    public pan(x: number, y: number) {\n        const scale = 0.01\n        this.camera.center[0] += x / this.camera.distance ;\n        this.camera.center[1] -= y / this.camera.distance;\n        this.camera.eye[0] += x / this.camera.distance;\n        this.camera.eye[1] -= y / this.camera.distance;\n        this.update();\n\n    }\n    // public arcRotation(x: number, y: number) {\n    //     x = x * 0.01;\n    //     y = y * 0.01;\n    //     this.angleXY += x;\n    //     this.angleZ += y;\n    //     this.camera.eye[0] = this.camera.center[0] + (Math.sin(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n    //     this.camera.eye[1] = this.camera.center[1] + (Math.cos(this.angleXY) * Math.cos(this.angleZ)) * this.distance;\n    //     this.camera.eye[2] = this.camera.center[2] + (Math.sin(this.angleZ) * this.distance);\n\n    //     console.log('angleXY', this.angleXY, 'angleZ', this.angleZ, this.distance, 'distance' )\n    //     console.log('camera.eye', this.camera.eye )\n    //     this.update();\n    // }\n}\n\nconst createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};","import { Renderer } from '.';\n\nexport enum PrimitiveTopology {\n    PointList = 'point-list',\n    LineList = 'line-list',\n    LineStrip = 'line-strip',\n    TriangleList = 'triangle-list',\n    TriangleStrip = 'triangle-strip',\n}\nexport interface IWebGPUInitInput {\n    /** HTML canvas element */\n    canvas: HTMLCanvasElement;\n    /** The GPU texture format */\n    format?: GPUTextureFormat;\n    /** MSAA count (1 or 4) */\n    msaaCount?: number;\n}\nexport interface IWebGPUInit {\n    /** The GPU device */\n    device?: GPUDevice;\n    /** The GPU canvas context */\n    context?: GPUCanvasContext;\n    /** The GPU texture format */\n    format?: GPUTextureFormat;\n    /** The canvas size */\n    size?: {width: number, height: number};\n    /** The background color for the scene */\n    background?: {r: number, g: number, b: number, a: number};\n    /** MSAA count (1 or 4) */\n    msaaCount?: number;\n}\n\nexport class WebGPU {\n    public renderer: Renderer;\n    public PrimitiveTopology = PrimitiveTopology;\n\n    ctx: GPUCanvasContext;\n    device: GPUDevice;\n    format: GPUTextureFormat;\n\n    commandEncoder: GPUCommandEncoder;\n    renderPass: GPURenderPassEncoder;\n    textureView: GPUTextureView;\n\n    renderPassDescription: GPURenderPassDescriptor;\n    depthTexture : GPUTexture;\n\n    init;\n    msaaCount;\n    background;\n    size;\n\n    constructor(renderer: Renderer) {\n        this.renderer = renderer;\n    }\n    public async initWebGPU() {\n\n        this.init = await initWebGPU({canvas: this.renderer.canvas});\n\n        this.device = this.init.device;\n        this.ctx = this.init.context;\n        this.format = this.init.format;\n        this.msaaCount = this.init.msaaCount;\n        this.background = this.init.background;\n        this.size = this.init.size;\n\n\n        // if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\n        // const adapter = await navigator.gpu.requestAdapter({\n        //     powerPreference: 'high-performance'\n        //     // powerPreference: 'low-power'\n        // })\n        // if (!adapter) { throw new Error('No Adapter Found'); }\n\n        // const device = await adapter.requestDevice()\n        // this.ctx = this.renderer.canvas.getContext('webgpu') as GPUCanvasContext\n        // // this.format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\n        // this.format = \"bgra8unorm\";\n\n        // this.ctx.configure({\n        //     device: device, \n        //     format: this.format,\n        //     // prevent chrome warning\n        //     alphaMode: 'opaque'\n        // });\n\n        // // this.size = { width: this.canvas.width, height: this.canvas.height }\n        // this.device = device;\n\n        // this.textureView = this.ctx.getCurrentTexture().createView();\n        // this.depthTexture = this.device.createTexture({\n        //     size: [this.ctx.canvas.width, this.ctx.canvas.height, 1],\n        //     format: \"depth24plus\",\n        //     usage: GPUTextureUsage.RENDER_ATTACHMENT\n        // });\n        // // this.renderPassDescription = {\n        // //     colorAttachments: [{\n        // //         view: this.textureView,\n        // //         clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, //background color\n        // //         loadOp: 'clear',\n        // //         storeOp: 'store',\n        // //         //@ts-ignore\n        // //         loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        // //     }],\n        // //     depthStencilAttachment: {\n        // //         view: this.depthTexture.createView(),\n        // //         depthClearValue: 1.0,\n        // //         depthLoadOp: 'clear',\n        // //         depthStoreOp: \"store\",\n        // //     }\n        // // };\n        // this.renderPassDescription = {\n        //     colorAttachments: [{\n        //         view: this.textureView,\n        //         clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, //background color\n        //         loadOp: 'clear',\n        //         storeOp: 'store'\n        //     }],\n        //     depthStencilAttachment: {\n        //         view: this.depthTexture.createView(),\n        //         depthClearValue: 1.0,\n        //         depthLoadOp: 'clear',\n        //         depthStoreOp: \"store\",\n        //         //stencilLoadValue: 0,\n        //         //stencilStoreOp: \"store\"\n        //     }\n        // }\n    }\n    public destroy() {\n        this.device.destroy();\n    }\n}\n\n\nexport const checkWebGPUSupport = navigator.gpu? 'Great, your current browser supports WebGPU!' :  `Your current browser does not support WebGPU! Make sure you are on a system with WebGPU enabled.`;\n\nexport const initWebGPU = async (input: IWebGPUInitInput, deviceDescriptor:GPUDeviceDescriptor = {}): Promise<IWebGPUInit> => {\n    // set default parameters\n    input.format = input.format === undefined? navigator.gpu.getPreferredCanvasFormat(): input.format;\n    input.msaaCount = input.msaaCount === undefined? 1: input.msaaCount;\n    \n    if(checkWebGPUSupport.includes('does not support WebGPU')){\n        throw(checkWebGPUSupport);\n    }\n\n    const adapter = await navigator.gpu.requestAdapter();\n    const device = await adapter.requestDevice(deviceDescriptor);\n    const context = input.canvas.getContext('webgpu') as GPUCanvasContext;\n    const pixelRatio = input.canvas.clientWidth / input.canvas.clientHeight;\n    // input.canvas.width = input.canvas.clientWidth * pixelRatio;\n    // input.canvas.height = input.canvas.clientHeight * pixelRatio;\n    const size = {width: input.canvas.width, height: input.canvas.height};\n    context.configure({\n        device: device,\n        format: input.format,\n        alphaMode: 'opaque',\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n    });\n    const background = { r: 0.009, g: 0.0125, b: 0.0164, a: 1.0 };\n    return {device, context, format:input.format, size, background, msaaCount:input.msaaCount};    \n}","import { App } from '..';\nimport { CameraController } from './Camera/CameraController';\nimport { WebGPU } from './WebGPU';\n\nexport class Renderer {\n    public app: App;\n    public canvas: HTMLCanvasElement;\n\n    public cameraController: CameraController;\n    public webGPU: WebGPU;\n\n    public isAnimation: boolean = true;\n    private requestAni: any;\n\n    constructor(app: App) {\n        this.app = app;\n\n        this.canvas = document.createElement('canvas');\n        // this.canvas.style.width = '100px';\n        // this.canvas.style.height = '100px';\n        this.canvas.width = this.app.divHost.clientWidth;\n        this.canvas.height = this.app.divHost.clientHeight;\n        this.app.divHost.appendChild(this.canvas);\n        \n        // window.addEventListener('resize', (ev: UIEvent) => {\n        //     console.log(ev)\n        //     this.canvas.width = this.app.divHost.clientWidth;\n        //     this.canvas.height = this.app.divHost.clientHeight;\n        //     // this.canvas.width = e\n        // });\n\n        this.webGPU = new WebGPU(this);\n    }\n    async init() {\n        await this.webGPU.initWebGPU();\n\n        this.cameraController = new CameraController(this);\n        this.requestAni = requestAnimationFrame(this.loop);\n    }\n\n    public loop = () => {\n        if (this.isAnimation) {\n            this.requestAni = requestAnimationFrame(this.loop);\n        }\n        // this.cameraController.update();\n        this.drawing();\n    }\n    public drawing() {\n        this.app.scene.render();\n    }\n    public destroy() {\n        this.webGPU.destroy();\n        // this.isAnimation = false;\n        cancelAnimationFrame(this.requestAni);\n        // this.requestAni = undefined;\n        while (this.app.divHost.lastElementChild) {\n            this.app.divHost.removeChild(this.app.divHost.lastElementChild);\n        }\n    }\n}\n\n","import { Controller } from './Controller';\r\nimport { Renderer } from './Renderer';\r\nimport { Scene } from './Scene';\r\nimport {  WW } from './web8'\r\n\r\nexport { Renderer } from './Renderer';\r\n\r\n// https://www.youtube.com/playlist?list=PLn3eTxaOtL2Ns3wkxdyS3CiqkJuwQdZzn\r\n// https://www.youtube.com/playlist?list=PL_UrKDEhALdKh0118flOjuAnVIGKFUJXN\r\n\r\n// https://webgpufundamentals.org/\r\n// https://webgpu.github.io/webgpu-samples/\r\n\r\n// https://antongerdelan.net/opengl/raycasting.html\r\n\r\n// https://github.com/jack1232/webgpu-simplified/blob/main/src/index.ts\r\n// https://webgpu-gpu-book.drxudotnet.com/#index\r\n// https://webgpu-gpu-book.drxudotnet.com/#ch01-triangle-primitive\r\n// https://github.com/jack1232/webgpu-new-video-series/tree/main\r\n\r\n// https://codepen.io/g-vitrac/pen/JjeoKgY\r\n\r\n// import {  WW } from './web'\r\n\r\n\r\nexport class App {\r\n    public divHost: HTMLElement;\r\n\r\n    public controller: Controller;\r\n    public renderer: Renderer;\r\n    public scene: Scene;\r\n\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        // this.renderer = new Renderer(this)\r\n        // this.controller = new Controller(this);\r\n        // this.scene = new Scene(this);\r\n\r\n        new WW(this.divHost);\r\n\r\n        this.init();\r\n        // console.log('NWebGPU');\r\n    }\r\n    public async init() {\r\n        // this.controller.init();\r\n        // await this.renderer.init();\r\n        // await this.scene.init();\r\n    };\r\n    public destroy() {\r\n        // this.renderer.destroy();\r\n        // while (this.divHost.lastElementChild) {\r\n        //     this.divHost.removeChild(this.divHost.lastElementChild);\r\n        // }\r\n    }\r\n}\r\n\r\nexport class Solution {\r\n    public app: App\r\n    constructor(id: string) {\r\n        this.app = new App(id)\r\n    }\r\n    public destroy() {\r\n        this.app.destroy();\r\n    }\r\n}","import { vec3, mat4 } from 'gl-matrix';\n\nexport const loadWGSL = async (path: string) => {\n    return fetch(`${path}`)\n        .then((response: Response) => {\n            return response.text();\n        }).catch((err: Error) => {\n            console.debug(err);\n        });\n\n}\n\nexport const createViewProjection = (respectRatio = 1.0, cameraPosition:vec3 = [2, 2, 4], lookDirection:vec3 = [0, 0, 0], \n    upDirection:vec3 = [0, 1, 0]) => {\n\n    const viewMatrix = mat4.create();\n    const projectionMatrix = mat4.create();       \n    const viewProjectionMatrix = mat4.create();\n\n    // mat4.perspective(projectionMatrix, 2 * Math.PI / 5, respectRatio, 0.1, 100.0);\n    mat4.ortho(projectionMatrix, 0, 0, 800, 800, -400 , 400);\n    // mat4.frustum(projectionMatrix, 0, 800, 800, 0, -400, 400);\n\n    mat4.lookAt(viewMatrix, cameraPosition, lookDirection, upDirection);\n    mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);\n\n    const cameraOption = {\n        eye: cameraPosition,\n        center: lookDirection,\n        zoomMax: 100,\n        zoomSpeed: 2\n    };\n\n    return {\n        viewMatrix,\n        projectionMatrix,\n        viewProjectionMatrix,\n        cameraOption\n    }\n};\n\nexport const createTransforms = (modelMat:mat4, translation:vec3 = [0,0,0], rotation:vec3 = [0,0,0], scaling:vec3 = [1,1,1]) => {\n    const rotateXMat = mat4.create();\n    const rotateYMat = mat4.create();\n    const rotateZMat = mat4.create();   \n    const translateMat = mat4.create();\n    const scaleMat = mat4.create();\n\n    //perform individual transformations\n    mat4.fromTranslation(translateMat, translation);\n    mat4.fromXRotation(rotateXMat, rotation[0]);\n    mat4.fromYRotation(rotateYMat, rotation[1]);\n    mat4.fromZRotation(rotateZMat, rotation[2]);\n    mat4.fromScaling(scaleMat, scaling);\n\n    //combine all transformation matrices together to form a final transform matrix: modelMat\n    mat4.multiply(modelMat, rotateXMat, scaleMat);\n    mat4.multiply(modelMat, rotateYMat, modelMat);        \n    mat4.multiply(modelMat, rotateZMat, modelMat);\n    mat4.multiply(modelMat, translateMat, modelMat);\n};\n\nexport const createGPUBuffer = (device:GPUDevice, data:Float32Array, usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\n    // console.log(data.byteLength, data)\n    const buffer = device.createBuffer({\n        size: data.byteLength,\n        usage: usageFlag,\n        mappedAtCreation: true\n    });\n    new Float32Array(buffer.getMappedRange()).set(data);\n    buffer.unmap();\n    return buffer;\n};"],"names":["require","checkWebGPUSupport","navigator","gpu","createRenderPipelineDescriptor","input","indexFormat","withFragment","primitiveType","undefined","cullMode","isDepthStencil","vsEntry","fsEntry","shader","vsShader","fsShader","includes","descriptor","layout","vertex","module","init","device","createShaderModule","code","entryPoint","buffers","fragment","targets","format","primitive","topology","stripIndexFormat","multisample","count","msaaCount","depthStencil","depthWriteEnabled","depthCompare","setVertexBuffers","formats","offsets","totalArrayStride","shaderLocations","len","length","len1","len2","i","stride","parseInt","split","loc","push","arrayStride","attributes","shaderLocation","offset","strides","createRenderPassDescriptor","withColorAttachment","colorAttachmentView","textureView","context","getCurrentTexture","createView","colorAttachmentResolveTarget","colorAttachments","view","resolveTarget","clearValue","background","loadOp","storeOp","depthStencilAttachment","depthView","depthClearValue","depthLoadOp","depthStoreOp","BufferType","createBuffer","bufferSize","bufferType","Uniform","flag","GPUBufferUsage","UNIFORM","COPY_DST","COPY_SRC","Vertex","VERTEX","Index","INDEX","Storage","STORAGE","VertexStorage","IndexStorage","Indirect","INDIRECT","IndirectStorage","Read","MAP_READ","Write","MAP_WRITE","size","usage","getDataType","data","Object","prototype","toString","call","createBufferWithData","dtype","buffer","byteLength","mappedAtCreation","Uint32Array","getMappedRange","set","Uint16Array","Float64Array","Float32Array","unmap","createBindGroup","otherResources","entries","bufLen","resLen","binding","resource","createModelMat","translation","rotation","scale","modelMat","mat4","createNormalMat","normalMat","pi","sin","x","Math","cos","getTorusPosition","R","r","u","v","y","z","vec3","getTorusData","rlarge","rsmall","p0","p1","p2","p3","pts","normals","eps","du","j","dv","normal","n_vertices_per_row","indices","indices2","idx0","idx1","idx2","idx3","positions","WW","constructor","div","run","createPipeline","async","numObjects","vert_shader","loadWGSL","vert_shaderPath","frag_shader","frag_shaderPath","depth_shader","depth_shaderPath","ws","pipeline","createRenderPipelineAsync","descriptor2","shadowPipeline","depthTexture","depthFormat","createTexture","sampleCount","GPUTextureUsage","RENDER_ATTACHMENT","shadowDepthTexture","TEXTURE_BINDING","cubeData","vertexBuffer","normalBuffer","indexBuffer","torusData","vertexBuffer1","normalBuffer1","indexBuffer1","torusData2","vertexBuffer2","normalBuffer2","indexBuffer2","vpUniformBuffer","modelUniformBuffer","normalUniformBuffer","colorUniformBuffer","lightProjectUniformBuffer","lightUniformBuffer","materialUniformBuffer","vertBindGroup","getBindGroupLayout","fragBindGroup","createSampler","compare","shadowBindGroup","pipelines","vertexBuffers","uniformBuffers","uniformBindGroups","depthTextures","canvas","document","createElement","width","divHost","clientWidth","height","clientHeight","appendChild","deviceDescriptor","getPreferredCanvasFormat","adapter","requestAdapter","requestDevice","getContext","window","devicePixelRatio","configure","alphaMode","g","b","a","uLength","vLength","s2","colors","uvs","getCubeData","p","vt","cameraPos","lookDir","upDir","viewMat","cameraOptions","eye","center","zoomMax","zoomSpeed","vpMat","projectionMat","aspectRatio","PI","queue","writeBuffer","eyePosition","params","scene","mMat","nMat","cVec","m","n","random","lightMat","lightProjectMat","lightPosition","start","performance","now","frame","dt","hex","match","map","torus","draw","requestAnimationFrame","commandEncoder","createCommandEncoder","shadowPass","beginRenderPass","setPipeline","setBindGroup","setVertexBuffer","setIndexBuffer","drawIndexed","end","renderPass","object","submit","finish","Camera","cameraPosition","up","distance","viewMatrix","projectionMatrix","viewProjectionMatrix","near","far","mvpMatrix","type","respectRatio","angleXY","angleZ","this","zoom","update","CameraPerspective","super","CameraOrth","projection","dst","CameraController","solution","cameraOrth","cameraPerspective","camera","modelMatrix","screen2","vec2","arcRotation","createTransforms","rotateZ","val","translateX","getMatrix","shiftCamera","moveCamera","pan","zoomWheel","scaling","rotateXMat","rotateYMat","rotateZMat","translateMat","scaleMat","PrimitiveTopology","WebGPU","renderer","ctx","renderPassDescription","initWebGPU","destroy","Renderer","app","cameraController","webGPU","isAnimation","requestAni","loop","drawing","render","cancelAnimationFrame","lastElementChild","removeChild","App","id","controller","getElementById","Solution","fetch","path","then","response","text","catch","err","console","debug","createGPUBuffer","usageFlag"],"sourceRoot":""}