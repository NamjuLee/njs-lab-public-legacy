{"version":3,"file":"static/js/18913.a3d12d6f.chunk.js","mappings":"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","sources":["njslab/Workshop/workshop-three/LAB_Web_13_Voxel/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, getCSVFromURL } from '../../../../lib';\r\n\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n        const scene = this.scene;\r\n        this.camera.position.set(0, 9, 9);\r\n\r\n        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.55);\r\n        this.scene.add(ambientLight);\r\n\r\n        this.pointLight = new THREE.PointLight(0xffffff, 0.75);\r\n        this.pointLight.position.x = 10;\r\n        this.scene.add(this.pointLight);\r\n\r\n        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.55);\r\n        hemiLight.color.setHSL(0.6, 1, 0.6);\r\n        hemiLight.groundColor.setHSL(0.095, 1, 0.75);\r\n        hemiLight.position.set(0, 50, 0);\r\n        scene.add(hemiLight);\r\n\r\n        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);\r\n        dirLight.color.setHSL(1, 1, 1);\r\n        dirLight.position.set(- 1, 1.75, 1);\r\n        dirLight.position.multiplyScalar(30);\r\n        dirLight.castShadow = true;\r\n\r\n        const val = 1; // for quality of the shadow in the scene\r\n        dirLight.shadow.camera.left = - val;\r\n        dirLight.shadow.camera.right = val;\r\n        dirLight.shadow.camera.top = val;\r\n        dirLight.shadow.camera.bottom = - val;\r\n\r\n        dirLight.shadow.camera.far = 100;\r\n        dirLight.shadow.bias = - 0.00001;\r\n        dirLight.shadow.mapSize.width = 2048;\r\n        dirLight.shadow.mapSize.height = 2048;\r\n        scene.add(dirLight);\r\n\r\n\r\n        const distance = (x, y, z, xx, yy, zz) => {\r\n            return Math.sqrt((xx - x) * (xx - x) + (yy - y) * (yy - y) + (zz - z) * (zz - z));\r\n        }\r\n\r\n        // https://en.wikipedia.org/wiki/Wavefront_.obj_file\r\n        const URL_OBJ = 'https://raw.githubusercontent.com/McNopper/OpenGL/master/Binaries/bunny.obj';\r\n        const geometryObj = {\r\n            boundingBox: [],\r\n            vertex: []\r\n        }\r\n\r\n        getCSVFromURL(URL_OBJ).then((obj) => {\r\n            const data = obj.split('\\n');\r\n\r\n            geometryObj.boundingBox = [\r\n                [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE],\r\n                [Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE]\r\n            ]\r\n\r\n            for (let i = 0; i < data.length; ++i) {\r\n                const ln = data[i].split(' ');\r\n                if (ln[0] === 'v') {\r\n                    // console.log(ln)\r\n                    geometryObj.vertex.push([+ln[1], +ln[2], +ln[3], 0]); // the last value used for checking isVisiting or not.\r\n\r\n                    // get min and max vector from the individual vertex by this loop\r\n                    geometryObj.boundingBox[0][0] = geometryObj.boundingBox[0][0] > +ln[1] ? +ln[1] : geometryObj.boundingBox[0][0];\r\n                    geometryObj.boundingBox[0][1] = geometryObj.boundingBox[0][1] > +ln[2] ? +ln[2] : geometryObj.boundingBox[0][1];\r\n                    geometryObj.boundingBox[0][2] = geometryObj.boundingBox[0][2] > +ln[3] ? +ln[3] : geometryObj.boundingBox[0][2];\r\n\r\n                    geometryObj.boundingBox[1][0] = geometryObj.boundingBox[1][0] < +ln[1] ? +ln[1] : geometryObj.boundingBox[1][0];\r\n                    geometryObj.boundingBox[1][1] = geometryObj.boundingBox[1][1] < +ln[2] ? +ln[2] : geometryObj.boundingBox[1][1];\r\n                    geometryObj.boundingBox[1][2] = geometryObj.boundingBox[1][2] < +ln[3] ? +ln[3] : geometryObj.boundingBox[1][2];\r\n                }\r\n            }\r\n            voxelization(geometryObj);\r\n        });\r\n\r\n        const voxelization = (obj) => {\r\n            // ................................................................................\r\n            // your code goes here\r\n\r\n            const theDis = .07;\r\n\r\n            const xNum = 15;\r\n            const yNum = 15;\r\n            const zNum = 15;\r\n\r\n            const xInterval = (obj.boundingBox[1][0] - obj.boundingBox[0][0]) / (xNum - 1);\r\n            const yInterval = (obj.boundingBox[1][1] - obj.boundingBox[0][1]) / (yNum - 1);\r\n            const zInterval = (obj.boundingBox[1][2] - obj.boundingBox[0][2]) / (zNum - 1);\r\n            console.log('xInterval', xInterval, 'yInterval', yInterval, 'zInterval', zInterval)\r\n\r\n            const listVoxel = [];\r\n\r\n            for (let z = 0; z < zNum; ++z) {\r\n                const theZ = obj.boundingBox[0][2] + z * zInterval;\r\n                for (let y = 0; y < yNum; ++y) {\r\n                    const theY = obj.boundingBox[0][1] + y * yInterval;\r\n                    for (let x = 0; x < xNum; ++x) {\r\n                        const theX = obj.boundingBox[0][0] + x * xInterval;\r\n\r\n                        let needLoop = true;\r\n                        for (let i = 0; i < obj.vertex.length; i += 1) {\r\n                            const v = obj.vertex[i];\r\n\r\n                            if (v[3] === 0) {\r\n                                const d = distance(theX, theY, theZ, v[0], v[1], v[2]);\r\n                                if (d < theDis) {\r\n                                    obj.vertex[i][3] = 1;\r\n                                    listVoxel.push([theX, theY, theZ]);\r\n                                    needLoop = false;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (!needLoop) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // console.log(listVoxel)\r\n            // console.log('done!!');\r\n\r\n            for (let i = 0; i < listVoxel.length; ++i) {\r\n                // console.log(i);\r\n                let geometryBox = new THREE.BoxGeometry(xInterval, yInterval, zInterval);\r\n                // geometryBox.computeBoundingSphere();\r\n                // geometryBox.computeVertexNormals();\r\n                geometryBox.computeVertexNormals();\r\n                geometryBox.computeBoundingBox();\r\n\r\n                let materialBox = new THREE.MeshStandardMaterial({ color: 0x967bb6 });\r\n                let meshCube = new THREE.Mesh(geometryBox, materialBox);\r\n\r\n                meshCube.position.x = listVoxel[i][0];\r\n                meshCube.position.y = listVoxel[i][1];\r\n                meshCube.position.z = listVoxel[i][2];\r\n                meshCube.castShadow = true;\r\n                meshCube.receiveShadow = true;\r\n                scene.add(meshCube);\r\n\r\n            }\r\n\r\n            this.start();\r\n        }\r\n    }\r\n    public update(scene: THREE.Scene) {\r\n        var matrix = new THREE.Matrix4();\r\n        matrix.makeRotationY(Math.PI * 0.011);\r\n        this.pointLight.position.applyMatrix4(matrix);\r\n    }\r\n}\r\n"],"names":["Solution","RendererThree","constructor","super","pointLight","scene","this","camera","position","set","ambientLight","THREE","add","x","hemiLight","color","setHSL","groundColor","dirLight","multiplyScalar","castShadow","shadow","left","right","top","bottom","far","bias","mapSize","width","height","distance","y","z","xx","yy","zz","Math","sqrt","geometryObj","boundingBox","vertex","getCSVFromURL","then","obj","data","split","Number","MAX_VALUE","MIN_VALUE","i","length","ln","push","voxelization","xInterval","yInterval","zInterval","console","log","listVoxel","theZ","theY","theX","needLoop","v","geometryBox","computeVertexNormals","computeBoundingBox","materialBox","meshCube","receiveShadow","start","update","matrix","makeRotationY","PI","applyMatrix4"],"sourceRoot":""}