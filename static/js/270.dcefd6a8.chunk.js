"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[270],{270:(e,t,n)=>{n.r(t),n.d(t,{CreateGPUBuffer:()=>a,Solution:()=>r,vertex:()=>i,vertexCount:()=>o});const i=new Float32Array([0,.5,0,-.5,-.5,0,.5,-.5,0]),o=3;class r{constructor(e){this.divHost=void 0,this.canvas=void 0,this.ctx=void 0,this.device=void 0,this.format=void 0,this.size=void 0,this.pipelineObj=void 0,this.mouse=new Float32Array([0,0]),this.divHost=document.getElementById(e),this.canvas=document.createElement("canvas"),this.divHost.appendChild(this.canvas),this.canvas.addEventListener("mousemove",(e=>{this.mouse[0],e.offsetX,this.mouse[1],e.offsetY;this.mouse[0]=e.offsetX,this.mouse[1]=e.offsetY,console.log("mousemove",e)}),!1),this.initWebGPU()}async initWebGPU(){if(!navigator.gpu)throw new Error("Not Support WebGPU");const e=await navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(!e)throw new Error("No Adapter Found");const t=await e.requestDevice();this.ctx=this.canvas.getContext("webgpu");const n=navigator.gpu.getPreferredCanvasFormat?navigator.gpu.getPreferredCanvasFormat():this.ctx.getPreferredFormat(e);window.devicePixelRatio;this.canvas.width=this.divHost.clientWidth,this.canvas.height=this.divHost.clientHeight,this.ctx.configure({device:t,format:n,alphaMode:"opaque"}),this.size={width:this.canvas.width,height:this.canvas.height},this.device=t,this.format=n,this.initPipeline(this.device,this.format)}async initPipeline(e,t){let n,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"triangle-list";"line-strip"===i&&(n="uint32");const o={vertex:"  \n    struct Output {\n        @builtin(position) Position : vec4<f32>,\n        @location(0) vColor : vec4<f32>,\n    };\n\n    @vertex\n    fn main(@builtin(vertex_index) VertexIndex: u32) -> Output {\n        var pos : array<vec2<f32>, 9> = array<vec2<f32>, 9>(             \n            vec2<f32>(-0.63,  0.80),\n            vec2<f32>(-0.65,  0.20),\n            vec2<f32>(-0.20,  0.60),\n            vec2<f32>(-0.37, -0.07),\n            vec2<f32>( 0.05,  0.18),\n            vec2<f32>(-0.13, -0.40),\n            vec2<f32>( 0.30, -0.13),\n            vec2<f32>( 0.13, -0.64),\n            vec2<f32>( 0.70, -0.30)     \n        );\n    \n        var color : array<vec3<f32>, 9> = array<vec3<f32>, 9>(             \n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),\n            vec3<f32>(1.0, 0.0, 0.0),\n            vec3<f32>(0.0, 1.0, 0.0),\n            vec3<f32>(0.0, 0.0, 1.0),  \n        );\n\n        var output: Output;\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n        return output;\n    }",fragment:"\n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }\n    "},r=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:o.vertex}),entryPoint:"main"},fragment:{module:e.createShaderModule({code:o.fragment}),entryPoint:"main",targets:[{format:t}]},primitive:{topology:i,stripIndexFormat:n}}),a=e.createCommandEncoder(),s=this.ctx.getCurrentTexture().createView(),c=a.beginRenderPass({colorAttachments:[{view:s,clearValue:[0,0,0,1],loadOp:"clear",storeOp:"store"}]});c.setPipeline(r),c.draw(9,1,0,0),c.end(),e.queue.submit([a.finish()])}destroy(){for(this.device.destroy();this.divHost.lastElementChild;)this.divHost.removeChild(this.divHost.lastElementChild)}}const a=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST;const i=e.createBuffer({size:t.byteLength,usage:n,mappedAtCreation:!0});return new Float32Array(i.getMappedRange()).set(t),i.unmap(),i}}}]);
//# sourceMappingURL=270.dcefd6a8.chunk.js.map