"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[93926],{93926:(t,e,i)=>{i.d(e,{Z:()=>Pt});var n=i(41941),o=i(69299),s=i(19199);class r extends n.Z{get isComposite(){return!0}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((t=>t.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(){}setState(t){super.setState(t),this.setNeedsUpdate()}getPickingInfo(t){let{info:e}=t;const{object:i}=e;return i&&i.__source&&i.__source.parent&&i.__source.parent.id===this.id?(e.object=i.__source.object,e.index=i.__source.index,e):e}renderLayers(){return null}filterSubLayer(t){return!0}shouldRenderSubLayer(t,e){return e&&e.length}getSubLayerClass(t,e){const{_subLayerProps:i}=this.props;return i&&i[t]&&i[t].type||e}getSubLayerRow(t,e,i){return t.__source={parent:this,object:e,index:i},t}getSubLayerAccessor(t){if("function"===typeof t){const e={data:this.props.data,target:[]};return(i,n)=>i&&i.__source?(e.index=i.__source.index,t(i.__source.object,e)):t(i,n)}return t}getSubLayerProps(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{opacity:e,pickable:i,visible:n,parameters:o,getPolygonOffset:s,highlightedObjectIndex:r,autoHighlight:a,highlightColor:l,coordinateSystem:c,coordinateOrigin:d,wrapLongitude:g,positionFormat:p,modelMatrix:h,extensions:u,fetch:f,_subLayerProps:v}=this.props,y={opacity:e,pickable:i,visible:n,parameters:o,getPolygonOffset:s,highlightedObjectIndex:r,autoHighlight:a,highlightColor:l,coordinateSystem:c,coordinateOrigin:d,wrapLongitude:g,positionFormat:p,modelMatrix:h,extensions:u,fetch:f},m=v&&v[t.id],_=m&&m.updateTriggers,P=t.id||"sublayer";if(m){const e=this.constructor._propTypes,i=t.type?t.type._propTypes:{};for(const t in m){const n=i[t]||e[t];n&&"accessor"===n.type&&(m[t]=this.getSubLayerAccessor(m[t]))}}Object.assign(y,t,m),y.id="".concat(this.props.id,"-").concat(P),y.updateTriggers={all:this.props.updateTriggers.all,...t.updateTriggers,..._};for(const L of u){const t=L.getSubLayerProps.call(this,L);t&&Object.assign(y,t,{updateTriggers:Object.assign(y.updateTriggers,t.updateTriggers)})}return y}_updateAutoHighlight(t){for(const e of this.getSubLayers())e.updateAutoHighlight(t)}_getAttributeManager(){return null}_renderLayers(){let{subLayers:t}=this.internalState;const e=!t||this.needsUpdate();e&&(t=this.renderLayers(),t=(0,s.x)(t,Boolean),this.internalState.subLayers=t),(0,o.Z)("compositeLayer.renderLayers",this,e,t);for(const i of t)i.parent=this}}r.layerName="CompositeLayer";var a=i(77951),l=i(54517),c=i(38378);const d="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",g={lightSources:{}};function p(){let{color:t=[0,0,0],intensity:e=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.map((t=>t*e/255))}const h={name:"lights",vs:d,fs:d,getUniforms:function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:g;if("lightSources"in e){const{ambientLight:t,pointLights:i,directionalLights:n}=e.lightSources||{};return t||i&&i.length>0||n&&n.length>0?Object.assign({},function(t){let{ambientLight:e,pointLights:i=[],directionalLights:n=[]}=t;const o={};return o["lighting_uAmbientLight.color"]=e?p(e):[0,0,0],i.forEach(((t,e)=>{o["lighting_uPointLight[".concat(e,"].color")]=p(t),o["lighting_uPointLight[".concat(e,"].position")]=t.position,o["lighting_uPointLight[".concat(e,"].attenuation")]=t.attenuation||[1,0,0]})),o.lighting_uPointLightCount=i.length,n.forEach(((t,e)=>{o["lighting_uDirectionalLight[".concat(e,"].color")]=p(t),o["lighting_uDirectionalLight[".concat(e,"].direction")]=t.direction})),o.lighting_uDirectionalLightCount=n.length,o}({ambientLight:t,pointLights:i,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in e){const i={pointLights:[],directionalLights:[]};for(const t of e.lights||[])switch(t.type){case"ambient":i.ambientLight=t;break;case"directional":i.directionalLights.push(t);break;case"point":i.pointLights.push(t)}return t({lightSources:i})}return{}},defines:{MAX_LIGHTS:3}},u="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",f={};function v(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:f;if(!("material"in t))return{};const{material:e}=t;return e?function(t){const{ambient:e=.35,diffuse:i=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:i,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(e):{lighting_uEnabled:!1}}const y={name:"gouraud-lighting",dependencies:[h],vs:u,defines:{LIGHTING_VERTEX:1},getUniforms:v};var m=i(43992),_=i(56128),P=i(96952),L=i(29382),x=i(44681),S=i(90643),b=i(57089),C=i.n(b);const w=1,A=-1;function E(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Math.sign(function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{start:i=0,end:n=t.length}=e,o=e.size||2;let s=0;for(let r=i,a=n-o;r<n;r+=o)s+=(t[r]-t[a])*(t[r+1]+t[a+1]),a=r;return s/2}(t,e))}(t,i);return n!==e&&(function(t,e){const{start:i=0,end:n=t.length,size:o=2}=e,s=(n-i)/o,r=Math.floor(s/2);for(let a=0;a<r;++a){const e=i+a*o,n=i+(s-1-a)*o;for(let i=0;i<o;++i){const o=t[e+i];t[e+i]=t[n+i],t[n+i]=o}}}(t,i),!0)}function T(t,e,i,n){let o,s,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];if(8&i)o=(n[3]-t[1])/(e[1]-t[1]),s=3;else if(4&i)o=(n[1]-t[1])/(e[1]-t[1]),s=1;else if(2&i)o=(n[2]-t[0])/(e[0]-t[0]),s=2;else{if(!(1&i))return null;o=(n[0]-t[0])/(e[0]-t[0]),s=0}for(let a=0;a<t.length;a++)r[a]=(1&s)===a?n[s]:o*(e[a]-t[a])+t[a];return r}function z(t,e){let i=0;return t[0]<e[0]?i|=1:t[0]>e[2]&&(i|=2),t[1]<e[1]?i|=4:t[1]>e[3]&&(i|=8),i}function I(t,e){const i=e.length,n=t.length;if(n>0){let o=!0;for(let s=0;s<i;s++)if(t[n-i+s]!==e[s]){o=!1;break}if(o)return!1}for(let o=0;o<i;o++)t[n+o]=e[o];return!0}function M(t,e){const i=e.length;for(let n=0;n<i;n++)t[n]=e[n]}function R(t,e,i,n){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];const s=n+e*i;for(let r=0;r<i;r++)o[r]=t[s+r];return o}function G(t,e){const{size:i=2,broken:n=!1,gridResolution:o=10,gridOffset:s=[0,0],startIndex:r=0,endIndex:a=t.length}=e||{},l=(a-r)/i;let c=[];const d=[c],g=R(t,0,i,r);let p,h;const u=j(g,o,s,[]),f=[];I(c,g);for(let v=1;v<l;v++){for(p=R(t,v,i,r,p),h=z(p,u);h;){T(g,p,h,u,f);const t=z(f,u);t&&(T(g,f,t,u,f),h=t),I(c,f),M(g,f),B(u,o,h),n&&c.length>i&&(c=[],d.push(c),I(c,g)),h=z(p,u)}I(c,p),M(g,p)}return n?d:d[0]}const O=0,F=1;function D(t,e){for(let i=0;i<e.length;i++)t.push(e[i]);return t}function N(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2?arguments[2]:void 0;if(!t.length)return[];const{size:n=2,gridResolution:o=10,gridOffset:s=[0,0],edgeTypes:r=!1}=i||{},a=[],l=[{pos:t,types:r?new Array(t.length/n).fill(F):null,holes:e||[]}],c=[[],[]];let d=[];for(;l.length;){const{pos:t,types:e,holes:i}=l.shift();V(t,n,i[0]||t.length,c),d=j(c[0],o,s,d);const g=z(c[1],d);if(g){let o=k(t,e,n,0,i[0]||t.length,d,g);const s={pos:o[0].pos,types:o[0].types,holes:[]},a={pos:o[1].pos,types:o[1].types,holes:[]};l.push(s,a);for(let l=0;l<i.length;l++)o=k(t,e,n,i[l],i[l+1]||t.length,d,g),o[0]&&(s.holes.push(s.pos.length),s.pos=D(s.pos,o[0].pos),r&&(s.types=D(s.types,o[0].types))),o[1]&&(a.holes.push(a.pos.length),a.pos=D(a.pos,o[1].pos),r&&(a.types=D(a.types,o[1].types)))}else{const n={positions:t};r&&(n.edgeTypes=e),i.length&&(n.holeIndices=i),a.push(n)}}return a}function k(t,e,i,n,o,s,r){const a=(o-n)/i,l=[],c=[],d=[],g=[],p=[];let h,u,f;const v=R(t,a-1,i,n);let y=Math.sign(8&r?v[1]-s[3]:v[0]-s[2]),m=e&&e[a-1],_=0,P=0;for(let L=0;L<a;L++)h=R(t,L,i,n,h),u=Math.sign(8&r?h[1]-s[3]:h[0]-s[2]),f=e&&e[n/i+L],u&&y&&y!==u&&(T(v,h,r,s,p),I(l,p)&&d.push(m),I(c,p)&&g.push(m)),u<=0?(I(l,h)&&d.push(f),_-=u):d.length&&(d[d.length-1]=O),u>=0?(I(c,h)&&g.push(f),P+=u):g.length&&(g[g.length-1]=O),M(v,h),y=u,m=f;return[_?{pos:l,types:e&&d}:null,P?{pos:c,types:e&&g}:null]}function j(t,e,i,n){const o=Math.floor((t[0]-i[0])/e)*e+i[0],s=Math.floor((t[1]-i[1])/e)*e+i[1];return n[0]=o,n[1]=s,n[2]=o+e,n[3]=s+e,n}function B(t,e,i){8&i?(t[1]+=e,t[3]+=e):4&i?(t[1]-=e,t[3]-=e):2&i?(t[0]+=e,t[2]+=e):1&i&&(t[0]-=e,t[2]-=e)}function V(t,e,i,n){let o=1/0,s=-1/0,r=1/0,a=-1/0;for(let l=0;l<i;l+=e){const e=t[l],i=t[l+1];o=e<o?e:o,s=e>s?e:s,r=i<r?i:r,a=i>a?i:a}return n[0][0]=o,n[0][1]=r,n[1][0]=s,n[1][1]=a,n}const W=85.051129;function U(t,e,i,n){let o=-1,s=-1;for(let r=i+1;r<n;r+=e){const e=Math.abs(t[r]);e>o&&(o=e,s=r-1)}return s}function Z(t,e,i,n){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:W;const s=t[i],r=t[n-e];if(Math.abs(s-r)>180){const n=R(t,0,e,i);n[0]+=360*Math.round((r-s)/360),I(t,n),n[1]=Math.sign(n[1])*o,I(t,n),n[0]=s,I(t,n)}}function H(t,e,i,n){let o,s=t[0];for(let r=i;r<n;r+=e){o=t[r];const e=o-s;(e>180||e<-180)&&(o-=360*Math.round(e/360)),t[r]=s=o}}function J(t,e){let i;const n=t.length/e;for(let s=0;s<n&&(i=t[s*e],(i+180)%360===0);s++);const o=360*-Math.round(i/360);if(0!==o)for(let s=0;s<n;s++)t[s*e]+=o}const X=w,K=A,Y={isClosed:!0};function q(t,e,i,n,o){let s=e;const r=i.length;for(let a=0;a<r;a++)for(let e=0;e<n;e++)t[s++]=i[a][e]||0;if(!function(t){const e=t[0],i=t[t.length-1];return e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]}(i))for(let a=0;a<n;a++)t[s++]=i[0][a]||0;return Y.start=e,Y.end=s,Y.size=n,E(t,o,Y),s}function Q(t,e,i,n){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0,r=arguments.length>6?arguments[6]:void 0;s=s||i.length;const a=s-o;if(a<=0)return e;let l=e;for(let c=0;c<a;c++)t[l++]=i[o+c];if(!function(t,e,i,n){for(let o=0;o<e;o++)if(t[i+o]!==t[n-e+o])return!1;return!0}(i,n,o,s))for(let c=0;c<n;c++)t[l++]=i[o+c];return Y.start=e,Y.end=l,Y.size=n,E(t,r,Y),l}function $(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const i=[],n=[];if(t.positions){const{positions:o,holeIndices:s}=t;if(s){let t=0;for(let r=0;r<=s.length;r++)t=Q(i,t,o,e,s[r-1],s[r],0===r?X:K),n.push(t);return n.pop(),{positions:i,holeIndices:n}}t=o}if(Number.isFinite(t[0]))return Q(i,0,t,e,0,i.length,X),i;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let o=0;for(const[s,r]of t.entries())o=q(i,o,r,e,0===s?X:K),n.push(o);return n.pop(),{positions:i,holeIndices:n}}return q(i,0,t,e,X),i}var tt=i(86715),et=i(23438),it=i(85694);class nt{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{attributes:e={}}=t;this.typedArrayManager=tt.Z,this.indexStarts=null,this.vertexStarts=null,this.vertexCount=0,this.instanceCount=0,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t),Object.seal(this)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:i={},getGeometry:n,geometryBuffer:o,positionFormat:s,dataChanged:r,normalize:a=!0}=this.opts;if(this.data=e,this.getGeometry=n,this.positionSize=o&&o.size||("XY"===s?2:3),this.buffers=i,this.normalize=a,o&&((0,et.Z)(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),a||(i.positions=o)),this.geometryBuffer=i.positions,Array.isArray(r))for(const l of r)this._rebuildGeometry(l);else this._rebuildGeometry()}updatePartialGeometry(t){let{startRow:e,endRow:i}=t;this._rebuildGeometry({startRow:e,endRow:i})}normalizeGeometry(t){return t}updateGeometryAttributes(t,e,i){throw new Error("Not implemented")}getGeometrySize(t){throw new Error("Not implemented")}getGeometryFromBuffer(t){const e=t.value||t;return(0,et.Z)(ArrayBuffer.isView(e)),(0,l.jr)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices})}_allocate(t,e){const{attributes:i,buffers:n,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in n)s.release(i[r]),i[r]=null;else{const n=o[r];n.copy=e,i[r]=s.allocate(i[r],t,n)}}_forEachGeometry(t,e,i){const{data:n,getGeometry:o}=this,{iterable:s,objectInfo:r}=(0,l.jB)(n,e,i);for(const a of s){r.index++;t(o(a,r),r.index)}}_rebuildGeometry(t){if(!this.data||!this.getGeometry)return;let{indexStarts:e,vertexStarts:i,instanceCount:n}=this;const{data:o,geometryBuffer:s}=this,{startRow:r=0,endRow:a=1/0}=t||{},l={};if(t||(e=[0],i=[0]),this.normalize||!s)this._forEachGeometry(((t,e)=>{t=this.normalizeGeometry(t),l[e]=t,i[e+1]=i[e]+this.getGeometrySize(t)}),r,a),n=i[i.length-1];else if(s.buffer instanceof it.Z){const t=s.stride||4*this.positionSize;i=o.startIndices,n=i[o.length]||s.buffer.byteLength/t}else{const t=s.value||s,e=s.stride/t.BYTES_PER_ELEMENT||this.positionSize;i=o.startIndices,n=i[o.length]||t.length/e}this._allocate(n,Boolean(t)),this.indexStarts=e,this.vertexStarts=i,this.instanceCount=n;const c={};this._forEachGeometry(((t,o)=>{t=l[o]||t,c.vertexStart=i[o],c.indexStart=e[o];const s=o<i.length-1?i[o+1]:n;c.geometrySize=s-i[o],c.geometryIndex=o,this.updateGeometryAttributes(t,c)}),r,a),this.vertexCount=e[e.length-1]}}class ot extends nt{constructor(t){const{fp64:e,IndexType:i=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:i,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;e&&(this.vertexCount=(e.value||e).length)}normalizeGeometry(t){if(this.normalize){if(t=$(t,this.positionSize),this.opts.resolution)return N(t.positions||t,t.holeIndices,{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0});if(this.opts.wrapLongitude)return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2?arguments[2]:void 0;const{size:n=2,normalize:o=!0,edgeTypes:s=!1}=i||{};e=e||[];const r=[],a=[];let l=0,c=0;for(let g=0;g<=e.length;g++){const o=e[g]||t.length,s=c,d=U(t,n,l,o);for(let e=d;e<o;e++)r[c++]=t[e];for(let e=l;e<d;e++)r[c++]=t[e];H(r,n,s,c),Z(r,n,s,c,null===i||void 0===i?void 0:i.maxLatitude),l=o,a[g]=c}a.pop();const d=N(r,a,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(o)for(const g of d)J(g.positions,n);return d}(t.positions||t,t.holeIndices,{size:this.positionSize,maxLatitude:86,edgeTypes:!0})}return t}getGeometrySize(t){if(Array.isArray(t)&&!Number.isFinite(t[0])){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}return(t.positions||t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):()=>null}updateGeometryAttributes(t,e){if(Array.isArray(t)&&!Number.isFinite(t[0]))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else this._updateIndices(t,e),this._updatePositions(t,e),this._updateVertexValid(t,e)}_updateIndices(t,e){let{geometryIndex:i,vertexStart:n,indexStart:o}=e;const{attributes:s,indexStarts:r,typedArrayManager:a}=this;let l=s.indices;if(!l)return;let c=o;const d=function(t,e,i){let n=null;t.holeIndices&&(n=t.holeIndices.map((t=>t/e)));let o=t.positions||t;if(i){const t=o.length;o=o.slice();const n=[];for(let s=0;s<t;s+=e){n[0]=o[s],n[1]=o[s+1];const t=i(n);o[s]=t[0],o[s+1]=t[1]}}return C()(o,n,e)}(t,this.positionSize,this.opts.preproject);l=a.allocate(l,o+d.length,{copy:!0});for(let g=0;g<d.length;g++)l[c++]=d[g]+n;r[i+1]=o+d.length,s.indices=l}_updatePositions(t,e){let{vertexStart:i,geometrySize:n}=e;const{attributes:{positions:o},positionSize:s}=this;if(!o)return;const r=t.positions||t;for(let a=i,l=0;l<n;a++,l++){const t=r[l*s],e=r[l*s+1],i=s>2?r[l*s+2]:0;o[3*a]=t,o[3*a+1]=e,o[3*a+2]=i}}_updateVertexValid(t,e){let{vertexStart:i,geometrySize:n}=e;const{attributes:{vertexValid:o},positionSize:s}=this,r=t&&t.holeIndices;if(t&&t.edgeTypes?o.set(t.edgeTypes,i):o.fill(1,i,i+n),r)for(let a=0;a<r.length;a++)o[i+r[a]/s-1]=0;o[i+n-1]=0}}const st="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n\n#ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",rt="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(st,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n"),at="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(st,"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n"),lt=[0,0,0,255],ct={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:lt},getLineColor:{type:"accessor",value:lt},material:!0},dt={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class gt extends n.Z{getShaders(t){return super.getShaders({vs:"top"===t?rt:at,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[c.Z,y,m.Z]})}get wrapLongitude(){return!1}initializeState(){const{gl:t,viewport:e}=this.context;let{coordinateSystem:i}=this.props;e.isGeospatial&&i===_.Df.DEFAULT&&(i=_.Df.LNGLAT),this.setState({numInstances:0,polygonTesselator:new ot({preproject:i===_.Df.LNGLAT&&e.projectFlat,fp64:this.use64bitPositions(),IndexType:!t||(0,P.ag)(t,L.h.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const n=this.getAttributeManager(),o=!0;n.remove(["instancePickingColors"]),n.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:o},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:dt,accessor:"getPolygon",update:this.calculatePositions,noAlloc:o,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:o},elevations:{size:1,transition:dt,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{alias:"colors",size:this.props.colorFormat.length,type:5121,normalized:!0,transition:dt,accessor:"getFillColor",defaultValue:lt,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{alias:"colors",size:this.props.colorFormat.length,type:5121,normalized:!0,transition:dt,accessor:"getLineColor",defaultValue:lt,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(t&&t.__source?t.__source.index:i,n)},shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw(t){let{uniforms:e}=t;const{extruded:i,filled:n,wireframe:o,elevationScale:s}=this.props,{topModel:r,sideModel:a,polygonTesselator:l}=this.state,c={...e,extruded:Boolean(i),elevationScale:s};a&&(a.setInstanceCount(l.instanceCount-1),a.setUniforms(c),o&&(a.setDrawMode(3),a.setUniforms({isWireframe:!0}).draw()),n&&(a.setDrawMode(6),a.setUniforms({isWireframe:!1}).draw())),r&&(r.setVertexCount(l.vertexCount),r.setUniforms(c).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager();var s;(n.extensionsChanged||e.filled!==i.filled||e.extruded!==i.extruded)&&(null===(s=this.state.models)||void 0===s||s.forEach((t=>t.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry(t){let{props:e,oldProps:i,changeFlags:n}=t;if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:t}=this.state,i=e.data.attributes||{};t.updateGeometry({data:e.data,normalize:e._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:e.getPolygon,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:i,extruded:n}=this.props;let o,s;if(i){const i=this.getShaders("top");i.defines.NON_INSTANCED_MODEL=1,o=new x.Z(t,{...i,id:"".concat(e,"-top"),drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return n&&(s=new x.Z(t,{...this.getShaders("side"),id:"".concat(e,"-side"),geometry:new S.Z({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}function pt(t,e,i,n){let o=t;if(Array.isArray(t[0])){const i=t.length*e;o=new Array(i);for(let n=0;n<t.length;n++)for(let i=0;i<e;i++)o[n*e+i]=t[n][i]||0}return i?G(o,{size:e,gridResolution:i}):n?function(t,e){const{size:i=2,startIndex:n=0,endIndex:o=t.length,normalize:s=!0}=e||{},r=t.slice(n,o);H(r,i,0,o-n);const a=G(r,{size:i,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(const l of a)J(l,i);return a}(o,{size:e}):o}gt.layerName="SolidPolygonLayer",gt.defaultProps=ct;class ht extends nt{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):()=>null}normalizeGeometry(t){return this.normalize?pt(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}get(t){return this.attributes[t]}getGeometrySize(t){if(Array.isArray(t[0])){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&Array.isArray(t[0]))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const{segmentTypes:i}=this.attributes,n=this.isClosed(t),{vertexStart:o,geometrySize:s}=e;i.fill(0,o,o+s),n?(i[o]=4,i[o+s-2]=4):(i[o]+=1,i[o+s-2]+=2),i[o+s-1]=4}_updatePositions(t,e){const{positions:i}=this.attributes;if(!i)return;const{vertexStart:n,geometrySize:o}=e,s=new Array(3);for(let r=n,a=0;a<o;r++,a++)this.getPointOnPath(t,a,s),i[3*r]=s[0],i[3*r+1]=s[1],i[3*r+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);const o=e*n;return i[0]=t[o],i[1]=t[o+1],i[2]=3===n&&t[o+2]||0,i}isClosed(t){if(!this.normalize)return this.opts.loop;const{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(2===e||t[2]===t[i+2])}}const ut=[0,0,0,255],ft={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:ut},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},vt={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class yt extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[c.Z,m.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:vt,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:vt,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:vt,defaultValue:ut},instancePickingColors:{size:3,type:5121,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(t&&t.__source?t.__source.index:i,n)}}}),this.setState({pathTesselator:new ht({fp64:this.use64bitPositions()})}),this.props.getDashArray&&!this.props.extensions.length&&a.Z.removed("getDashArray","PathStyleExtension")()}updateState(t){let{oldProps:e,props:i,changeFlags:n}=t;super.updateState({props:i,oldProps:e,changeFlags:n});const o=this.getAttributeManager();if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,e=i.data.attributes||{};t.updateGeometry({data:i.data,geometryBuffer:e.getPath,buffers:e,normalize:!i._pathType,loop:"loop"===i._pathType,getGeometry:i.getPath,positionFormat:i.positionFormat,wrapLongitude:i.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:n.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||o.invalidateAll()}if(n.extensionsChanged){var s;const{gl:t}=this.context;null===(s=this.state.model)||void 0===s||s.delete(),this.state.model=this._getModel(t),o.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw(t){let{uniforms:e}=t;const{jointRounded:i,capRounded:n,billboard:o,miterLimit:s,widthUnits:r,widthScale:a,widthMinPixels:l,widthMaxPixels:c}=this.props;this.state.model.setUniforms(e).setUniforms({jointType:Number(i),capType:Number(n),billboard:o,widthUnits:_.iI[r],widthScale:a,miterLimit:s,widthMinPixels:l,widthMaxPixels:c}).draw()}_getModel(t){return new x.Z(t,{...this.getShaders(),id:this.props.id,geometry:new S.Z({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}yt.layerName="PathLayer",yt.defaultProps=ft;const mt=[0,0,0,255],_t={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:t=>t.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:mt},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class Pt extends r{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&a.Z.removed("getLineDashArray","PathStyleExtension")()}updateState(t){let{oldProps:e,props:i,changeFlags:n}=t;const o=n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon);if(o&&Array.isArray(n.dataChanged)){const t=this.state.paths.slice(),e=n.dataChanged.map((e=>function(t){let{data:e,getIndex:i,dataRange:n,replace:o}=t;const{startRow:s=0,endRow:r=1/0}=n,a=e.length;let l=a,c=a;for(let h=0;h<a;h++){const t=i(e[h]);if(l>h&&t>=s&&(l=h),t>=r){c=h;break}}let d=l;const g=c-l!==o.length,p=g&&e.slice(c);for(let h=0;h<o.length;h++)e[d++]=o[h];if(g){for(let t=0;t<p.length;t++)e[d++]=p[t];e.length=d}return{startRow:l,endRow:l+o.length}}({data:t,getIndex:t=>t.__source.index,dataRange:e,replace:this._getPaths(e)})));this.setState({paths:t,pathsDiff:e})}else o&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{data:e,getPolygon:i,positionFormat:n,_normalize:o}=this.props,s=[],r="XY"===n?2:3,{startRow:a,endRow:c}=t,{iterable:d,objectInfo:g}=(0,l.jB)(e,a,c);for(const l of d){g.index++;let t=i(l,g);o&&(t=$(t,r));const{holeIndices:e}=t,n=t.positions||t;if(e)for(let i=0;i<=e.length;i++){const t=n.slice(e[i-1]||0,e[i]||n.length);s.push(this.getSubLayerRow({path:t},l,g.index))}else s.push(this.getSubLayerRow({path:n},l,g.index))}return s}renderLayers(){const{data:t,_dataDiff:e,stroked:i,filled:n,extruded:o,wireframe:s,_normalize:r,_windingOrder:a,elevationScale:l,transitions:c,positionFormat:d}=this.props,{lineWidthUnits:g,lineWidthScale:p,lineWidthMinPixels:h,lineWidthMaxPixels:u,lineJointRounded:f,lineMiterLimit:v,lineDashJustified:y}=this.props,{getFillColor:m,getLineColor:_,getLineWidth:P,getLineDashArray:L,getElevation:x,getPolygon:S,updateTriggers:b,material:C}=this.props,{paths:w,pathsDiff:A}=this.state,E=this.getSubLayerClass("fill",gt),T=this.getSubLayerClass("stroke",yt),z=this.shouldRenderSubLayer("fill",w)&&new E({_dataDiff:e,extruded:o,elevationScale:l,filled:n,wireframe:s,_normalize:r,_windingOrder:a,getElevation:x,getFillColor:m,getLineColor:o&&s?_:mt,material:C,transitions:c},this.getSubLayerProps({id:"fill",updateTriggers:{getPolygon:b.getPolygon,getElevation:b.getElevation,getFillColor:b.getFillColor,lineColors:o&&s,getLineColor:b.getLineColor}}),{data:t,positionFormat:d,getPolygon:S});return[!o&&z,!o&&i&&this.shouldRenderSubLayer("stroke",w)&&new T({_dataDiff:A&&(()=>A),widthUnits:g,widthScale:p,widthMinPixels:h,widthMaxPixels:u,jointRounded:f,miterLimit:v,dashJustified:y,_pathType:"loop",transitions:c&&{getWidth:c.getLineWidth,getColor:c.getLineColor,getPath:c.getPolygon},getColor:this.getSubLayerAccessor(_),getWidth:this.getSubLayerAccessor(P),getDashArray:this.getSubLayerAccessor(L)},this.getSubLayerProps({id:"stroke",updateTriggers:{getWidth:b.getLineWidth,getColor:b.getLineColor,getDashArray:b.getLineDashArray}}),{data:w,positionFormat:d,getPath:t=>t.path}),o&&z]}}Pt.layerName="PolygonLayer",Pt.defaultProps=_t}}]);
//# sourceMappingURL=93926.732381bf.chunk.js.map