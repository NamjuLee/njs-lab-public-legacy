"use strict";(self.webpackChunkNJS_Lab=self.webpackChunkNJS_Lab||[]).push([[47154],{47154:(t,i,s)=>{s.r(i),s.d(i,{Renderer:()=>r,Solution:()=>h});var e=s(55913);class h{constructor(t){this.divHost=void 0,this.renderer=void 0,this.divHost=document.getElementById(t),this.divHost.style.display="flex",this.divHost.style.alignItems="center";const i=document.createElement("div");i.style.marginLeft="auto",i.style.marginRight="auto",i.style.backgroundColor="#555",i.style.width="1000px",i.style.height="600px",this.divHost.appendChild(i),this.renderer=new r(i);let s=document.createElement("div");i.appendChild(s),s.textContent="Reset",s.onclick=()=>{this.renderer.Build()},s=document.createElement("div"),i.appendChild(s),s.textContent="Play and Stop toggle",s.onclick=()=>{this.renderer.playToggle=!this.renderer.playToggle}}destroy(){for(this.renderer.destroy();this.divHost.lastElementChild;)this.divHost.removeChild(this.divHost.lastElementChild)}}const o=(t,i,s,e)=>{t.fillStyle=s,t.beginPath(),t.rect(i.x*e,i.y*e,e-1,e-1),t.closePath(),t.fill()};class r extends e.bb{constructor(t){super(t),this.w=0,this.h=0,this.cols=0,this.rows=0,this.cellSize=20,this.gridWidth=0,this.gridHeight=0,this.chanceOfWalls=.15,this.connectionDiagonal=!0,this.graph=void 0,this.playToggle=!0,this.frame=0,this.divTextIteration=void 0,this.canvas.style.position="relative",this.canvas.style.width="100%",this.canvas.style.height="100%",this.divTextIteration=document.createElement("div"),t.appendChild(this.divTextIteration),this.Build(),this.start()}update(){for(let t=0;t<this.cols;t++)for(let i=0;i<this.rows;i++){const s=this.graph.grid[t][i];s.count=0;for(let t=0;t<s.neighbors.length;t++)s.neighbors[t].alive&&s.count++}for(let t=0;t<this.cols;t++)for(let i=0;i<this.rows;i++){const s=this.graph.grid[t][i];s.alive?s.count<2?s.alive=!1:1<s.count&&s.count<4?s.alive=!0:s.count>3&&(s.alive=!1):3===s.count&&(s.alive=!0)}}render(t){this.playToggle&&(this.divTextIteration.textContent="".concat(this.frame++," iterations")),this.graph.doneComputation&&this.Build(),this.frame%10===0&&this.update();for(let i=0;i<this.cols;i++)for(let s=0;s<this.rows;s++){const e=this.graph.grid[i][s];let h="rgb(255, 255, 255)";e.blocked&&(h="rgba(0, 0, 0, 0.9)"),e===this.graph.endNode&&(h="rgba(255, 0, 255, 0.9)"),e.alive&&(h="rgba(0, 0, 0, 1)"),o(t,e,h,this.cellSize)}for(let i=0;i<this.graph.openNodes.length;i++){const s=this.graph.openNodes[i];o(t,s,"rgb(0, 0, 255)",this.cellSize)}for(let i=0;i<this.graph.closedNodes.length;i++){const s=this.graph.closedNodes[i];o(t,s,"rgb(255, 0, 0)",this.cellSize)}for(let i=0;i<this.graph.path.length;i++){const s=this.graph.path[i];o(t,s,"rgb(0, 255, 0)",this.cellSize)}}Build(){this.frame=0,this.w=this.canvas.width,this.h=this.canvas.height,this.cols=Math.floor(this.w/this.cellSize),this.rows=Math.floor(this.h/this.cellSize),this.gridWidth=this.w,this.gridHeight=this.h,this.graph=new l,this.graph.connectionDiagonal=this.connectionDiagonal;for(let t=0;t<this.cols;t++)for(let i=0;i<this.rows;i++){void 0===this.graph.grid[t]&&(this.graph.grid[t]=[]);const s=new n(t,i);Math.random()<this.chanceOfWalls&&(s.alive=!0),this.graph.grid[t][i]=s}for(let t=0;t<this.cols;t++)for(let i=0;i<this.rows;i++)this.graph.buildConnection(this.graph.grid[t][i],this.cols,this.rows)}}class l{constructor(){this.grid=[],this.openNodes=[],this.closedNodes=[],this.startNode=void 0,this.endNode=void 0,this.path=[],this.heuristicConst=1,this.doneComputation=!1,this.connectionDiagonal=!0,this.buildConnection=(t,i,s)=>{if(t.blocked)return;let e=t.x,h=t.y;e<i-1&&(this.grid[e+1][h].blocked||t.neighbors.push(this.grid[e+1][h])),h<s-1&&(this.grid[e][h+1].blocked||t.neighbors.push(this.grid[e][h+1])),e>0&&(this.grid[e-1][h].blocked||t.neighbors.push(this.grid[e-1][h])),h>0&&(this.grid[e][h-1].blocked||t.neighbors.push(this.grid[e][h-1])),this.connectionDiagonal&&(e>0&&h>0&&(this.grid[e-1][h-1].blocked||t.neighbors.push(this.grid[e-1][h-1])),e<i-1&&h<s-1&&(this.grid[e+1][h+1].blocked||t.neighbors.push(this.grid[e+1][h+1])),e>0&&h<s-1&&(this.grid[e-1][h+1].blocked||t.neighbors.push(this.grid[e-1][h+1])),e<i-1&&h>0&&(this.grid[e+1][h-1].blocked||t.neighbors.push(this.grid[e+1][h-1])))}}}class n{constructor(t,i){this.f=0,this.h=0,this.g=0,this.x=0,this.y=0,this.z=0,this.neighbors=[],this.count=0,this.alive=!1,this.blocked=!1,this.f=0,this.h=0,this.g=0,this.x=t,this.y=i,this.neighbors=[]}}}}]);
//# sourceMappingURL=47154.750e274b.chunk.js.map