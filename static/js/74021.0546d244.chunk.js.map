{"version":3,"file":"static/js/74021.0546d244.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/Util/index.ts","njslab/Infrastructure/WebGPU/WebGPU_01_Basic Loop UI/UI.ts","njslab/Infrastructure/WebGPU/WebGPU_01_Basic Loop UI/index.ts"],"sourcesContent":["export const getSlider = (title: string, min: number, max: number) => {\n    // <input type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\">\n    const div = document.createElement('div');\n    div.style.display = 'flex';\n\n    const slider = document.createElement('input');\n    slider.type = 'range';\n    slider.min = `${min}`;\n    slider.max = `${max}`;\n\n    const text = document.createElement('div');\n    text.textContent = title;\n    text.style.color = '#aaa';\n    div.appendChild(slider);\n    div.appendChild(text);\n    return {\n        div, slider, text\n    }\n};\n\nexport * from './MatUtil';","import { getSlider } from '../Util';\nimport { Solution } from './';\n\nexport class UI {\n    public divHost: HTMLElement;\n    public solution: Solution;\n    public divColor: HTMLInputElement;\n    public divRange: any;\n\n    constructor(solution: Solution) {\n        this.solution = solution;\n        this.divHost = solution.divHost;\n\n        this.divColor = document.createElement('input');\n        this.divColor.type = 'color';\n        this.divColor.defaultValue = '#ff0000';\n        // this.divColor.style.position = 'absolute';\n        this.divHost.appendChild(this.divColor);\n\n        this.divRange = getSlider('size', 0, 100);\n        this.divHost.appendChild(this.divRange.div);\n\n        this.appendEvent();\n    }\n    public appendEvent() {\n        // update colorBuffer if color changed\n        this.divColor.addEventListener('input', (e: Event) => {\n            const color = (e.target as HTMLInputElement).value; // get hex color string\n            const r = +('0x' + color.slice(1, 3)) / 255; // parse hex color into rgb\n            const g = +('0x' + color.slice(3, 5)) / 255;\n            const b = +('0x' + color.slice(5, 7)) / 255;\n            // write colorBuffer with new color\n            this.solution.device.queue.writeBuffer(this.solution.pipelineObj.colorBuffer, 0, new Float32Array([r, g, b, 1]));\n            this.solution.run();\n        });\n\n        // update vertexBuffer\n        this.divRange.slider.addEventListener('input', (e: Event) => {\n            // get input value\n            const value = +(e.target as HTMLInputElement).value;\n            // console.log(value)\n            // chagne vertex 0/3/6\n            this.solution.vertex[0] = 0;\n            this.solution.vertex[3] = -0.5 + -(value * 0.01);\n            this.solution.vertex[6] = 0.5 + (value * 0.01);\n            // write vertexBuffer with new vertex\n            this.solution.device.queue.writeBuffer(this.solution.pipelineObj.vertexBuffer, 0, this.solution.vertex);\n            this.solution.run();\n        });\n\n        // re-configure context on resize\n        window.addEventListener('resize', () => {\n            this.solution.canvas.width = this.solution.divHost.clientWidth;\n            this.solution.canvas.height = this.solution.divHost.clientHeight;\n            // don't need to recall context.configure() after v104\n            this.solution.run();\n        });\n    }\n}","import { UI } from './UI';\r\n\r\n\r\nconst positionVert = `\r\n@vertex\r\nfn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\r\n    return vec4<f32>(position, 1.0);\r\n}\r\n`\r\nconst colorFrag = `\r\n@group(0) @binding(0) var<uniform> color : vec4<f32>;\r\n\r\n@fragment\r\nfn main() -> @location(0) vec4<f32> {\r\n    return color;\r\n}\r\n`\r\n\r\nexport class Solution {\r\n    divHost: HTMLElement;\r\n    canvas: HTMLCanvasElement;\r\n    ctx: GPUCanvasContext;\r\n    device: GPUDevice;\r\n    format: GPUTextureFormat;\r\n    size: any;\r\n    pipelineObj: any;\r\n    ui: UI;\r\n    vertex = new Float32Array([\r\n        0.0, 0.5, 0.0,\r\n        -0.5, -0.5, 0.0,\r\n        0.5, -0.5, 0.0\r\n    ])\r\n    vertexCount = 3\r\n    mouse = new Float32Array([\r\n       0,0\r\n    ])\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        //     console.log(id, 'webGPU', navigator.gpu);\r\n        this.canvas = document.createElement('canvas');\r\n        this.divHost.appendChild(this.canvas);\r\n\r\n        this.canvas.addEventListener('mousemove', (e: MouseEvent) => {\r\n            // console.log('move dragging')\r\n            const xOff = this.mouse[0] - e.offsetX;\r\n            const yOff = this.mouse[1] - e.offsetY;\r\n\r\n            this.mouse[0] = e.offsetX;\r\n            this.mouse[1] = e.offsetY;\r\n\r\n            // console.log('mousemove', e);\r\n        }, false);\r\n\r\n        this.ui = new UI(this)\r\n        this.initWebGPU();\r\n    }\r\n    async initWebGPU() {\r\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\r\n\r\n        const adapter = await navigator.gpu.requestAdapter({\r\n            powerPreference: 'high-performance'\r\n            // powerPreference: 'low-power'\r\n        })\r\n\r\n        if (!adapter) { throw new Error('No Adapter Found'); }\r\n\r\n        const device = await adapter.requestDevice()\r\n        this.ctx = this.canvas.getContext('webgpu') as GPUCanvasContext\r\n        // @ts-ignore\r\n        const format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\r\n        const devicePixelRatio = window.devicePixelRatio || 1\r\n        this.canvas.width = this.divHost.clientWidth;\r\n        this.canvas.height = this.divHost.clientHeight;\r\n        this.ctx.configure({\r\n            // json specific format when key and value are the same\r\n            device, format,\r\n            // prevent chrome warning\r\n            alphaMode: 'opaque'\r\n        })\r\n\r\n        this.size = { width: this.canvas.width, height: this.canvas.height }\r\n        this.device = device;\r\n        this.format = format;\r\n\r\n        this.initPipeline(this.device, this.format);\r\n    }\r\n    async initPipeline(device: GPUDevice, format: GPUTextureFormat) {\r\n\r\n        const pipeline = await device.createRenderPipelineAsync({\r\n            label: 'Basic Pipline',\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: device.createShaderModule({ code: positionVert, }),\r\n                entryPoint: 'main',\r\n                buffers: [\r\n                    {\r\n                    arrayStride: 3 * 4, // 3 float32,\r\n                    attributes: [\r\n                            {\r\n                                // position xyz\r\n                                shaderLocation: 0,\r\n                                offset: 0,\r\n                                format: 'float32x3',\r\n                            }\r\n                        ]\r\n                    }\r\n                ]\r\n            },\r\n            fragment: {\r\n                module: device.createShaderModule({ code: colorFrag, }),\r\n                entryPoint: 'main',\r\n                targets: [\r\n                    {\r\n                        format: format\r\n                    }\r\n                ]\r\n            },\r\n            primitive: {\r\n                topology: 'triangle-list' // try point-list, line-list, line-strip, triangle-strip?\r\n            }\r\n        } as GPURenderPipelineDescriptor);\r\n\r\n\r\n        // create vertex buffer\r\n        const vertexBuffer = device.createBuffer({\r\n            label: 'GPUBuffer store vertex',\r\n            size: this.vertex.byteLength,\r\n            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\r\n            //mappedAtCreation: true\r\n        })\r\n        device.queue.writeBuffer(vertexBuffer, 0, this.vertex);\r\n\r\n\r\n        // create color buffer\r\n        const colorBuffer = device.createBuffer({\r\n            label: 'GPUBuffer store rgba color',\r\n            size: 4 * 4, // 4 * float32\r\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\r\n        })\r\n        device.queue.writeBuffer(colorBuffer, 0, new Float32Array([0, 1, 1, 1]))\r\n\r\n        const uniformGroup = device.createBindGroup({\r\n            label: 'Uniform Group with colorBuffer',\r\n            layout: pipeline.getBindGroupLayout(0),\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: {\r\n                        buffer: colorBuffer\r\n                    }\r\n                },\r\n            ]\r\n        })\r\n        // return all vars\r\n        //     console.log('working');\r\n        this.pipelineObj = { pipeline, vertexBuffer, colorBuffer, uniformGroup }\r\n        this.run();\r\n    }\r\n    public run() {\r\n        this.draw(this.device, this.ctx, this.pipelineObj)\r\n    }\r\n    draw(device: GPUDevice, context: GPUCanvasContext, pipelineObj: {\r\n        pipeline: GPURenderPipeline,\r\n        vertexBuffer: GPUBuffer,\r\n        colorBuffer: GPUBuffer,\r\n        uniformGroup: GPUBindGroup\r\n    }) {\r\n        // console.log('run...');\r\n        const commandEncoder = device.createCommandEncoder()\r\n        const view = context.getCurrentTexture().createView()\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            //@ts-ignore\r\n            colorAttachments: [\r\n                {\r\n                    view: view,\r\n                    clearValue: { r: 0, g: 0, b: 0, a: 1.0 },\r\n                    loadOp: 'clear',\r\n                    storeOp: 'store'\r\n                }\r\n            ]\r\n        };\r\n\r\n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\r\n        passEncoder.setPipeline(pipelineObj.pipeline)\r\n\r\n\r\n        passEncoder.setBindGroup(0, pipelineObj.uniformGroup)\r\n\r\n        passEncoder.setVertexBuffer(0, pipelineObj.vertexBuffer)\r\n        passEncoder.draw(this.vertexCount)\r\n        passEncoder.end()\r\n        // webgpu run in a separate process, all the commands will be executed after submit\r\n        device.queue.submit([commandEncoder.finish()])\r\n    }\r\n    public destroy() {\r\n        this.device.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}"],"names":["getSlider","title","min","max","div","document","createElement","style","display","slider","type","text","textContent","color","appendChild","UI","constructor","solution","divHost","divColor","divRange","this","defaultValue","appendEvent","addEventListener","e","target","value","r","slice","g","b","device","queue","writeBuffer","pipelineObj","colorBuffer","Float32Array","run","vertex","vertexBuffer","window","canvas","width","clientWidth","height","clientHeight","Solution","id","ctx","format","size","ui","vertexCount","mouse","getElementById","offsetX","offsetY","initWebGPU","async","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","getPreferredCanvasFormat","getPreferredFormat","devicePixelRatio","configure","alphaMode","initPipeline","pipeline","createRenderPipelineAsync","label","layout","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","createBuffer","byteLength","usage","GPUBufferUsage","VERTEX","COPY_DST","UNIFORM","uniformGroup","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","draw","context","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","view","getCurrentTexture","createView","clearValue","a","loadOp","storeOp","passEncoder","beginRenderPass","setPipeline","setBindGroup","setVertexBuffer","end","submit","finish","destroy","lastElementChild","removeChild"],"sourceRoot":""}