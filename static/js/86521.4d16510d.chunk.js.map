{"version":3,"file":"static/js/86521.4d16510d.chunk.js","mappings":"6JAGO,MAAMA,UAAiBC,EAAAA,GAY1BC,cACIC,MADkB,uDAAG,QACZ,KAXbC,gBAAU,OAEVC,UAAY,IAAIC,EAAAA,IAAkB,KAClCC,MAAQ,IAAID,EAAAA,IAAgB,KAC5BE,EAAI,IAAIF,EAAAA,IAAgB,KAExBG,YAAM,OAENC,IAAoB,GAKhB,MAAMC,EAAe,IAAIL,EAAAA,IAAmB,SAC5CM,KAAKC,MAAMC,IAAIH,GAEfC,KAAKR,WAAa,IAAIE,EAAAA,IAAkB,SAAU,KAClDM,KAAKR,WAAWW,SAASC,EAAI,GAC7BJ,KAAKR,WAAWa,YAAa,EAC7BL,KAAKC,MAAMC,IAAIF,KAAKR,YAEpB,MAAMc,EAAO,IAAIZ,EAAAA,IAAiB,GAClCY,EAAKH,SAASI,EAAI,KAClBP,KAAKC,MAAMC,IAAII,GACfN,KAAKC,MAAMC,IAAI,IAAIR,EAAAA,IAAiB,GAAI,KAExCM,KAAKQ,WACLR,KAAKS,OACT,CACOD,WAEH,MAAME,EAAW,IAAIhB,EAAAA,IAAyB,CAAEiB,MAAO,MAAUC,SAAU,MAAUC,kBAAmB,IAClGC,EAAiB,IAAIpB,EAAAA,IAAqB,IAAM,GAAI,IACpDqB,EAAe,IAAIrB,EAAAA,IAAWoB,EAAgBJ,GACpDK,EAAaC,WAAW,GACxBhB,KAAKH,OAASkB,EACdf,KAAKC,MAAMC,IAAIa,GAGf,IAAIE,EAAW,IAAIvB,EAAAA,IAAqB,EAAG,GAAI,IAC3CwB,EAAS,IAAIxB,EAAAA,IAAWuB,EAAU,IAAIvB,EAAAA,KAC1CwB,EAAOF,YAAY,GACnBhB,KAAKE,IAAIgB,GAETD,EAAW,IAAIvB,EAAAA,IAAqB,EAAG,GAAI,IAC3CwB,EAAS,IAAIxB,EAAAA,IAAWuB,EAAU,IAAIvB,EAAAA,KACtCwB,EAAOF,WAAW,GAClBhB,KAAKE,IAAIgB,EACb,CACOhB,IAAIgB,GAAqC,IAAjBC,IAAO,yDAClCnB,KAAKC,MAAMC,IAAIgB,GACXC,GAAUnB,KAAKF,IAAIsB,KAAKF,EAChC,CACOG,UAAUC,GACbtB,KAAKmB,QAAQG,EAEjB,CACOH,QAAQG,GACXtB,KAAKL,MAAMS,EAAKkB,EAAEC,QAAUvB,KAAKwB,SAASC,WAAWC,YAAe,EAAI,EACxE1B,KAAKL,MAAMY,GAAMe,EAAEK,QAAU3B,KAAKwB,SAASC,WAAWG,aAAgB,EAAI,EAE1E5B,KAAKP,UAAUoC,cAAc7B,KAAKL,MAAOK,KAAK8B,QAG9C,MAAMC,EAAa/B,KAAKP,UAAUuC,iBAAiBhC,KAAKF,KAGxD,GAAIiC,EAAWE,OAAS,EASpB,OARAjC,KAAKJ,EAAEsC,IAAIH,EAAW,GAAGI,MAAM/B,EAAG2B,EAAW,GAAGI,MAAM5B,EAAGwB,EAAW,GAAGI,MAAMC,GAKzEL,EAAW,GAAGb,SAAWlB,KAAKH,QAC9BG,KAAKH,OAAOM,SAAS+B,IAAIH,EAAW,GAAGI,MAAM/B,EAAG2B,EAAW,GAAGI,MAAM5B,EAAGwB,EAAW,GAAGI,MAAMC,GAExFL,CAIf,CACOM,WAAWf,GACDtB,KAAKmB,QAAQG,EAI9B,CAEOgB,OAAOrC,GAEV,MAAMsC,EAAS,IAAI7C,EAAAA,IACnB6C,EAAOC,cAAwB,KAAVC,KAAKC,IAC1B1C,KAAKR,WAAWW,SAASwC,aAAaJ,EAE1C,E","sources":["njslab/LabStarter/Starter-Three/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree } from '../../../lib';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight\r\n\r\n    raycaster = new THREE.Raycaster();\r\n    mouse = new THREE.Vector2();\r\n    m = new THREE.Vector3();\r\n\r\n    sphere: THREE.Mesh;\r\n\r\n    obj: THREE.Mesh[] = []; \r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        const ambientLight = new THREE.AmbientLight(0x555555);\r\n        this.scene.add(ambientLight);\r\n\r\n        this.pointLight = new THREE.PointLight( 0xffffff, 100 );\r\n        this.pointLight.position.x = 10;\r\n        this.pointLight.castShadow = true;\r\n        this.scene.add(this.pointLight);\r\n\r\n        const axis = new THREE.AxesHelper(5);\r\n        axis.position.y = 0.001;\r\n        this.scene.add(axis);\r\n        this.scene.add(new THREE.GridHelper(10, 10));\r\n\r\n        this.initPost();\r\n        this.start();\r\n    }\r\n    public initPost() {\r\n        // @ts-ignore\r\n        const material = new THREE.MeshBasicMaterial( { color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1 } );\r\n        const geometrySphere = new THREE.SphereGeometry(0.05, 50, 50);\r\n        const objectSphere = new THREE.Mesh(geometrySphere, material);\r\n        objectSphere.translateX(1)\r\n        this.sphere = objectSphere\r\n        this.scene.add(objectSphere);\r\n\r\n\r\n        let geometry = new THREE.SphereGeometry(1, 50, 50);\r\n        let object = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial());\r\n        object.translateX(-1)\r\n        this.add(object);\r\n\r\n        geometry = new THREE.SphereGeometry(1, 50, 50);\r\n        object = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial());\r\n        object.translateX(1)\r\n        this.add(object);\r\n    }\r\n    public add(object: THREE.Mesh, picking = true) {\r\n        this.scene.add(object);\r\n        if (picking) {this.obj.push(object)}\r\n    }\r\n    public mouseMove(e: MouseEvent): void {\r\n        this.picking(e)\r\n\r\n    }\r\n    public picking(e: MouseEvent) {\r\n        this.mouse.x = (e.offsetX / this.renderer.domElement.clientWidth) * 2 - 1;\r\n        this.mouse.y = -(e.offsetY / this.renderer.domElement.clientHeight) * 2 + 1;\r\n\r\n        this.raycaster.setFromCamera(this.mouse, this.camera);\r\n\r\n        // Calculate objects intersecting the picking ray\r\n        const intersects = this.raycaster.intersectObjects(this.obj);\r\n\r\n\r\n        if (intersects.length > 0) {\r\n            this.m.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);\r\n            // console.log(intersects[0]); // This will give you the first object intersected\r\n\r\n            // console.log(this.m); \r\n\r\n            if (intersects[0].object !== this.sphere) {\r\n                this.sphere.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z)\r\n            }\r\n            return intersects;\r\n\r\n        }\r\n        return undefined;\r\n    }\r\n    public mouseClick(e: MouseEvent): void {\r\n        const mesh = this.picking(e)\r\n        if (mesh) {\r\n            // console.log({mesh})\r\n        }\r\n    }\r\n\r\n    public update(scene: THREE.Scene) {\r\n\r\n        const matrix = new THREE.Matrix4();\r\n        matrix.makeRotationY(Math.PI * 0.011);\r\n        this.pointLight.position.applyMatrix4(matrix);\r\n\r\n    }\r\n\r\n}\r\n"],"names":["Solution","RendererThree","constructor","super","pointLight","raycaster","THREE","mouse","m","sphere","obj","ambientLight","this","scene","add","position","x","castShadow","axis","y","initPost","start","material","color","emissive","emissiveIntensity","geometrySphere","objectSphere","translateX","geometry","object","picking","push","mouseMove","e","offsetX","renderer","domElement","clientWidth","offsetY","clientHeight","setFromCamera","camera","intersects","intersectObjects","length","set","point","z","mouseClick","update","matrix","makeRotationY","Math","PI","applyMatrix4"],"sourceRoot":""}