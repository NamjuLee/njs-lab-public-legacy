{"version":3,"file":"static/js/16429.194d2e45.chunk.js","mappings":"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","sources":["njslab/Infrastructure/WebGPU/WebGPU_04_rect_buffer_index/shaders/shaders.ts","njslab/Infrastructure/WebGPU/WebGPU_04_rect_buffer_index/index.ts"],"sourcesContent":["export const CreateGPUBufferUint = (device:GPUDevice, data:Uint32Array, \n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST) => {\n    const buffer = device.createBuffer({\n        size: data.byteLength,\n        usage: usageFlag,\n        mappedAtCreation: true\n    });\n    new Uint32Array(buffer.getMappedRange()).set(data);\n    buffer.unmap();\n    return buffer;\n}\n\nexport const CreateGPUBuffer = (device:GPUDevice, data:Float32Array, \n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\n    const buffer = device.createBuffer({\n        size: data.byteLength,\n        usage: usageFlag,\n        mappedAtCreation: true\n    });\n    new Float32Array(buffer.getMappedRange()).set(data);\n    buffer.unmap();\n    return buffer;\n}\n\nexport const Shaders = () => {\n    const vertex = `\n        struct Output {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) vColor : vec4<f32>,\n        };\n        @vertex\n        fn main(@location(0) pos: vec4<f32>, @location(1) color: vec4<f32>) -> Output {\n            var output: Output;\n            output.Position = pos;\n            output.vColor = color;\n            return output;\n        }`;\n\n    const fragment = `\n        @fragment\n        fn main(@location(0) vColor: vec4<f32>) -> @location(0) vec4<f32> {\n            return vColor;\n        }`;\n\n    return {\n        vertex, \n        fragment\n    };\n}\n\nexport const ShadersOld = () => {\n    const vertex = `\n        [[location(0)]] var<in> position : vec4<f32>;\n        [[location(1)]] var<in> color : vec4<f32>;\n        [[builtin(position)]] var<out> Position : vec4<f32>;\n        [[location(0)]] var<out> vColor : vec4<f32>;\n\n        [[stage(vertex)]]\n        fn main() -> void {\n            Position = position;\n            vColor = color;\n            return;\n        }`;\n\n    const fragment = `\n        [[location(0)]] var<in> vColor : vec4<f32>;\n        [[location(0)]] var<out> fragColor : vec4<f32>;\n\n        [[stage(fragment)]]\n        fn main() -> void {\n            fragColor = vColor;\n            return;\n        }`;\n\n    return {\n        vertex, \n        fragment\n    };\n}\n","// import positionVert from './shaders/position.vert.wgsl?raw';\r\n// import colorFrag from './shaders/color.frag.wgsl';\r\n\r\nimport { Shaders, CreateGPUBufferUint, CreateGPUBuffer } from './shaders/shaders';\r\nimport shader from './shaders/shader.wgsl';\r\n\r\nconst vertex = new Float32Array([\r\n    0.0, 0.5, 0.0,\r\n    -0.5, -0.5, 0.0,\r\n    0.5, -0.5, 0.0\r\n])\r\nconst vertexCount = 3\r\n\r\nexport { vertex, vertexCount }\r\n\r\nconst positionVert = `\r\n@vertex\r\nfn main(@location(0) position : vec3<f32>) -> @builtin(position) vec4<f32> {\r\n    return vec4<f32>(position, 1.0);\r\n}\r\n`\r\nconst colorFrag = `\r\n@group(0) @binding(0) var<uniform> color : vec4<f32>;\r\n\r\n@fragment\r\nfn main() -> @location(0) vec4<f32> {\r\n    return color;\r\n}\r\n`\r\n\r\nexport class Solution {\r\n    divHost: HTMLElement;\r\n    canvas: HTMLCanvasElement;\r\n    ctx: GPUCanvasContext;\r\n    device: GPUDevice;\r\n    format: GPUTextureFormat;\r\n    size: any;\r\n    pipelineObj: any;\r\n    constructor(id: string) {\r\n        this.divHost = document.getElementById(id);\r\n\r\n        //     console.log(id, 'webGPU', navigator.gpu);\r\n        this.canvas = document.createElement('canvas');\r\n        this.divHost.appendChild(this.canvas);\r\n        \r\n        this.initWebGPU();\r\n    }\r\n    async initWebGPU() {\r\n        if (!navigator.gpu) { throw new Error('Not Support WebGPU'); }\r\n\r\n        \r\n\r\n        const adapter = await navigator.gpu.requestAdapter({\r\n            powerPreference: 'high-performance'\r\n            // powerPreference: 'low-power'\r\n        })\r\n\r\n        if (!adapter) { throw new Error('No Adapter Found'); }\r\n\r\n        const device = await adapter.requestDevice()\r\n        this.ctx = this.canvas.getContext('webgpu') as GPUCanvasContext\r\n        // @ts-ignore\r\n        const format = navigator.gpu.getPreferredCanvasFormat ? navigator.gpu.getPreferredCanvasFormat() : this.ctx.getPreferredFormat(adapter)\r\n        const devicePixelRatio = window.devicePixelRatio || 1\r\n        this.canvas.width = this.divHost.clientWidth;\r\n        this.canvas.height = this.divHost.clientHeight;\r\n        this.ctx.configure({\r\n            // json specific format when key and value are the same\r\n            device, format,\r\n            // prevent chrome warning\r\n            alphaMode: 'opaque'\r\n        })\r\n\r\n        this.size = { width: this.canvas.width, height: this.canvas.height }\r\n        this.device = device;\r\n        this.format = format;\r\n\r\n        this.initPipeline(this.device, this.format);\r\n    }\r\n    async initPipeline(device: GPUDevice, format: GPUTextureFormat, primitiveType = 'triangle-list') { // triangle-list , triangle-strip\r\n        const vertexData = new Float32Array([\r\n            //position    //color\r\n            -0.5, -0.5, 0, 1, 0, 0,  // vertex a, index = 0\r\n            0.5, -0.5, 0,  0, 1, 0,  // vertex b, index = 1\r\n            0.5, 0.5, 0, 0, 0, 1,  // vertex c, index = 2  \r\n            -0.5, 0.5, 0, 1, 1, 0   // vertex d, index = 3        \r\n        ]);\r\n\r\n        const indexData = new Uint32Array([0, 1, 3, 3, 1, 2]);\r\n\r\n        const vertexBuffer = CreateGPUBuffer(this.device, vertexData);\r\n        const indexBuffer = CreateGPUBufferUint(this.device, indexData);\r\n        const shader = Shaders();\r\n\r\n        const pipeline = this.device.createRenderPipeline({\r\n            layout: 'auto',\r\n            vertex: {\r\n                module: this.device.createShaderModule({\r\n                    code: shader.vertex\r\n                }),\r\n                entryPoint: \"main\",\r\n                //@ts-ignore\r\n                buffers: [\r\n                    {\r\n                        arrayStride: 4 * (3 + 3),\r\n                        attributes: [{\r\n                            shaderLocation: 0,\r\n                            format: \"float32x3\",\r\n                            offset: 0\r\n                        },\r\n                        {\r\n                            shaderLocation: 1,\r\n                            format: 'float32x3',\r\n                            offset: 4 * 3,\r\n                        }\r\n                        ]\r\n                    }\r\n                ]\r\n            },\r\n            fragment: {\r\n                module: this.device.createShaderModule({\r\n                    code: shader.fragment\r\n                }),\r\n                entryPoint: \"main\",\r\n                targets: [\r\n                    {\r\n                        format: this.format as GPUTextureFormat\r\n                    }\r\n                ]\r\n            },\r\n            primitive: {\r\n                topology: \"triangle-list\",\r\n            }\r\n        });\r\n        const commandEncoder = device.createCommandEncoder();\r\n        const textureView = this.ctx.getCurrentTexture().createView();\r\n        const renderPass = commandEncoder.beginRenderPass({\r\n            //@ts-ignore\r\n            colorAttachments: [{\r\n                view: textureView as GPUTextureView,\r\n                clearValue: [0.0, 0.0, 0.0, 1], //background color\r\n                loadOp: 'clear',\r\n                storeOp: 'store'\r\n            }]\r\n        });\r\n\r\n        renderPass.setPipeline(pipeline);\r\n        renderPass.setVertexBuffer(0, vertexBuffer);\r\n        renderPass.setIndexBuffer(indexBuffer, \"uint32\");\r\n\r\n        renderPass.drawIndexed(6);\r\n        renderPass.end();\r\n\r\n        device.queue.submit([commandEncoder.finish()]);\r\n\r\n    }\r\n    public destroy() {\r\n        this.device.destroy();\r\n        while (this.divHost.lastElementChild) {\r\n            this.divHost.removeChild(this.divHost.lastElementChild);\r\n        }\r\n    }\r\n}"],"names":["vertex","Float32Array","vertexCount","Solution","constructor","id","divHost","canvas","ctx","device","format","size","pipelineObj","this","document","getElementById","createElement","appendChild","initWebGPU","async","navigator","gpu","Error","adapter","requestAdapter","powerPreference","requestDevice","getContext","getPreferredCanvasFormat","getPreferredFormat","window","devicePixelRatio","width","clientWidth","height","clientHeight","configure","alphaMode","initPipeline","vertexData","indexData","Uint32Array","vertexBuffer","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap","CreateGPUBuffer","indexBuffer","INDEX","CreateGPUBufferUint","shader","fragment","pipeline","createRenderPipeline","layout","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","targets","primitive","topology","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","loadOp","storeOp","setPipeline","setVertexBuffer","setIndexBuffer","drawIndexed","end","queue","submit","finish","destroy","lastElementChild","removeChild"],"sourceRoot":""}