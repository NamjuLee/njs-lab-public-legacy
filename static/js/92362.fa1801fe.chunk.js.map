{"version":3,"file":"static/js/92362.fa1801fe.chunk.js","mappings":"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","sources":["njslab/Lab/Globe/index.ts"],"sourcesContent":["import * as THREE from 'three';\r\nimport { RendererThree, Vector3 } from '../../../lib';\r\n\r\nimport { NJSCORE } from '../../../lib';\r\n\r\nexport class Solution extends RendererThree {\r\n\r\n    pointLight: THREE.PointLight\r\n\r\n    constructor(id: string = 'main') {\r\n        super(id)\r\n\r\n        this.camera.position.set(0, 50, 50);\r\n\r\n        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.25);\r\n        this.scene.add(ambientLight);\r\n\r\n        this.pointLight = new THREE.PointLight(0xffffff, 0.75);\r\n        this.pointLight.position.x = 10;\r\n        this.pointLight.castShadow = true;\r\n        this.scene.add(this.pointLight);\r\n\r\n\r\n\r\n        // const geometry = new THREE.SphereGeometry(1, 50, 50);\r\n        // const object = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial());\r\n        // this.scene.add(object);\r\n\r\n        const vec = getVec();\r\n        console.log(vec);\r\n        const [positions, colors, sizes] = initNode(vec);\r\n\r\n        const attributePositions = new THREE.BufferAttribute(new Float32Array(positions), 3);\r\n        const attributeColors = new THREE.BufferAttribute(new Float32Array(colors), 4);\r\n        const attributeSize = new THREE.BufferAttribute(new Float32Array(sizes), 1);\r\n\r\n\r\n\r\n        //\r\n\r\n\r\n\r\n        const globe = new THREE.Group();\r\n\r\n        const geometryddd = new THREE.BufferGeometry();\r\n        geometryddd.setAttribute('position', attributePositions);\r\n        geometryddd.setAttribute('customColor', attributeColors);\r\n        geometryddd.setAttribute('size', attributeSize);\r\n\r\n        let file = 'dotTexture.png';\r\n        // console.log(img);\r\n        let path = `njslabSandboxStatic/img/${file}`;\r\n        // let path = `${location.origin}/njslabSandboxStatic/img/${file}`;\r\n\r\n        path = 'https://raw.githubusercontent.com/NamjuLee/data/master/img/brush/dotTexture.png';\r\n\r\n        // const loader = new THREE.TextureLoader();\r\n\r\n        // loader.load(path, (tex) => {\r\n\r\n\r\n        const texture = new THREE.TextureLoader().load(path);\r\n\r\n        console.log(path); // PointsMaterial ShaderMaterial\r\n        let material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                color: { value: new THREE.Color(0xffffff) },\r\n                texture: { value: texture }\r\n            },\r\n            vertexShader: shaderVert,\r\n            fragmentShader: shaderFrag,\r\n            alphaTest: 0.9\r\n        });\r\n        material.transparent = true;\r\n\r\n        // let geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);\r\n        // let box = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));\r\n        // AppWallPaperGL.app.canvasThree.scene.add(box);\r\n        // this.box = box;\r\n\r\n        // var wrap = new THREE.Points(geo, material);\r\n        // this.mesh = wrap;\r\n        // AppWallPaperGL.app.canvasThree.scene.add(wrap);\r\n\r\n        // let blendings = ['NoBlending', 'NormalBlending', 'AdditiveBlending', 'SubtractiveBlending', 'MultiplyBlending'];\r\n        // material.blending = THREE[blendings[2]];\r\n        // console.log(path);\r\n        // let material = new THREE.PointsMaterial({ color: 0x888888 }); // new THREE.ShaderMaterial();\r\n\r\n        const mesh = new THREE.Mesh(geometryddd, material);\r\n        this.scene.add(mesh);\r\n        // this.globe.add(this.mesh);\r\n        // AppWallPaperGL.app.canvasThree.scene.add(this.mesh);\r\n\r\n        // // Create white segments\r\n        // this.lineSegGeo = new THREE.Geometry();\r\n        // const segmentsMat = new THREE.LineBasicMaterial({\r\n        //     color: 0xffffff,\r\n        //     transparent: true,\r\n        //     opacity: 0.3,\r\n        //     vertexColors: THREE.VertexColors\r\n        // });\r\n        // // segmentsMat.blending = THREE[blendings[4]];\r\n        // const lns = [];\r\n        // this.edges = [];\r\n        // let theIndex = 0;\r\n        // for (let i = 0; i < this.nodes.length - 1; ++i) {\r\n        //     for (let j = i; j < this.nodes.length; ++j) {\r\n        //         if (this.vecs[i].distanceTo(this.vecs[j]) < 0.15) {\r\n        //             lns.push(this.vecs[i], this.vecs[j]);\r\n        //             this.lineSegGeo.vertices.push(this.vecs[i]);\r\n        //             this.lineSegGeo.vertices.push(this.vecs[j]);\r\n\r\n        //             // const c0 = ColorUtility.GetRandomColorByLightness(this.DOT_COLOR, 0.7 + (Math.random() - 0.5) * 0.7);\r\n        //             // const c1 = ColorUtility.GetRandomColorByLightness(this.DOT_COLOR, 0.4 + (Math.random() - 0.5) * 0.3);\r\n\r\n        //             const c0 = this.nodes[i].col;\r\n        //             const c1 = this.nodes[j].col;\r\n        //             this.lineSegGeo.colors.push(new THREE.Color(c0[0] / 255, c0[1] / 255, c0[2] / 255));\r\n        //             this.lineSegGeo.colors.push(new THREE.Color(c1[0] / 255, c1[1] / 255, c1[2] / 255));\r\n\r\n        //             this.edges.push(new Edge(this, theIndex, this.nodes[i], this.nodes[j], 0.01));\r\n        //             theIndex++;\r\n        //         }\r\n        //     }\r\n        // }\r\n        // this.lineSegments = new THREE.LineSegments(this.lineSegGeo, segmentsMat);\r\n        // this.globe.add(this.lineSegments);\r\n        // // this.mesh = this.globe;\r\n        // // AppWallPaperGL.app.canvasThree.scene.add(this.globe);\r\n        // this.geometryCoreWrapper.threeCore.scene.add(this.lineSegments);\r\n\r\n        //\r\n        this.start();\r\n        // });\r\n    }\r\n\r\n    public update(scene: THREE.Scene) {\r\n\r\n        var matrix = new THREE.Matrix4();\r\n        matrix.makeRotationY(Math.PI * 0.011);\r\n        this.pointLight.position.applyMatrix4(matrix);\r\n\r\n    }\r\n\r\n}\r\n\r\nconst getVec = () => {\r\n\r\n    const nVecs = NJSCORE.NVectorUtility.GetSpherecVecs3dRandomWithThicknessOffset(500, 15, 0.15);\r\n    const vecs = [];\r\n    for (let i = 0; i < nVecs.length; ++i) {\r\n        vecs.push(new THREE.Vector3(nVecs[i].x, nVecs[i].y, nVecs[i].z));\r\n    }\r\n    return vecs;\r\n}\r\nconst initNode = (vecs: THREE.Vector3[]) => {\r\n    let DOT_COLOR = NJSCORE.ColorUtility.GetRandomHex(); //  '#7116b7';\r\n    let positions = []; let colors = []; let sizes = []; let nodes = [];\r\n    for (let i = 0; i < vecs.length; ++i) {\r\n        positions.push(vecs[i].x, vecs[i].y, vecs[i].z);\r\n        let col = NJSCORE.ColorUtility.GetRandomColorByLightness(DOT_COLOR, 0.2 + Math.random() * 0.7);\r\n        colors.push(col[0] / 255, col[1] / 255, col[2] / 255, Math.random());\r\n        console.log(col[0] / 255, col[1] / 255, col[2] / 255, Math.random())\r\n        let size = i * 0.0001; // PARTICLE_SIZE + (Math.random() - 0.5) * 0.15;\r\n        // let size = i + PARTICLE_SIZE + (Math.random() - 0.5) * 0.15;\r\n        sizes.push(size);\r\n        const dot = new Node(i, vecs[i], col, size);\r\n        nodes.push(dot);\r\n    }\r\n    return [positions, colors, sizes];\r\n}\r\nconst shaderVert = `\r\n    attribute float size;\r\n    attribute vec4 customColor;\r\n    varying vec4 vColor;\r\n\r\n    void main() {\r\n        // vColor = vec4(vColor.xyz, distance(vec3(customColor.xyz), position));\r\n        vColor = customColor;\r\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n        gl_PointSize = size * ( 30.0 / -mvPosition.z );\r\n        gl_Position = projectionMatrix * mvPosition;\r\n    }\r\n    `;\r\n\r\nconst shaderFrag = `\r\n    uniform vec3 color;\r\n    uniform sampler2D texture;\r\n    varying vec4 vColor;\r\n\r\n\tvoid main() {\r\n        gl_FragColor = vColor; // vec4(color * vColor, 1.0);\r\n        // gl_FragColor = gl_FragColor * texture2D(texture, gl_PointCoord);\r\n        // if (gl_FragColor.a < 0.5) discard;\r\n    }\r\n    `;\r\n\r\nexport class Node {\r\n    // parent: GlobeNetworkAThree;\r\n    v: THREE.Vector3;\r\n    col: number[];\r\n    theta: number;\r\n    phi: number;\r\n    size: number;\r\n    id: number;\r\n    edges: Edge[];\r\n    seedRandom: number;\r\n    t: number;\r\n    tForR: number;\r\n\r\n    needUpdate: boolean;\r\n\r\n    constructor(i: number, v: THREE.Vector3, c: number[], s: number) {\r\n        // this.parent = parent;\r\n        this.t = 0.0;\r\n        this.v = v;\r\n        this.id = i;\r\n        this.col = c;\r\n        this.size = s;\r\n        this.tForR = 0.0;\r\n\r\n        this.seedRandom = Math.random();\r\n    }\r\n    Translate(x: number, y: number, z: number) {\r\n        // this.v.setX(this.parent.attributePositions.getX(this.id));\r\n        // this.v.setY(this.parent.attributePositions.getY(this.id));\r\n        // this.v.setZ(this.parent.attributePositions.getZ(this.id));\r\n        // this.parent.attributePositions.setXYZ(this.id, this.v.x + x, this.v.y + y, this.v.z + z);\r\n    }\r\n    Scale(s: number) {\r\n        // this.size = this.parent.attributeSize.getX(this.id);\r\n        // this.parent.attributeSize.setX(this.id, this.size + s);\r\n    }\r\n    ScalebyValue(s: number) {\r\n        // this.size = this.parent.attributeSize.getX(this.id);\r\n        // this.parent.attributeSize.setX(this.id, s);\r\n    }\r\n    SetScale(s: number) {\r\n        // // this.size = this.parent.attributeSize.getX(this.id);\r\n        // this.parent.attributeSize.setX(this.id, s);\r\n        // this.needUpdate = true;\r\n        // this.tForR = 0.0;\r\n        // this.t = 0.0;\r\n    }\r\n    Update(t: number) {\r\n        // if (!this.needUpdate) { return; }\r\n        // this.t += 0.019;\r\n        // this.ScalebyValue(NumericalMotion.easeOutElastic2(this.tForR) * this.seedRandom);\r\n        // this.tForR += 0.01;\r\n\r\n        // if (this.t > 1) {\r\n        //     this.needUpdate = false;\r\n        //     this.SetScale(0.1);\r\n        // }\r\n    }\r\n}\r\nexport class Edge {\r\n\r\n    // parent: GlobeNetworkAThree;\r\n    n0: Node;\r\n    n1: Node;\r\n    size: number;\r\n    id: number;\r\n    seedRandom: number;\r\n\r\n    constructor(i: number, n0: Node, n1: Node, s: number) {\r\n        // this.parent = parent;\r\n        this.id = i;\r\n        this.n0 = n0;\r\n        this.n1 = n1;\r\n        this.size = s;\r\n        this.seedRandom = Math.random();\r\n    }\r\n    Update(t: number) {\r\n        //\r\n    }\r\n}"],"names":["Solution","RendererThree","constructor","super","pointLight","this","camera","position","set","ambientLight","THREE","scene","add","x","castShadow","vec","getVec","console","log","positions","colors","sizes","initNode","attributePositions","Float32Array","attributeColors","attributeSize","geometryddd","setAttribute","path","texture","load","material","uniforms","color","value","vertexShader","shaderVert","fragmentShader","shaderFrag","alphaTest","transparent","mesh","start","update","matrix","makeRotationY","Math","PI","applyMatrix4","nVecs","NJSCORE","vecs","i","length","push","y","z","DOT_COLOR","nodes","col","random","size","dot","Node","v","c","s","theta","phi","id","edges","seedRandom","t","tForR","needUpdate","Translate","Scale","ScalebyValue","SetScale","Update","Edge","n0","n1"],"sourceRoot":""}