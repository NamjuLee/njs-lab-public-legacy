{"version":3,"file":"static/js/42556.11e1e7d7.chunk.js","mappings":"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","sources":["njslab/LabStarter/AppNGL3d/NGL3dApp_08/WebGL/Shader.ts","njslab/LabStarter/AppNGL3d/NGL3dApp_08/WebGL/VAO.ts"],"sourcesContent":["//  import { GLShaderCommon } from '../Utility/GLShaderCommon';\r\nimport { Model } from './Model';\r\n\r\nexport enum ATTR {\r\n    ATTR_POSITION_NAME = 'a_position',\r\n    ATTR_POSITION_LOC = 0,\r\n\r\n    ATTR_NORMAL_NAME = 'a_norm',\r\n    ATTR_NORMAL_LOC = 1,\r\n\r\n    ATTR_UV_NAME = 'a_uv',\r\n    ATTR_UV_LOC = 2,\r\n\r\n    ATTR_COLOR_NAME = 'a_color',\r\n    ATTR_COLOR_LOC = 4,\r\n}\r\n\r\nexport class AttribLocations {\r\n\r\n    position: number;\r\n    norm: number;\r\n    uv: number;\r\n\r\n    constructor(gl: WebGL2RenderingContext, program: WebGLProgram) {\r\n        this.position = gl.getAttribLocation(program, ATTR.ATTR_POSITION_NAME);\r\n        this.norm = gl.getAttribLocation(program, ATTR.ATTR_NORMAL_NAME);\r\n        this.uv = gl.getAttribLocation(program, ATTR.ATTR_UV_NAME);\r\n    }\r\n}\r\n\r\nexport class UniformLocations {\r\n\r\n    perspective: WebGLUniformLocation | null;\r\n    modelMatrix: WebGLUniformLocation | null;\r\n    cameraMatrix: WebGLUniformLocation | null;\r\n    mainTexture: WebGLUniformLocation | null;\r\n\r\n    constructor(gl: WebGL2RenderingContext, program: WebGLProgram) {\r\n        this.perspective = gl.getUniformLocation(program, 'uPMatrix');\r\n        this.modelMatrix = gl.getUniformLocation(program, 'uMVMatrix');\r\n        this.cameraMatrix = gl.getUniformLocation(program, 'uCameraMatrix');\r\n        this.mainTexture = gl.getUniformLocation(program, 'uMainTex');\r\n    }\r\n}\r\n\r\nexport class Shader {\r\n\r\n    gl: WebGL2RenderingContext;\r\n    program: WebGLProgram | null;\r\n\r\n    attribLoc: AttribLocations;\r\n    uniformLoc: UniformLocations;\r\n\r\n    vShader: WebGLShader | null;\r\n    fShader: WebGLShader | null;\r\n\r\n    constructor(gl: WebGL2RenderingContext, vertShaderSrc: string, fragShaderSrc: string, needValidate: boolean = true) {\r\n        this.gl = gl;\r\n        this.vShader = ShaderUtility.CreateShader(gl, gl.VERTEX_SHADER as unknown as WebGLShader, vertShaderSrc);\r\n        this.fShader = ShaderUtility.CreateShader(gl, gl.FRAGMENT_SHADER as unknown as WebGLShader, fragShaderSrc);\r\n\r\n        if (this.vShader && this.fShader) {\r\n            let program = ShaderUtility.CreateProgram(gl, this.vShader, this.fShader, needValidate);\r\n\r\n            if (program) {\r\n                this.program = program;\r\n                gl.useProgram(this.program);\r\n                this.attribLoc = new AttribLocations(gl, this.program);\r\n                this.uniformLoc = new UniformLocations(gl, this.program);\r\n                return;\r\n\r\n            } else {\r\n                console.error('vertex fragment shader error'); return;\r\n            }\r\n        } else {\r\n            console.error('vertex fragment shader error'); return;\r\n        }\r\n        // Note :: Extended shaders should deactivate shader when done calling super and setting up custom parts in the constructor.\r\n    }\r\n\r\n    // ...................................................\r\n    // Methods\r\n    activate() {\r\n        this.gl.useProgram(this.program); return this;\r\n    }\r\n    deactivate() {\r\n        this.gl.useProgram(null); return this;\r\n    }\r\n\r\n    // function helps clean up resources when shader is no longer needed.\r\n    dispose() {\r\n        // unbind the program if its currently active\r\n        if (this.gl.getParameter(this.gl.CURRENT_PROGRAM) === this.program) { this.gl.useProgram(null); }\r\n        this.gl.deleteProgram(this.program);\r\n    }\r\n    setPerspective(matData: Float32Array) {\r\n        this.gl.uniformMatrix4fv(this.uniformLoc.perspective, false, matData);\r\n        return this;\r\n    }\r\n    setModelMatrix(matData: Float32Array) {\r\n        this.gl.uniformMatrix4fv(this.uniformLoc.modelMatrix, false, matData);\r\n        return this;\r\n    }\r\n    setCameraMatrix(matData: Float32Array) {\r\n        this.gl.uniformMatrix4fv(this.uniformLoc.cameraMatrix, false, matData);\r\n        return this;\r\n    }\r\n    // ...................................................\r\n    // RENDER RELATED METHODS\r\n\r\n    // Setup custom properties\r\n    preRender() {\r\n        //\r\n    }\r\n    // Handle rendering a model\r\n    renderModel(model: Model) {\r\n        this.setModelMatrix(model.transform.getViewMatrix());\t// Set the transform, so the shader knows where the model exists in 3d space\r\n        this.gl.bindVertexArray(model.vao.vao);\t// Enable VAO, this will set all the predefined attributes for the shader\r\n\r\n        if (model.vao.noCulling) { this.gl.disable(this.gl.CULL_FACE); }\r\n        if (model.vao.doBlending) { this.gl.enable(this.gl.BLEND); }\r\n\r\n        if (model.vao.indexCount) {\r\n            // console.log(model.vao.indexCount);\r\n            this.gl.drawElements(model.vao.drawMode, model.vao.indexCount, this.gl.UNSIGNED_SHORT, 0);\r\n        } else {\r\n            this.gl.drawArrays(model.vao.drawMode, 0, model.vao.vertexCount);\r\n        }\r\n\r\n        this.gl.bindVertexArray(null);\r\n        if (model.vao.noCulling) { this.gl.enable(this.gl.CULL_FACE); }\r\n        if (model.vao.doBlending) { this.gl.disable(this.gl.BLEND); }\r\n\r\n        return this;\r\n\r\n    }\r\n}\r\n\r\nexport class ShaderUtility {\r\n    static CreateProgram(gl: WebGL2RenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader, needValidate: boolean = true): WebGLProgram | null {\r\n        const program = gl.createProgram();\r\n        if (program === null) { return null; }\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n\r\n        gl.bindAttribLocation(program, ATTR.ATTR_POSITION_LOC, ATTR.ATTR_POSITION_NAME);\r\n        gl.bindAttribLocation(program, ATTR.ATTR_NORMAL_LOC, ATTR.ATTR_NORMAL_NAME);\r\n        gl.bindAttribLocation(program, ATTR.ATTR_UV_LOC, ATTR.ATTR_UV_NAME);\r\n\r\n        gl.linkProgram(program);\r\n\r\n        // Check that shader program was able to link to WebGL\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n            const error = gl.getProgramInfoLog(program);\r\n            console.log('Failed to link program: ' + error);\r\n            gl.deleteProgram(program);\r\n            gl.deleteShader(fragmentShader);\r\n            gl.deleteShader(vertexShader);\r\n            return null;\r\n        }\r\n        if (needValidate) {\r\n            gl.validateProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\r\n                console.error('Failed to validate program', gl.getProgramInfoLog(program));\r\n                gl.deleteProgram(program);\r\n                gl.deleteShader(fragmentShader);\r\n                gl.deleteShader(vertexShader);\r\n                return null;\r\n            }\r\n        }\r\n        gl.deleteShader(fragmentShader);\r\n        gl.deleteShader(vertexShader);\r\n        return program;\r\n    }\r\n    static CreateShader(gl: WebGL2RenderingContext, type: WebGLShader, shaderString: string) {\r\n        // console.log(type);\r\n        const shader = gl.createShader(type as unknown as number);\r\n        if (shader === null) { return null; }\r\n        gl.shaderSource(shader, shaderString);\r\n        gl.compileShader(shader);\r\n        const suc = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (suc) { return shader; }\r\n        console.log(gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n    }\r\n    static LoadTexture(gl: WebGL2RenderingContext, img: HTMLImageElement, doYFlip: boolean) {\r\n        let tex = gl.createTexture();\r\n        if (doYFlip === true) { gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); } // true); }\t// Flip the texture by the Y Position, So 0,0 is bottom left corner.\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Set text buffer for work\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\t\t\t// Push image to GPU.\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\t\t\t\t\t// Setup up scaling\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\t// Setup down scaling\r\n        gl.generateMipmap(gl.TEXTURE_2D);\t// Precalc different sizes of texture for better quality rendering.\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, null); // Unbind\r\n\r\n        // gl.mTextureCache[name] = tex;\t\t\t\t\t\t\t\t\t\t\t// Save ID for later unloading\r\n\r\n        if (doYFlip === true) { gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); }\t// Stop flipping textures\r\n        return tex;\r\n    }\r\n}","import { ATTR } from './Shader';\r\n\r\nexport enum DRAW_MODE {\r\n    //\r\n}\r\n\r\nexport class VAO {\r\n    name: string;\r\n\r\n    noCulling: boolean = true;\r\n    doBlending: boolean = true;\r\n\r\n    vao: WebGLVertexArrayObject | null;\r\n    bufVertices: WebGLBuffer | null;\r\n    bufNormals: WebGLBuffer | null;\r\n    bufUV: WebGLBuffer | null;\r\n    bufIndex: WebGLBuffer | null;\r\n\r\n    vertexComponentLen: number;\r\n    vertexCount: number;\r\n    indexCount: number;\r\n    drawMode: number;\r\n\r\n    constructor(gl: WebGL2RenderingContext, name: string, aryVert: number[], aryInd?: number[] | null, aryNorm?: number[] | null, aryUV?: number[] | null) {\r\n        this.name = name;\r\n        this.drawMode = gl.TRIANGLES;\r\n\r\n        this.vao = gl.createVertexArray();\r\n        gl.bindVertexArray(this.vao);\t//  Bind it so all the calls to vertexAttribPointer/enableVertexAttribArray is saved to the vao.\r\n\r\n        // .......................................................\r\n        // Set up vertices\r\n        if (aryVert !== undefined && aryVert != null) {\r\n            this.bufVertices = gl.createBuffer();\t\t\t\t\t\t\t\t\t\t\t\t\t// Create buffer...\r\n            this.vertexComponentLen = 3;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// How many floats make up a vertex\r\n            this.vertexCount = aryVert.length / this.vertexComponentLen;\t\t\t\t\t\t\t\t// How many vertices in the array\r\n\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.bufVertices);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(aryVert), gl.STATIC_DRAW);\t\t// then push array into it.\r\n            gl.enableVertexAttribArray(ATTR.ATTR_POSITION_LOC);\t\t\t\t\t\t\t\t\t\t// Enable Attribute location\r\n            gl.vertexAttribPointer(ATTR.ATTR_POSITION_LOC, 3, gl.FLOAT, false, 0, 0);\t\t\t\t\t\t// Put buffer at location of the vao\r\n        }\r\n\r\n        // .......................................................\r\n        // Setup normals\r\n        if (aryNorm !== undefined && aryNorm !== null) {\r\n            this.bufNormals = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.bufNormals);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(aryNorm), gl.STATIC_DRAW);\r\n            gl.enableVertexAttribArray(ATTR.ATTR_NORMAL_LOC);\r\n            gl.vertexAttribPointer(ATTR.ATTR_NORMAL_LOC, 3, gl.FLOAT, false, 0, 0);\r\n        }\r\n\r\n        // .......................................................\r\n        // Setup UV\r\n        if (aryUV !== undefined && aryUV !== null) {\r\n            // console.log(aryUV);\r\n            this.bufUV = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.bufUV);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(aryUV), gl.STATIC_DRAW);\r\n            // console.log(this);\r\n            gl.enableVertexAttribArray(ATTR.ATTR_UV_LOC);\r\n            gl.vertexAttribPointer(ATTR.ATTR_UV_LOC, 2, gl.FLOAT, false, 0, 0);\t// UV only has two floats per component\r\n        }\r\n\r\n        // .......................................................\r\n        // Setup Index.\r\n        if (aryInd !== undefined && aryInd !== null) {\r\n            this.bufIndex = gl.createBuffer();\r\n            this.indexCount = aryInd.length;\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufIndex);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(aryInd), gl.STATIC_DRAW);\r\n            // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n\r\n        }\r\n        // console.log(this);\r\n\r\n        // Clean up\r\n        gl.bindVertexArray(null);\t\t\t\t\t// Unbind the VAO, very Important. always unbind when your done using one.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\t// Unbind any buffers that might be set\r\n\r\n        // this.mMeshCache[name] = rtn;\r\n    }\r\n\r\n}"],"names":["ATTR","AttribLocations","constructor","gl","program","position","norm","uv","this","getAttribLocation","ATTR_POSITION_NAME","ATTR_NORMAL_NAME","ATTR_UV_NAME","UniformLocations","perspective","modelMatrix","cameraMatrix","mainTexture","getUniformLocation","Shader","vertShaderSrc","fragShaderSrc","needValidate","attribLoc","uniformLoc","vShader","fShader","ShaderUtility","CreateShader","VERTEX_SHADER","FRAGMENT_SHADER","CreateProgram","useProgram","console","error","activate","deactivate","dispose","getParameter","CURRENT_PROGRAM","deleteProgram","setPerspective","matData","uniformMatrix4fv","setModelMatrix","setCameraMatrix","preRender","renderModel","model","transform","getViewMatrix","bindVertexArray","vao","noCulling","disable","CULL_FACE","doBlending","enable","BLEND","indexCount","drawElements","drawMode","UNSIGNED_SHORT","drawArrays","vertexCount","static","vertexShader","fragmentShader","createProgram","attachShader","bindAttribLocation","ATTR_POSITION_LOC","ATTR_NORMAL_LOC","ATTR_UV_LOC","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","log","deleteShader","validateProgram","VALIDATE_STATUS","type","shaderString","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","img","doYFlip","tex","createTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","LINEAR_MIPMAP_NEAREST","generateMipmap","DRAW_MODE","VAO","name","aryVert","aryInd","aryNorm","aryUV","bufVertices","bufNormals","bufUV","bufIndex","vertexComponentLen","TRIANGLES","createVertexArray","undefined","createBuffer","length","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","ELEMENT_ARRAY_BUFFER","Uint16Array"],"sourceRoot":""}