{"version":3,"file":"static/js/49311.750627bb.chunk.js","mappings":"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","sources":["njslab/Tools/Graph/index.ts"],"sourcesContent":["export class Solution {\r\n    constructor(id: string) {\r\n\r\n        // console.log(\"Let's learn Typescript for digital mapping and visualization!!\");\r\n        // console.log(\"Typescript, Graph data Structure\");\r\n        // console.log(\"=================================\");\r\n        // Codepan\r\n        // Typescript: https://codepen.io/NJStudio/details/RwWxGXo\r\n        // Javascript: https://codepen.io/NJStudio/details/bGdozYY\r\n\r\n        //           N0\r\n        //          /  \\\r\n        //        N1    N2\r\n        //        /\\    /\\\r\n        //      N3 N4  N5 N6\r\n\r\n        let nodes: Node[] = [];\r\n\r\n        for (let i = 0; i < 7; ++i) {\r\n            nodes.push(new Node(i))\r\n        }\r\n\r\n        nodes[0].push(nodes[1]);\r\n        nodes[0].push(nodes[2]);\r\n\r\n        nodes[1].push(nodes[3]);\r\n        nodes[1].push(nodes[4]);\r\n\r\n        nodes[2].push(nodes[5]);\r\n        nodes[2].push(nodes[6]);\r\n\r\n        // nodes[3].push(nodes[6]);\r\n\r\n        // ........................................... BFS\r\n        let num = 0;\r\n        let outSortedBFS = []\r\n        const bfs = (nodes: Node[]) => {\r\n            let queue: Node[] = [];\r\n            nodes[0].visit = true;\r\n\r\n            queue.push(nodes[0])\r\n            outSortedBFS.push(nodes[0])\r\n\r\n            while (queue.length > 0) {\r\n                let current = queue.shift();\r\n\r\n                for (let i = 0; i < current.connection.length; ++i) {\r\n                    let other = current.connection[i];\r\n                    if (!other.visit) {\r\n                        other.visit = true;\r\n                        outSortedBFS.push(other);\r\n                        queue.push(other);\r\n                    }\r\n                }\r\n                if (num++ > 100) {\r\n                    // console.log('safeguard'); \r\n                    return;\r\n                }\r\n            }\r\n            return outSortedBFS;\r\n        }\r\n        bfs(nodes);\r\n        // console.log(\"BFS!\", outSortedBFS)\r\n        // console.log('done');\r\n\r\n        // ........................................... DFS\r\n\r\n        nodes = [];\r\n        for (let i = 0; i < 7; ++i) {\r\n            nodes.push(new Node(i))\r\n        }\r\n\r\n        nodes[0].push(nodes[1]);\r\n        nodes[0].push(nodes[2]);\r\n\r\n        nodes[1].push(nodes[3]);\r\n        nodes[1].push(nodes[4]);\r\n\r\n        nodes[2].push(nodes[5]);\r\n        nodes[2].push(nodes[6]);\r\n\r\n        let outSortedDFS = []\r\n        const dfs = (node: Node) => {\r\n            if (node.visit) { return; }\r\n            node.visit = true;\r\n            outSortedDFS.push(node);\r\n            for (let i = 0; i < node.connection.length; ++i) {\r\n                dfs(node.connection[i])\r\n            }\r\n        }\r\n\r\n        dfs(nodes[0]);\r\n        // console.log(\"DFS!\", outSortedDFS)\r\n        // console.log('done');\r\n\r\n\r\n        // ........................................... DFS\r\n\r\n\r\n        aStartPropagation()\r\n\r\n\r\n    }\r\n    public destroy() {\r\n\r\n    }\r\n}\r\n\r\nclass Node {\r\n    public visit: boolean = false;\r\n    public id: number = -1;\r\n    public connection: Node[] = [];\r\n    constructor(id: number) {\r\n        this.id = id;\r\n    }\r\n    public push(other: Node) {\r\n        this.connection.push(other);\r\n        other.connection.push(this);\r\n    }\r\n}\r\n\r\nexport const aStartPropagation = () => {\r\n    // const pixelMap = new PixelMap();\r\n    //           N0\r\n    //          /  \\\r\n    //        N1    N2\r\n    //        /\\    /\\\r\n    //      N3 N4  N5 N6\r\n    //      /\r\n    //     N7\r\n\r\n    let n0 = new NodeAStart(0, 0, 0);\r\n    let n1 = new NodeAStart(-1, 1, 1);\r\n    let n2 = new NodeAStart(1, 1, 2);\r\n    let n3 = new NodeAStart(-2, 2, 3);\r\n    let n4 = new NodeAStart(-1, 2, 4);\r\n    let n5 = new NodeAStart(1, 2, 5);\r\n    let n6 = new NodeAStart(2, 2, 6);\r\n    let n7 = new NodeAStart(-2, 3, 7);\r\n\r\n    n0.neighbors.push(n1, n2);\r\n    n1.neighbors.push(n0, n3, n4);\r\n    n2.neighbors.push(n0, n5, n6);\r\n    n3.neighbors.push(n1);\r\n    n4.neighbors.push(n1);\r\n    n5.neighbors.push(n2);\r\n    n6.neighbors.push(n2);\r\n    n7.neighbors.push(n3);\r\n\r\n\r\n\r\n    // console.log('graph.gePath', AStart.gePath(n7, n6, AStart.TYPE.Euclidean));\r\n}\r\n\r\nexport class AStart {\r\n    public static TYPE = {\r\n        Manhattan: 'Manhattan  ',\r\n        Euclidean: 'Euclidean ',\r\n    }\r\n    public static strength = 0.01;\r\n    public static distanceManhattan = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => {\r\n        return Math.abs(x0 - x1) + Math.abs(y0 - y1) + Math.abs(z0 - z1);\r\n    }\r\n    public static distanceEuclidean = (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => {\r\n        return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));\r\n    }\r\n    public static gePath = (startNode, endNode, type: string) => {\r\n        this.typeHeuristic = this.distanceEuclidean;\r\n        if (type === AStart.TYPE.Manhattan) {\r\n            this.typeHeuristic = this.distanceManhattan;\r\n        }\r\n\r\n        const openNodes = [startNode];\r\n        const closedNodes: NodeAStart[] = [];\r\n        let result = undefined;\r\n        let count = 100;\r\n        while (count--) {\r\n            result = this.propagation(openNodes, closedNodes, endNode);\r\n            if (result !== undefined && result.length) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private static path: NodeAStart[] = [];\r\n    private static propagation = (openNodes, closedNodes, endNode) => {\r\n        if (openNodes.length > 0) {\r\n            // console.log(openNodes)\r\n            //find the lowest f in open nodes\r\n            let lowestF = 0;\r\n            for (let i = 0; i < openNodes.length; i++) {\r\n                if (openNodes[i].f < openNodes[lowestF].f) {\r\n                    lowestF = i;\r\n                }\r\n\r\n                if (openNodes[i].f === openNodes[lowestF].f) {\r\n                    if (openNodes[i].g > openNodes[lowestF].g) {\r\n                        lowestF = i;\r\n                    }\r\n                }\r\n            }\r\n            let current: NodeAStart = openNodes[lowestF];\r\n\r\n            if (current === endNode) {\r\n                //reached the end node so wait a sec and restart\r\n                return [current, current.previous, ...this.path];\r\n            }\r\n\r\n            //calculate path\r\n            this.path = [];\r\n            let temp = current;\r\n            while (temp.previous) {\r\n                this.path.push(temp.previous);\r\n                temp = temp.previous;\r\n            }\r\n            // console.log(this.path.length);\r\n\r\n            openNodes.splice(openNodes.indexOf(current), 1);\r\n            closedNodes.push(current);\r\n\r\n            let neighbors = current.neighbors;\r\n            for (let i = 0; i < neighbors.length; i++) {\r\n                let neighbor = neighbors[i];\r\n\r\n                if (!closedNodes.includes(neighbor) && !neighbor.blocked) {\r\n                    let tempG = current.g + this.heuristic(neighbor, current) * this.strength;\r\n\r\n                    if (!openNodes.includes(neighbor)) {\r\n                        openNodes.push(neighbor);\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n\r\n                    neighbor.g = tempG;\r\n                    neighbor.h = this.heuristic(neighbor, endNode);\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    neighbor.previous = current\r\n                }\r\n            }\r\n            return undefined;\r\n        } else {\r\n            return this.path;\r\n        }\r\n    }\r\n    private static typeHeuristic: (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => number;\r\n    private static heuristic = (a: NodeAStart, b: NodeAStart) => {\r\n        let d = 0;\r\n        return this.typeHeuristic(a.x, a.y, a.z, b.x, b.y, b.z);\r\n    }\r\n\r\n}\r\nexport class NodeAStart {\r\n    public id = -1;\r\n\r\n    public f = 0;\r\n    public h = 0;\r\n\r\n    public g = 0;\r\n\r\n    public x = 0;\r\n    public y = 0;\r\n    public z = 0;\r\n    public neighbors: NodeAStart[] = [];\r\n    public previous = undefined;\r\n    public blocked = false;\r\n    constructor(x: number, y: number, id: number) {\r\n        this.id = id;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n}\r\n\r\n"],"names":["Solution","constructor","id","nodes","i","push","Node","num","outSortedBFS","queue","visit","length","current","shift","connection","other","bfs","outSortedDFS","dfs","node","aStartPropagation","destroy","this","n0","NodeAStart","n1","n2","n3","n4","n5","n6","n7","neighbors","AStart","TYPE","Manhattan","Euclidean","strength","distanceManhattan","x0","y0","z0","x1","y1","z1","Math","abs","distanceEuclidean","sqrt","gePath","startNode","endNode","type","typeHeuristic","openNodes","closedNodes","result","count","propagation","undefined","path","lowestF","f","g","previous","temp","splice","indexOf","neighbor","includes","blocked","tempG","heuristic","h","a","b","x","y","z"],"sourceRoot":""}